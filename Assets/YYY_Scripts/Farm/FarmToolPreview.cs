using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic;

namespace FarmGame.Farm
{
    /// <summary>
    /// å†œç”°å·¥å…·é¢„è§ˆç»„ä»¶
    /// è´Ÿè´£æ˜¾ç¤ºé”„å¤´/æ°´å£¶çš„é¢„è§ˆæ•ˆæœ
    /// 
    /// ç‰¹æ€§ï¼š
    /// - è‡ªç”Ÿèƒ½åŠ›ï¼šAwake æ—¶è‡ªåŠ¨åˆ›å»ºç¼ºå¤±çš„ GhostTilemap å’Œ CursorRenderer
    /// - 1+8 é¢„è§ˆï¼šé”„å¤´æ˜¾ç¤ºä¸­å¿ƒå— + å‘¨å›´ 8 æ ¼è¾¹ç•Œå˜åŒ–
    /// - é¢œè‰²åé¦ˆï¼šç»¿è‰²=å¯ç”¨ï¼Œçº¢è‰²=ä¸å¯ç”¨ï¼Œè“è‰²=æµ‡æ°´
    /// </summary>
    public class FarmToolPreview : MonoBehaviour
    {
        #region å•ä¾‹ï¼ˆLazy Singletonï¼‰
        
        private static FarmToolPreview _instance;
        
        /// <summary>
        /// å•ä¾‹è®¿é—®å™¨ï¼ˆLazy Singletonï¼‰
        /// å¦‚æœåœºæ™¯ä¸­æ²¡æœ‰ FarmToolPreviewï¼Œä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ª
        /// </summary>
        public static FarmToolPreview Instance
        {
            get
            {
                if (_instance == null)
                {
                    // å…ˆå°è¯•åœ¨åœºæ™¯ä¸­æŸ¥æ‰¾
                    _instance = FindFirstObjectByType<FarmToolPreview>();
                    
                    if (_instance == null)
                    {
                        // ğŸ”¥ çœŸæ­£çš„è‡ªç”Ÿèƒ½åŠ›ï¼šå¦‚æœåœºæ™¯æ²¡æœ‰ï¼Œç›´æ¥åˆ›å»ºä¸€ä¸ª
                        var go = new GameObject("FarmToolPreview_AutoGenerated");
                        _instance = go.AddComponent<FarmToolPreview>();
                        Debug.Log("[FarmToolPreview] è‡ªåŠ¨åˆ›å»ºå®ä¾‹ï¼ˆåœºæ™¯ä¸­æœªæ‰¾åˆ°ï¼‰");
                    }
                }
                return _instance;
            }
        }
        
        #endregion
        
        #region é¢„è§ˆçŠ¶æ€æšä¸¾
        
        public enum FarmPreviewState
        {
            Hidden,     // éšè—
            Valid,      // æœ‰æ•ˆï¼ˆç»¿è‰²ï¼‰
            Invalid     // æ— æ•ˆï¼ˆçº¢è‰²ï¼‰
        }
        
        // ğŸ”¥ 9.0.5 æ–°å¢ï¼šæµ‡æ°´å¤±è´¥åŸå› 
        public enum WateringFailureReason
        {
            None,           // æ— å¤±è´¥
            NoFarmland,     // æ²¡æœ‰è€•åœ°æ•°æ®
            NotTilled,      // æœªè€•ä½œ
            AlreadyWatered, // å·²æµ‡æ°´
            HasObstacle,    // æœ‰éšœç¢ç‰©
            ManagerNull     // FarmTileManager ä¸º null
        }
        
        #endregion
        
        #region é…ç½®
        
        [Header("å…‰æ ‡é…ç½®")]
        [Tooltip("å…‰æ ‡ Spriteï¼ˆæ–¹å½¢æ¡†ï¼‰")]
        [SerializeField] private Sprite cursorSprite;
        
        [Tooltip("æœ‰æ•ˆæ—¶çš„é¢œè‰²ï¼ˆç»¿è‰²ï¼‰")]
        [SerializeField] private Color validColor = new Color(0f, 1f, 0f, 0.5f);
        
        [Tooltip("æ— æ•ˆæ—¶çš„é¢œè‰²ï¼ˆçº¢è‰²ï¼‰")]
        [SerializeField] private Color invalidColor = new Color(1f, 0f, 0f, 0.5f);
        
        [Tooltip("æµ‡æ°´æ—¶çš„é¢œè‰²ï¼ˆè“è‰²ï¼‰")]
        [SerializeField] private Color wateringColor = new Color(0f, 0.5f, 1f, 0.5f);
        
        [Header("é¢„è§ˆé€æ˜åº¦")]
        [SerializeField, Range(0.1f, 1f)] private float previewAlpha = 0.5f;
        
        [Header("Debug")]
        [SerializeField] private bool showDebugInfo = false;
        
        #endregion
        
        #region è¿è¡Œæ—¶å¼•ç”¨ï¼ˆè‡ªåŠ¨åˆ›å»ºï¼‰
        
        private Tilemap ghostTilemap;
        private TilemapRenderer ghostTilemapRenderer;
        private SpriteRenderer cursorRenderer;
        
        #endregion
        
        #region çŠ¶æ€
        
        private FarmPreviewState currentState = FarmPreviewState.Hidden;
        private Vector3Int lastCellPosition;
        private int lastLayerIndex = -1;
        private bool isHoeMode = false; // true=é”„å¤´, false=æ°´å£¶
        private bool isSeedMode = false; // ğŸ”¥ æ–°å¢ï¼šç§å­æ¨¡å¼
        
        // ğŸ”¥ æ–°å¢ï¼šå½“å‰ Sorting Layer ç¼“å­˜
        private string currentSortingLayer = "Layer 1";
        
        // ğŸ”¥ 9.0.4 æ–°å¢ï¼šå…¬å¼€å±æ€§ä¾› GameInputManager æŸ¥è¯¢
        /// <summary>
        /// å½“å‰ç›®æ ‡æ˜¯å¦åœ¨ä½¿ç”¨è·ç¦»å†…
        /// </summary>
        public bool IsInRange { get; private set; }
        
        /// <summary>
        /// å½“å‰å…‰æ ‡ä½ç½®ï¼ˆæ ¼å­ä¸­å¿ƒä¸–ç•Œåæ ‡ï¼‰
        /// </summary>
        public Vector3 CurrentCursorPos { get; private set; }
        
        /// <summary>
        /// å½“å‰ç›®æ ‡çš„æ ¼å­åæ ‡
        /// </summary>
        public Vector3Int CurrentCellPos { get; private set; }
        
        /// <summary>
        /// å½“å‰ç›®æ ‡çš„æ¥¼å±‚ç´¢å¼•
        /// </summary>
        public int CurrentLayerIndex { get; private set; }
        
        // ğŸ”¥ æ–°å¢ï¼šç§å­é¢œè‰²
        [Header("ç§å­é¢„è§ˆé…ç½®")]
        [SerializeField] private Color seedValidColor = new Color(0f, 0.8f, 0.2f, 0.6f);
        [SerializeField] private Color seedInvalidColor = new Color(1f, 0.2f, 0f, 0.6f);
        
        // ç¼“å­˜å½“å‰é¢„è§ˆçš„ Tilesï¼ˆç”¨äºæ¸…é™¤ï¼‰
        private HashSet<Vector3Int> currentPreviewPositions = new HashSet<Vector3Int>();
        
        // ğŸ”¥ è¯Šæ–­æ—¥å¿—å»é‡æ ‡å¿—
        private bool _hasLoggedDiagnostics = false;
        private bool _hasLoggedPreviewTiles = false;
        
        // === ğŸ”´ è¡¥ä¸004ï¼šé”å®šæœºåˆ¶å·²ç§»é™¤ï¼ˆæ¨¡å—Aï¼‰ ===
        
        // ğŸ”´ è¡¥ä¸004 æ¨¡å—Bï¼šå·®å¼‚åŒ– ghost tile æ•°æ®ç¼“å­˜ï¼ˆä¾›å…¥é˜Ÿæ—¶å¤åˆ¶ï¼‰
        private Dictionary<Vector3Int, TileBase> _currentGhostTileData;
        /// <summary>
        /// å½“å‰ ghost é¢„è§ˆçš„å·®å¼‚åŒ– tile æ•°æ®å¿«ç…§ï¼ˆè€•åœ°æ¨¡å¼ï¼‰ã€‚
        /// å…¥é˜Ÿæ—¶å¤åˆ¶æ­¤æ•°æ®åˆ°é˜Ÿåˆ—é¢„è§ˆï¼Œç¡®ä¿ä¸‰å±‚æ•°æ®ä¸€è‡´ã€‚
        /// </summary>
        public Dictionary<Vector3Int, TileBase> CurrentGhostTileData => _currentGhostTileData;
        
        // ğŸ”´ V6 æ¨¡å—Sï¼šé”„å¤´çŠ¶æ€æš´éœ²ï¼ˆä¾› TryEnqueueFarmTool åˆ¤æ–­å…¥é˜Ÿç±»å‹ï¼‰
        private bool _canTill;
        private bool _hasCrop;
        public bool CanTill => _canTill;
        public bool HasCrop => _hasCrop;
        
        // ğŸ”´ è¡¥ä¸004 æ¨¡å—Cï¼šæµ‡æ°´ ghost ç¼“å­˜ï¼ˆè¿›å…¥æ–°æ ¼å­æ‰éšæœºï¼‰
        private Vector3Int _lastWateringCellPos = new Vector3Int(int.MinValue, int.MinValue, 0);
        private int _cachedPuddleVariant = -1;
        
        // ğŸ”´ V6 æ¨¡å—Tï¼šæµ‡æ°´éšæœºé‡å†™ï¼ˆåˆ‡æ¢æ—¶éšæœº + 003ä¿®å¤å…¥é˜Ÿç¬é—´éšæœºï¼‰
        private bool _wateringModeInitialized = false;
        // 003ä¿®å¤ï¼š_needsNewPuddleVariant å·²åºŸå¼ƒï¼ˆéšæœºç§»åˆ°å…¥é˜Ÿç¬é—´ï¼‰
        /// <summary>
        /// å½“å‰æµ‡æ°´ ghost çš„ puddleVariantï¼ˆä¾›å…¥é˜Ÿæ—¶å¤åˆ¶ï¼‰ã€‚
        /// </summary>
        public int CurrentPuddleVariant => _cachedPuddleVariant;
        
        // ğŸ”¥ 9.0.5 æ–°å¢ï¼šæµ‡æ°´å¤±è´¥åŸå› 
        public WateringFailureReason LastWateringFailure { get; private set; } = WateringFailureReason.None;
        
        // === ğŸ”´ è¡¥ä¸003 æ¨¡å—Hï¼šé¢„è§ˆç³»ç»Ÿå…¨é¢æ”¹é€  ===
        
        // åŒ Tilemap åˆ†ç¦»ï¼ˆCP-H4ï¼‰
        private Tilemap queuePreviewTilemap;
        private TilemapRenderer queuePreviewTilemapRenderer;
        
        // ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M1ï¼‰ï¼šshader é¢œè‰²å åŠ  Materialï¼ˆæ›¿ä»£æ–¹æ¡ˆCçš„ SpriteRenderer è¦†ç›–å±‚ï¼‰
        private Material previewOverlayMaterial;
        
        // ç§å­é¢„è§ˆ â€” å¤åˆ»æ”¾ç½®ç³»ç»Ÿï¼ˆCP-H3ï¼‰
        private SpriteRenderer seedPreviewRenderer;
        private SpriteRenderer seedGridRenderer;
        private Sprite gridSprite;  // ç¨‹åºåŒ–æ ¼å­æ–¹æ¡† sprite
        
        // ç§å­é˜Ÿåˆ—é¢„è§ˆå¯¹è±¡æ± ï¼ˆCP-H6ï¼‰
        private List<SpriteRenderer> seedQueuePool = new List<SpriteRenderer>();
        private List<(Vector3Int cellPos, SpriteRenderer renderer)> activeSeedQueuePreviews = new List<(Vector3Int, SpriteRenderer)>();
        
        // é˜Ÿåˆ—é¢„è§ˆä½ç½®ç¼“å­˜
        private HashSet<Vector3Int> queuePreviewPositions = new HashSet<Vector3Int>();
        
        // ğŸ”´ V3 æ¨¡å—Kï¼ˆCP-K1ï¼‰ï¼šè€•åœ°é˜Ÿåˆ— tile ç»„è¿½è¸ªï¼ˆä¸­å¿ƒç‚¹ â†’ å…³è”çš„æ‰€æœ‰ tile ä½ç½®ï¼‰
        private Dictionary<Vector3Int, List<Vector3Int>> tillQueueTileGroups = new Dictionary<Vector3Int, List<Vector3Int>>();
        
        // ğŸ”´ è¡¥ä¸004 æ¨¡å—Dï¼šæ‰§è¡Œé¢„è§ˆè¿½è¸ªï¼ˆæ­£åœ¨æ‰§è¡ŒåŠ¨ç”»çš„æ“ä½œï¼Œå—ä¿æŠ¤ä¸è¢« WASD æ¸…é™¤ï¼‰
        private Dictionary<Vector3Int, List<Vector3Int>> executingTileGroups = new Dictionary<Vector3Int, List<Vector3Int>>();
        private HashSet<Vector3Int> executingWaterPositions = new HashSet<Vector3Int>();
        private List<(Vector3Int cellPos, SpriteRenderer renderer)> executingSeedPreviews = new List<(Vector3Int, SpriteRenderer)>();
        
        // é¢œè‰²é…ç½®
        [Header("è¡¥ä¸003 è¦†ç›–å±‚é¢œè‰²")]
        [SerializeField] private Color overlayValidColor = new Color(0f, 1f, 0f, 0.3f);
        [SerializeField] private Color overlayInvalidColor = new Color(1f, 0f, 0f, 0.3f);
        [SerializeField] private float queuePreviewAlpha = 0.5f;
        
        #endregion
        
        #region ç”Ÿå‘½å‘¨æœŸ
        
        private void Awake()
        {
            if (_instance == null)
            {
                _instance = this;
                EnsureComponents();
            }
            else if (_instance != this)
            {
                Destroy(gameObject);
            }
        }
        
        private void OnDestroy()
        {
            if (_instance == this)
            {
                _instance = null;
            }
        }
        
        /// <summary>
        /// è‡ªç”Ÿèƒ½åŠ›ï¼šç¡®ä¿æ‰€æœ‰å¿…è¦ç»„ä»¶å­˜åœ¨
        /// </summary>
        private void EnsureComponents()
        {
            // ğŸ”¥ é¦–å…ˆç¡®ä¿æœ‰ Grid ç»„ä»¶ï¼ˆTilemap å¿…é¡»åœ¨ Grid ä¸‹æ‰èƒ½æ­£ç¡®æ˜¾ç¤ºï¼‰
            var grid = GetComponent<Grid>();
            if (grid == null)
            {
                grid = gameObject.AddComponent<Grid>();
                grid.cellSize = new Vector3(1f, 1f, 0f); // æ ‡å‡† 1x1 æ ¼å­
                grid.cellGap = Vector3.zero;
                grid.cellLayout = GridLayout.CellLayout.Rectangle;
                grid.cellSwizzle = GridLayout.CellSwizzle.XYZ;
            }
            
            // 1. ç¡®ä¿ GhostTilemap å­˜åœ¨
            if (ghostTilemap == null)
            {
                var ghostGO = transform.Find("GhostTilemap");
                if (ghostGO == null)
                {
                    ghostGO = new GameObject("GhostTilemap").transform;
                    ghostGO.SetParent(transform);
                    ghostGO.localPosition = Vector3.zero;
                }
                
                ghostTilemap = ghostGO.GetComponent<Tilemap>();
                if (ghostTilemap == null)
                {
                    ghostTilemap = ghostGO.gameObject.AddComponent<Tilemap>();
                }
                
                ghostTilemapRenderer = ghostGO.GetComponent<TilemapRenderer>();
                if (ghostTilemapRenderer == null)
                {
                    ghostTilemapRenderer = ghostGO.gameObject.AddComponent<TilemapRenderer>();
                }
                
                // è®¾ç½® Sorting Layerï¼ˆä½¿ç”¨é¡¹ç›®ä¸­å­˜åœ¨çš„ Layer 1ï¼Œé«˜ sortingOrder ç¡®ä¿åœ¨åœ°é¢ä¹‹ä¸Šï¼‰
                ghostTilemapRenderer.sortingLayerName = "Layer 1";
                ghostTilemapRenderer.sortingOrder = 9999; // æé«˜å€¼ç¡®ä¿åœ¨æ‰€æœ‰åœ°é¢ Tile ä¹‹ä¸Š
                
                // è®¾ç½®é€æ˜åº¦
                ghostTilemap.color = new Color(1f, 1f, 1f, previewAlpha);
                
                if (showDebugInfo)
                    Debug.Log("[FarmToolPreview] è‡ªåŠ¨åˆ›å»º GhostTilemapï¼ˆå« Gridï¼‰");
            }
            
            // 2. ç¡®ä¿ CursorRenderer å­˜åœ¨
            if (cursorRenderer == null)
            {
                var cursorGO = transform.Find("CursorRenderer");
                if (cursorGO == null)
                {
                    cursorGO = new GameObject("CursorRenderer").transform;
                    cursorGO.SetParent(transform);
                    cursorGO.localPosition = Vector3.zero;
                }
                
                cursorRenderer = cursorGO.GetComponent<SpriteRenderer>();
                if (cursorRenderer == null)
                {
                    cursorRenderer = cursorGO.gameObject.AddComponent<SpriteRenderer>();
                }
                
                // è®¾ç½® Sorting Layerï¼ˆä½¿ç”¨é¡¹ç›®ä¸­å­˜åœ¨çš„ Layer 1ï¼Œé«˜ sortingOrder ç¡®ä¿åœ¨é¢„è§ˆ Tilemap ä¹‹ä¸Šï¼‰
                cursorRenderer.sortingLayerName = "Layer 1";
                cursorRenderer.sortingOrder = 10000; // æ¯” ghostTilemap æ›´é«˜
                
                // è®¾ç½® Spriteï¼ˆå¦‚æœæ²¡æœ‰é…ç½®ï¼Œç¨‹åºåŒ–ç”Ÿæˆä¸€ä¸ªç™½è‰²æ–¹æ¡†ï¼‰
                if (cursorSprite != null)
                {
                    cursorRenderer.sprite = cursorSprite;
                }
                else
                {
                    // ğŸ”¥ ç¨‹åºåŒ–ç”Ÿæˆå…‰æ ‡ Spriteï¼ˆ1x1 ç™½è‰² Textureï¼‰
                    cursorRenderer.sprite = CreateProceduralCursorSprite();
                    if (showDebugInfo)
                        Debug.Log("[FarmToolPreview] ç¨‹åºåŒ–ç”Ÿæˆå…‰æ ‡ Spriteï¼ˆæœªé…ç½® cursorSpriteï¼‰");
                }
                
                if (showDebugInfo)
                    Debug.Log("[FarmToolPreview] è‡ªåŠ¨åˆ›å»º CursorRenderer");
            }
            
            // === ğŸ”´ è¡¥ä¸003 æ¨¡å—Hï¼šæ–°å¢ç»„ä»¶åˆå§‹åŒ– ===
            
            // 3. queuePreviewTilemapï¼ˆé˜Ÿåˆ—é¢„è§ˆä¸“ç”¨ï¼‰
            if (queuePreviewTilemap == null)
            {
                var queueGO = transform.Find("QueuePreviewTilemap");
                if (queueGO == null)
                {
                    queueGO = new GameObject("QueuePreviewTilemap").transform;
                    queueGO.SetParent(transform, false);
                    queueGO.localPosition = Vector3.zero;
                }
                queuePreviewTilemap = queueGO.GetComponent<Tilemap>();
                if (queuePreviewTilemap == null)
                    queuePreviewTilemap = queueGO.gameObject.AddComponent<Tilemap>();
                queuePreviewTilemapRenderer = queueGO.GetComponent<TilemapRenderer>();
                if (queuePreviewTilemapRenderer == null)
                    queuePreviewTilemapRenderer = queueGO.gameObject.AddComponent<TilemapRenderer>();
                queuePreviewTilemapRenderer.sortingLayerName = "Layer 1";
                queuePreviewTilemapRenderer.sortingOrder = 9998;
                queuePreviewTilemap.color = new Color(1f, 1f, 1f, queuePreviewAlpha);
            }
            
            // 4. ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M1ï¼‰ï¼šåŠ è½½ FarmPreviewOverlay shader å¹¶åˆ›å»º Material
            if (previewOverlayMaterial == null)
            {
                var shader = Shader.Find("Custom/FarmPreviewOverlay");
                if (shader != null)
                {
                    previewOverlayMaterial = new Material(shader);
                    previewOverlayMaterial.SetColor("_OverlayColor", Color.clear); // é»˜è®¤æ— å åŠ 
                }
                else
                {
                    Debug.LogWarning("[FarmToolPreview] FarmPreviewOverlay shader æœªæ‰¾åˆ°ï¼ŒghostTilemap å°†ä½¿ç”¨é»˜è®¤ Material");
                }
            }
            // èµ‹ç»™ ghostTilemapRenderer
            if (previewOverlayMaterial != null && ghostTilemapRenderer != null)
            {
                ghostTilemapRenderer.material = previewOverlayMaterial;
            }
            
            // 5. ç¨‹åºåŒ–æ ¼å­ Sprite ç”Ÿæˆï¼ˆç§å­é¢„è§ˆç”¨ï¼‰
            if (gridSprite == null)
                gridSprite = CreateGridSprite();
            
            // 6. ç§å­é¢„è§ˆç»„ä»¶
            if (seedGridRenderer == null)
            {
                var seedGridGO = new GameObject("SeedGridRenderer");
                seedGridGO.transform.SetParent(transform, false);
                seedGridRenderer = seedGridGO.AddComponent<SpriteRenderer>();
                seedGridRenderer.sprite = gridSprite;
                seedGridRenderer.sortingLayerName = "Layer 1";
                seedGridRenderer.sortingOrder = 10000;
                seedGridRenderer.enabled = false;
            }
            if (seedPreviewRenderer == null)
            {
                var seedPreviewGO = new GameObject("SeedPreviewRenderer");
                seedPreviewGO.transform.SetParent(transform, false);
                seedPreviewRenderer = seedPreviewGO.AddComponent<SpriteRenderer>();
                seedPreviewRenderer.sortingLayerName = "Layer 1";
                seedPreviewRenderer.sortingOrder = 10001;
                seedPreviewRenderer.enabled = false;
            }
        }
        
        #endregion
        
        #region å…¬å¼€æ¥å£
        
        // === ğŸ”´ è¡¥ä¸004 æ¨¡å—Aï¼šé”å®šæœºåˆ¶å…¬å¼€æ¥å£å·²ç§»é™¤ ===
        
        // ğŸ”´ è¡¥ä¸004 æ¨¡å—Aï¼šLockPosition å·²ç§»é™¤ï¼ˆghost æ°¸ä¸é”å®šï¼Œæ¯å¸§è·Ÿéšé¼ æ ‡ï¼‰
        
        // ğŸ”´ è¡¥ä¸004 æ¨¡å—Aï¼šUnlockPosition å·²ç§»é™¤
        
        /// <summary>
        /// ğŸ”¥ é‡æ„ï¼šæ›´æ–°é”„å¤´é¢„è§ˆ
        /// æ–°å¢å‚æ•°ï¼šplayerTransform å’Œ reach ç”¨äºè·ç¦»æ£€æµ‹
        /// ğŸ”¥ 9.0.4ï¼šIsValid ä¸å†åŒ…å«è·ç¦»åˆ¤æ–­ï¼Œè·ç¦»çŠ¶æ€å•ç‹¬è®°å½•åˆ° IsInRange
        /// </summary>
        /// <param name="layerIndex">æ¥¼å±‚ç´¢å¼•</param>
        /// <param name="cellPos">æ ¼å­åæ ‡</param>
        /// <param name="playerTransform">ç©å®¶ Transformï¼ˆç”¨äºè·ç¦»æ£€æµ‹å’Œ Layer åŒæ­¥ï¼‰</param>
        /// <param name="reach">å·¥å…·ä½¿ç”¨è·ç¦»</param>
        public void UpdateHoePreview(int layerIndex, Vector3Int cellPos, Transform playerTransform = null, float reach = 1.5f)
        {
            isHoeMode = true;
            isSeedMode = false;
            
            // ğŸ”´ V6 æ¨¡å—Tï¼ˆT6ï¼‰ï¼šåˆ‡æ¢åˆ°é”„å¤´æ—¶é‡ç½®æµ‡æ°´æ¨¡å¼æ ‡å¿—
            _wateringModeInitialized = false;
            LogDiagnosticsOnce();
            
            // ğŸ”¥ Step 1: æ›´æ–° Sorting Layerï¼ˆè·Ÿéšç©å®¶æ¥¼å±‚ï¼‰
            if (playerTransform != null)
            {
                UpdateSortingLayer(playerTransform);
            }
            
            // è·å–æ ¼å­ä¸­å¿ƒä¸–ç•Œåæ ‡
            Vector3 cellCenter = GetCellCenterWorld(layerIndex, cellPos);
            
            // ğŸ”¥ Step 2: éšœç¢ç‰©æ£€æµ‹ï¼ˆä½¿ç”¨ HasFarmingObstacleï¼Œä¸æ£€æµ‹ Playerï¼‰
            bool hasObstacle = PlacementValidator.HasFarmingObstacle(cellCenter);
            
            // ğŸ”¥ Step 3: æ£€æŸ¥æ˜¯å¦å¯ä»¥é”„åœ°
            bool canTill = FarmTileManager.Instance != null && 
                           FarmTileManager.Instance.CanTillAt(layerIndex, cellPos);
            
            // ğŸ”¥ 10.X çº æ­£ï¼šé€šè¿‡ FarmTileData.cropController æŸ¥æ‰¾æ¯èä½œç‰©ï¼ˆæ›¿ä»£ CropManager.GetCropï¼‰
            bool canClearWithered = false;
            if (!canTill && FarmTileManager.Instance != null)
            {
                var tileData = FarmTileManager.Instance.GetTileData(layerIndex, cellPos);
                if (tileData?.cropController != null && tileData.cropController.GetState() == CropState.WitheredImmature)
                    canClearWithered = true;
            }
            
            // ğŸ”´ V6 æ¨¡å—Sï¼ˆCP-S1/S5ï¼‰ï¼šæ£€æµ‹ä»»ä½•çŠ¶æ€çš„å†œä½œç‰©
            bool hasCrop = false;
            if (!canTill && FarmTileManager.Instance != null)
            {
                var tileData = FarmTileManager.Instance.GetTileData(layerIndex, cellPos);
                if (tileData?.cropController != null)
                    hasCrop = true;
            }
            
            // ğŸ”´ V6 æ¨¡å—N'ï¼ˆCP-N1ï¼‰ï¼šb å±‚ç»Ÿä¸€æ‹¦æˆªï¼ˆå·²åœ¨é˜Ÿåˆ—ä¸­çš„æ ¼å­ç»Ÿç»Ÿæ— æ•ˆï¼‰
            if (queuePreviewPositions.Contains(cellPos))
            {
                canTill = false;
                hasCrop = false;
            }
            
            // ğŸ”´ V6 æ¨¡å—Sï¼šæš´éœ²çŠ¶æ€ä¾› TryEnqueueFarmTool ä½¿ç”¨
            _canTill = canTill;
            _hasCrop = hasCrop;
            
            // ğŸ”¥ 9.0.4 ä¿®æ”¹ï¼šIsValid ä¸å†åŒ…å«è·ç¦»åˆ¤æ–­
            bool isValid = !hasObstacle && (canTill || hasCrop);
            
            // æ›´æ–°çŠ¶æ€
            currentState = isValid ? FarmPreviewState.Valid : FarmPreviewState.Invalid;
            
            // ğŸ”¥ 9.0.5ï¼šæ°¸è¿œæ›´æ–°å®æ—¶æ•°æ®ï¼ˆä¸ç®¡æ˜¯å¦é”å®šï¼‰
            UpdateRealtimeData(layerIndex, cellPos, cellCenter, playerTransform, reach);
            
            // ğŸ”´ è¡¥ä¸004 æ¨¡å—Aï¼šç§»é™¤ _isLocked æ£€æŸ¥ï¼Œghost æ¯å¸§æ›´æ–°
            
            // ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M2ï¼‰ï¼šéšè—ç§å­é¢„è§ˆ
            if (seedGridRenderer != null) seedGridRenderer.enabled = false;
            if (seedPreviewRenderer != null) seedPreviewRenderer.enabled = false;
            
            // æ¸…é™¤æ—§é¢„è§ˆ
            ClearGhostTilemap();
            
            // ğŸ”´ V3 æ¨¡å—Mï¼šè€•åœ°ä¸éœ€è¦æ–¹æ¡†å…‰æ ‡
            if (cursorRenderer != null) cursorRenderer.enabled = false;
            
            // å¦‚æœå¯ä»¥é”„åœ°ï¼Œæ˜¾ç¤ºå·®å¼‚åŒ–é¢„è§ˆï¼ˆğŸ”´ è¡¥ä¸004V3ï¼ša å±‚å¯¹ b+c éƒ½åšå¢é‡ï¼‰
            if (canTill && FarmlandBorderManager.Instance != null)
            {
                // ğŸ”´ 003ä¿®å¤ï¼šæ„å»ºè”åˆé›†åˆï¼ˆbå±‚ + æ‰§è¡Œå±‚ï¼‰ï¼Œå¡«è¡¥æ‰§è¡Œæ€çœŸç©ºæœŸ
                var combinedPositions = new HashSet<Vector3Int>(queuePreviewPositions);
                foreach (var key in executingTileGroups.Keys)
                    combinedPositions.Add(key);
                foreach (var pos in executingWaterPositions)
                    combinedPositions.Add(pos);
                
                var previewTiles = FarmlandBorderManager.Instance.GetPreviewTiles(layerIndex, cellPos, combinedPositions);
                
                // ğŸ”¥ è¯Šæ–­ï¼šæ£€æŸ¥ previewTiles æ˜¯å¦ä¸ºç©ºï¼ˆä¸€æ¬¡æ€§è¾“å‡ºï¼Œä¸ä¾èµ– showDebugInfoï¼‰
                if (!_hasLoggedPreviewTiles)
                {
                    _hasLoggedPreviewTiles = true;
                    Debug.Log($"[FarmToolPreview] GetPreviewTiles è¿”å› {previewTiles.Count} ä¸ª Tile");
                    foreach (var kvp in previewTiles)
                    {
                        Debug.Log($"  - {kvp.Key}: {(kvp.Value != null ? kvp.Value.name : "null")}");
                    }
                }
                
                // ğŸ”´ è¡¥ä¸004 æ¨¡å—Bï¼ˆCP-B1ï¼‰ï¼šè·å–å®é™… tilemap ç”¨äºå·®å¼‚å¯¹æ¯”
                var tilemaps = FarmTileManager.Instance?.GetLayerTilemaps(layerIndex);
                Tilemap actualCenterTilemap = tilemaps?.farmlandCenterTilemap;
                Tilemap actualBorderTilemap = tilemaps?.farmlandBorderTilemap;
                
                // ç¼“å­˜å·®å¼‚åŒ–ç»“æœä¾›å…¥é˜Ÿæ—¶å¤åˆ¶
                if (_currentGhostTileData == null)
                    _currentGhostTileData = new Dictionary<Vector3Int, TileBase>();
                else
                    _currentGhostTileData.Clear();
                
                foreach (var kvp in previewTiles)
                {
                    if (kvp.Value == null) continue;
                    
                    // ğŸ”´ è¡¥ä¸004V3ï¼ˆCP-L1~L6ï¼‰ï¼šå¢é‡å·®é›†è¿‡æ»¤ï¼Œa å±‚å¯¹ b+c éƒ½åšå¢é‡
                    // ä¸­å¿ƒå—å¯¹æ¯” farmlandCenterTilemapï¼Œè¾¹ç•Œå¯¹æ¯” farmlandBorderTilemap + queuePreviewTilemap
                    TileBase actualTile;
                    if (kvp.Key == cellPos)
                        actualTile = actualCenterTilemap?.GetTile(kvp.Key);
                    else
                        actualTile = actualBorderTilemap?.GetTile(kvp.Key);
                    
                    // ğŸ”´ è¡¥ä¸004V3ï¼šå¦‚æœ c å±‚æ²¡æœ‰ tileï¼Œå†æ£€æŸ¥ b å±‚ï¼ˆqueuePreviewTilemapï¼‰
                    if (actualTile == null && queuePreviewTilemap != null)
                        actualTile = queuePreviewTilemap.GetTile(kvp.Key);
                    
                    if (kvp.Value == actualTile) continue;  // å®Œå…¨ç›¸åŒåˆ™è·³è¿‡
                    
                    var borderManager = FarmlandBorderManager.Instance;
                    TileBase tileToDisplay = kvp.Value; // é»˜è®¤æ˜¾ç¤ºé¢„è§ˆ tile
                    
                    if (actualTile == null)
                    {
                        // CP-L1ï¼šå…¨æ–°ä½ç½®ï¼Œç›´æ¥æ˜¾ç¤ºé¢„è§ˆ tile
                    }
                    else if (borderManager.IsShadowTile(actualTile))
                    {
                        // CP-L3ï¼šé˜´å½±â†’è¾¹ç•Œï¼ŒSorting Order è¦†ç›–
                        // ğŸ”´ Bug V ä¿®å¤ï¼šé˜´å½±åˆ†æ”¯ä¹Ÿè¦å¯¹ b å±‚ï¼ˆqueuePreviewTilemapï¼‰åšå¢é‡å·®é›†
                        if (queuePreviewTilemap != null && borderManager.IsBorderTile(kvp.Value))
                        {
                            var bLayerTile = queuePreviewTilemap.GetTile(kvp.Key);
                            if (bLayerTile != null && borderManager.IsBorderTile(bLayerTile))
                            {
                                var bDirs = borderManager.ParseDirections(bLayerTile);
                                var previewDirs = borderManager.ParseDirections(kvp.Value);
                                bool deltaU = previewDirs.hasU && !bDirs.hasU;
                                bool deltaD = previewDirs.hasD && !bDirs.hasD;
                                bool deltaL = previewDirs.hasL && !bDirs.hasL;
                                bool deltaR = previewDirs.hasR && !bDirs.hasR;
                                
                                if (!deltaU && !deltaD && !deltaL && !deltaR) continue;
                                
                                tileToDisplay = borderManager.SelectBorderTile(deltaU, deltaD, deltaL, deltaR);
                                if (tileToDisplay == null) continue;
                            }
                        }
                    }
                    else if (borderManager.IsBorderTile(actualTile) && borderManager.IsBorderTile(kvp.Value))
                    {
                        // CP-L2ï¼šè¾¹ç•Œâ†’è¾¹ç•Œï¼Œè®¡ç®—å¢é‡å·®é›†
                        var actualDirs = borderManager.ParseDirections(actualTile);
                        
                        // ğŸ”´ V6 æ¨¡å—Vï¼ˆCP-V1ï¼‰ï¼šåˆå¹¶ c+b ä¸¤å±‚æ–¹å‘åå†åšå·®é›†
                        bool mergedU = actualDirs.hasU;
                        bool mergedD = actualDirs.hasD;
                        bool mergedL = actualDirs.hasL;
                        bool mergedR = actualDirs.hasR;
                        
                        if (queuePreviewTilemap != null)
                        {
                            var bLayerTile = queuePreviewTilemap.GetTile(kvp.Key);
                            if (bLayerTile != null && borderManager.IsBorderTile(bLayerTile))
                            {
                                var bDirs = borderManager.ParseDirections(bLayerTile);
                                mergedU = mergedU || bDirs.hasU;
                                mergedD = mergedD || bDirs.hasD;
                                mergedL = mergedL || bDirs.hasL;
                                mergedR = mergedR || bDirs.hasR;
                            }
                        }
                        
                        var previewDirs = borderManager.ParseDirections(kvp.Value);
                        bool deltaU = previewDirs.hasU && !mergedU;
                        bool deltaD = previewDirs.hasD && !mergedD;
                        bool deltaL = previewDirs.hasL && !mergedL;
                        bool deltaR = previewDirs.hasR && !mergedR;
                        
                        // CP-L6ï¼šå¢é‡æ–¹å‘ä¸ºç©ºé›†æ—¶ä¸æ”¾ç½® tile
                        if (!deltaU && !deltaD && !deltaL && !deltaR) continue;
                        
                        tileToDisplay = borderManager.SelectBorderTile(deltaU, deltaD, deltaL, deltaR);
                        if (tileToDisplay == null) continue;
                    }
                    // else: CP-L4 ä¸­å¿ƒå—æ›¿æ¢ç­‰å…¶ä»–æƒ…å†µï¼Œç›´æ¥æ˜¾ç¤ºé¢„è§ˆ tile
                    
                    ghostTilemap.SetTile(kvp.Key, tileToDisplay);
                    currentPreviewPositions.Add(kvp.Key);
                    _currentGhostTileData[kvp.Key] = tileToDisplay; // ç¼“å­˜å¢é‡ tileï¼ˆéæœ€ç»ˆ tileï¼‰
                }
            }
            else if (hasCrop)
            {
                // ğŸ”´ V6 æ¨¡å—Sï¼ˆCP-S2ï¼‰ï¼šæœ‰å†œä½œç‰©çš„è€•åœ° â€” ä¸æ˜¾ç¤ºä»»ä½•é¢„è§ˆ
                _currentGhostTileData?.Clear();
                if (cursorRenderer != null) cursorRenderer.enabled = false;
                // ghostTilemap å·²è¢« ClearGhostTilemap æ¸…ç©ºï¼Œä¿æŒç©ºç™½
                
                if (!_hasLoggedPreviewTiles)
                {
                    _hasLoggedPreviewTiles = true;
                    Debug.Log($"[FarmToolPreview] hasCrop=true: ä¸æ˜¾ç¤ºä»»ä½•é¢„è§ˆ");
                }
            }
            else
            {
                // ğŸ”´ V6 æ¨¡å—Sï¼ˆCP-S3ï¼‰ï¼šæ— å†œä½œç‰©çš„å·²æœ‰è€•åœ° / å·²åœ¨é˜Ÿåˆ—ä¸­ / å…¶ä»–ä¸å¯è€•ç§ â€” æ”¾ç½®ç³»ç»ŸåŒæ¬¾çº¢æ–¹æ¡†
                _currentGhostTileData?.Clear();
                
                if (cursorRenderer != null)
                {
                    cursorRenderer.enabled = true;
                    // ğŸ”´ Bug S ä¿®å¤ï¼šä½¿ç”¨ gridSpriteï¼ˆ32x32 æ”¾ç½®ç³»ç»ŸåŒæ¬¾ï¼‰+ çº¢è‰²
                    cursorRenderer.sprite = gridSprite;
                    cursorRenderer.color = new Color(1f, 0.3f, 0.3f, 0.8f);
                    UpdateCursor(layerIndex, cellPos);
                }
                
                if (!_hasLoggedPreviewTiles)
                {
                    _hasLoggedPreviewTiles = true;
                    Debug.Log($"[FarmToolPreview] è·³è¿‡ 1+8 é¢„è§ˆ: canTill={canTill}, hasCrop={hasCrop}");
                }
            }
            
            // ğŸ”´ V6 æ¨¡å—O''ï¼ˆCP-O1ï¼‰ï¼šShader æŸ“è‰²é…åˆä¸‰åˆ†æ”¯
            if (previewOverlayMaterial != null)
            {
                if (canTill)
                    previewOverlayMaterial.SetColor("_OverlayColor", overlayValidColor);
                else
                    previewOverlayMaterial.SetColor("_OverlayColor", Color.clear);
            }
            
            // è®°å½•ä½ç½®
            lastCellPosition = cellPos;
            lastLayerIndex = layerIndex;
            
            // æ˜¾ç¤º
            Show();
        }
        
        /// <summary>
        /// ğŸ”¥ é‡æ„ï¼šæ›´æ–°æ°´å£¶é¢„è§ˆ
        /// æ–°å¢å‚æ•°ï¼šplayerTransform å’Œ reach ç”¨äºè·ç¦»æ£€æµ‹
        /// ğŸ”¥ 9.0.4ï¼šIsValid ä¸å†åŒ…å«è·ç¦»åˆ¤æ–­ï¼Œè·ç¦»çŠ¶æ€å•ç‹¬è®°å½•åˆ° IsInRange
        /// </summary>
        public void UpdateWateringPreview(int layerIndex, Vector3Int cellPos, Transform playerTransform = null, float reach = 1.5f)
        {
            isHoeMode = false;
            isSeedMode = false;
            
            // ğŸ”´ V6 æ¨¡å—Tï¼ˆCP-T1ï¼‰ï¼šåˆ‡æ¢åˆ°æ°´å£¶æ—¶éšæœºé»˜è®¤æ ·å¼
            if (!_wateringModeInitialized)
            {
                var initTiles = FarmVisualManager.Instance?.GetPuddleTiles();
                int initCount = initTiles != null ? initTiles.Length : 3;
                _cachedPuddleVariant = Random.Range(0, initCount);
                _wateringModeInitialized = true;
            }
            
            // ğŸ”¥ Step 1: æ›´æ–° Sorting Layer
            if (playerTransform != null)
            {
                UpdateSortingLayer(playerTransform);
            }
            
            // è·å–æ ¼å­ä¸­å¿ƒä¸–ç•Œåæ ‡
            Vector3 cellCenter = GetCellCenterWorld(layerIndex, cellPos);
            
            // ğŸ”¥ Step 2: éšœç¢ç‰©æ£€æµ‹
            bool hasObstacle = PlacementValidator.HasFarmingObstacle(cellCenter);
            
            // ğŸ”¥ Step 3: æ£€æŸ¥æ˜¯å¦å¯ä»¥æµ‡æ°´
            var tileData = FarmTileManager.Instance?.GetTileData(layerIndex, cellPos);
            bool canWater = tileData != null && 
                            tileData.isTilled && 
                            !tileData.wateredToday;
            
            // ğŸ”´ V6 æ¨¡å—Uï¼ˆCP-U1ï¼‰ï¼šb å±‚æ‹¦æˆªï¼ˆå·²åœ¨é˜Ÿåˆ—ä¸­çš„æ ¼å­ä¸å¯æµ‡æ°´ï¼‰
            if (canWater && queuePreviewPositions.Contains(cellPos))
                canWater = false;
            
            // ğŸ”¥ 9.0.5ï¼šè®°å½•æµ‡æ°´å¤±è´¥åŸå› 
            if (hasObstacle)
                LastWateringFailure = WateringFailureReason.HasObstacle;
            else if (FarmTileManager.Instance == null)
                LastWateringFailure = WateringFailureReason.ManagerNull;
            else if (tileData == null)
                LastWateringFailure = WateringFailureReason.NoFarmland;
            else if (!tileData.isTilled)
                LastWateringFailure = WateringFailureReason.NotTilled;
            else if (tileData.wateredToday)
                LastWateringFailure = WateringFailureReason.AlreadyWatered;
            else
                LastWateringFailure = WateringFailureReason.None;
            
            // ğŸ”¥ 9.0.4 ä¿®æ”¹ï¼šIsValid ä¸å†åŒ…å«è·ç¦»åˆ¤æ–­
            bool isValid = !hasObstacle && canWater;
            
            // æ›´æ–°çŠ¶æ€
            currentState = isValid ? FarmPreviewState.Valid : FarmPreviewState.Invalid;
            
            // ğŸ”¥ 9.0.5ï¼šæ°¸è¿œæ›´æ–°å®æ—¶æ•°æ®ï¼ˆä¸ç®¡æ˜¯å¦é”å®šï¼‰
            UpdateRealtimeData(layerIndex, cellPos, cellCenter, playerTransform, reach);
            
            // ğŸ”´ è¡¥ä¸004 æ¨¡å—Aï¼šç§»é™¤ _isLocked æ£€æŸ¥ï¼Œghost æ¯å¸§æ›´æ–°
            
            // ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M3ï¼‰ï¼šéšè—ç§å­é¢„è§ˆ
            if (seedGridRenderer != null) seedGridRenderer.enabled = false;
            if (seedPreviewRenderer != null) seedPreviewRenderer.enabled = false;
            
            // æ¸…é™¤æ—§é¢„è§ˆ
            ClearGhostTilemap();
            
            // ğŸ”´ V3 æ¨¡å—Mï¼šæµ‡æ°´ä¸éœ€è¦æ–¹æ¡†å…‰æ ‡
            if (cursorRenderer != null) cursorRenderer.enabled = false;
            
            // ğŸ”´ 003ä¿®å¤ï¼šéšæœºå·²ç§»åˆ°å…¥é˜Ÿç¬é—´ï¼ˆTryEnqueueFarmToolï¼‰ï¼Œæ­¤å¤„ä¸å†è§¦å‘éšæœº
            // _needsNewPuddleVariant æœºåˆ¶å·²åºŸå¼ƒ
            
            // ğŸ”´ V6 æ¨¡å—P'ï¼ˆCP-P1ï¼‰ï¼šæ— è®º isValid éƒ½æ”¾ç½®æ°´æ¸tileä½œä¸º shader è½½ä½“
            {
                var tiles = FarmVisualManager.Instance?.GetPuddleTiles();
                if (tiles != null && _cachedPuddleVariant >= 0 && _cachedPuddleVariant < tiles.Length)
                {
                    ghostTilemap.SetTile(cellPos, tiles[_cachedPuddleVariant]);
                    currentPreviewPositions.Add(cellPos);
                }
            }
            
            // ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M3ï¼‰ï¼šæ ¹æ® isValid è®¾ç½® ghostTilemap çš„ shader å åŠ è‰²
            if (previewOverlayMaterial != null)
            {
                previewOverlayMaterial.SetColor("_OverlayColor", isValid ? overlayValidColor : overlayInvalidColor);
            }
            
            // è®°å½•ä½ç½®
            lastCellPosition = cellPos;
            lastLayerIndex = layerIndex;
            
            // æ˜¾ç¤º
            Show();
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šæ›´æ–°ç§å­é¢„è§ˆ
        /// åªæ˜¾ç¤ºçº¢/ç»¿å…‰æ ‡ï¼Œéšè— GhostTilemap
        /// ğŸ”¥ 9.0.4ï¼šIsValid ä¸å†åŒ…å«è·ç¦»åˆ¤æ–­ï¼Œè·ç¦»çŠ¶æ€å•ç‹¬è®°å½•åˆ° IsInRange
        /// </summary>
        /// <param name="alignedPos">å¯¹é½åçš„ä¸–ç•Œåæ ‡ï¼ˆæ ¼å­ä¸­å¿ƒï¼‰</param>
        /// <param name="seedData">ç§å­æ•°æ®</param>
        /// <param name="playerTransform">ç©å®¶ Transform</param>
        /// <param name="reach">ç§æ¤è·ç¦»</param>
        public void UpdateSeedPreview(Vector3 alignedPos, FarmGame.Data.SeedData seedData, Transform playerTransform = null, float reach = 1.5f)
        {
            isHoeMode = false;
            isSeedMode = true;
            
            // ğŸ”´ V6 æ¨¡å—Tï¼ˆT6ï¼‰ï¼šåˆ‡æ¢åˆ°ç§å­æ—¶é‡ç½®æµ‡æ°´æ¨¡å¼æ ‡å¿—
            _wateringModeInitialized = false;
            
            // ğŸ”¥ Step 1: æ›´æ–° Sorting Layer
            if (playerTransform != null)
            {
                UpdateSortingLayer(playerTransform);
            }
            
            // è·å–æ¥¼å±‚å’Œæ ¼å­åæ ‡
            var farmTileManager = FarmTileManager.Instance;
            if (farmTileManager == null)
            {
                currentState = FarmPreviewState.Invalid;
                IsInRange = false;
                UpdateCursorForSeed(alignedPos, false);
                Show();
                return;
            }
            
            int layerIndex = farmTileManager.GetCurrentLayerIndex(alignedPos);
            var tilemaps = farmTileManager.GetLayerTilemaps(layerIndex);
            
            if (tilemaps == null)
            {
                currentState = FarmPreviewState.Invalid;
                IsInRange = false;
                UpdateCursorForSeed(alignedPos, false);
                Show();
                return;
            }
            
            Vector3Int cellPos = tilemaps.WorldToCell(alignedPos);
            
            // ğŸ”´ V3 æ¨¡å—Jï¼ˆCP-J1ï¼‰ï¼šä½¿ç”¨ Tilemap åŸç”Ÿåæ ‡æ›¿ä»£ PlacementGridCalculator åæ ‡
            Vector3 correctCenter = GetCellCenterWorld(layerIndex, cellPos);
            
            // ğŸ”¥ Step 2: éšœç¢ç‰©æ£€æµ‹
            bool hasObstacle = PlacementValidator.HasFarmingObstacle(correctCenter);
            
            // ğŸ”¥ Step 3: æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§æ¤
            var tileData = farmTileManager.GetTileData(layerIndex, cellPos);
            bool canPlant = tileData != null && tileData.CanPlant();
            
            // ğŸ”´ V6 æ¨¡å—P''ï¼ˆCP-P3ï¼‰ï¼šb å±‚æ‹¦æˆªï¼ˆå·²åœ¨é˜Ÿåˆ—ä¸­çš„æ ¼å­ä¸å¯æ’­ç§ï¼‰
            if (canPlant && queuePreviewPositions.Contains(cellPos))
                canPlant = false;
            
            // ğŸ”¥ Step 5: æ£€æŸ¥å­£èŠ‚ï¼ˆå¯é€‰ï¼‰
            bool correctSeason = true;
            if (seedData != null && TimeManager.Instance != null)
            {
                if (seedData.season != FarmGame.Data.Season.AllSeason)
                {
                    var currentSeason = TimeManager.Instance.GetSeason();
                    correctSeason = (int)seedData.season == (int)currentSeason;
                }
            }
            
            // ğŸ”¥ 9.0.4 ä¿®æ”¹ï¼šIsValid ä¸å†åŒ…å«è·ç¦»åˆ¤æ–­
            bool isValid = !hasObstacle && canPlant && correctSeason;
            
            // æ›´æ–°çŠ¶æ€
            currentState = isValid ? FarmPreviewState.Valid : FarmPreviewState.Invalid;
            
            // ğŸ”¥ 9.0.5ï¼šæ°¸è¿œæ›´æ–°å®æ—¶æ•°æ®ï¼ˆä¸ç®¡æ˜¯å¦é”å®šï¼‰
            UpdateRealtimeData(layerIndex, cellPos, correctCenter, playerTransform, reach);
            
            // ğŸ”´ è¡¥ä¸004 æ¨¡å—Aï¼šç§»é™¤ _isLocked æ£€æŸ¥ï¼Œghost æ¯å¸§æ›´æ–°
            
            // ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M6ï¼‰ï¼šé‡ç½® shader å åŠ è‰²ï¼ˆç§å­é¢„è§ˆä¸ä½¿ç”¨ shaderï¼‰
            if (previewOverlayMaterial != null)
                previewOverlayMaterial.SetColor("_OverlayColor", Color.clear);
            
            // æ¸…é™¤æ—§é¢„è§ˆ
            ClearGhostTilemap();
            if (ghostTilemap != null)
            {
                ghostTilemap.gameObject.SetActive(false);
            }
            
            // ğŸ”´ è¡¥ä¸003ï¼šéšè— cursorRendererï¼ˆåº•éƒ¨æ ¼å­æ–¹æ¡†å·²æ›¿ä»£ï¼‰
            if (cursorRenderer != null) cursorRenderer.enabled = false;
            
            // ğŸ”´ è¡¥ä¸003ï¼šåº•éƒ¨æ ¼å­æ–¹æ¡†ï¼ˆå¤åˆ» PlacementGridCellï¼‰
            if (seedGridRenderer != null)
            {
                seedGridRenderer.enabled = true;
                seedGridRenderer.transform.position = correctCenter;  // ğŸ”´ V3 æ¨¡å—Jï¼šä½¿ç”¨ Tilemap åŸç”Ÿåæ ‡
                seedGridRenderer.color = isValid
                    ? new Color(0f, 1f, 0f, 0.4f)   // ç»¿è‰²
                    : new Color(1f, 0f, 0f, 0.4f);   // çº¢è‰²
            }
            
            // ğŸ”´ è¡¥ä¸003ï¼šä½œç‰©ç¬¬ä¸€é˜¶æ®µ sprite é¢„è§ˆ
            if (seedPreviewRenderer != null)
            {
                seedPreviewRenderer.enabled = true;
                var cropSprite = seedData?.cropPrefab?.GetComponentInChildren<CropController>()?.GetFirstStageSprite();
                if (cropSprite != null)
                    seedPreviewRenderer.sprite = cropSprite;
                
                // ğŸ”´ 004-P2ï¼šæ¨¡æ‹Ÿ AlignSpriteBottom åç§»ï¼Œè®©é¢„è§ˆä¸å®é™…ç§æ¤é«˜åº¦ä¸€è‡´
                // CropController.AlignSpriteBottom: localPos.y = -spriteBounds.min.y
                Vector3 seedPos = correctCenter;
                if (seedPreviewRenderer.sprite != null)
                {
                    Bounds spriteBounds = seedPreviewRenderer.sprite.bounds;
                    seedPos.y += -spriteBounds.min.y;
                }
                seedPreviewRenderer.transform.position = seedPos;
                
                seedPreviewRenderer.color = isValid
                    ? new Color(1f, 1f, 1f, 0.7f)              // åŸè‰² + alpha
                    : new Color(1f, 0.5f, 0.5f, 0.7f);         // åçº¢ + alpha
            }
            
            // è®°å½•ä½ç½®
            lastCellPosition = cellPos;
            lastLayerIndex = layerIndex;
            
            // ğŸ”´ è¡¥ä¸003ï¼šç§å­é¢„è§ˆé€šè¿‡ seedGridRenderer + seedPreviewRenderer æ˜¾ç¤ºï¼Œä¸å†ä¾èµ– cursorRenderer
            Show();
        }
        
        /// <summary>
        /// æ˜¾ç¤ºé¢„è§ˆ
        /// </summary>
        public void Show()
        {
            if (!isSeedMode && ghostTilemap != null)
                ghostTilemap.gameObject.SetActive(true);
            if (cursorRenderer != null)
                cursorRenderer.gameObject.SetActive(true);
        }
        
        /// <summary>
        /// éšè—é¢„è§ˆ
        /// </summary>
        public void Hide()
        {
            currentState = FarmPreviewState.Hidden;
            isSeedMode = false;
            
            ClearGhostTilemap();
            
            if (ghostTilemap != null)
                ghostTilemap.gameObject.SetActive(false);
            if (cursorRenderer != null)
                cursorRenderer.gameObject.SetActive(false);
            
            // ğŸ”´ V3 æ¨¡å—Mï¼ˆCP-M5ï¼‰ï¼šéšè—ç§å­é¢„è§ˆç»„ä»¶
            if (seedGridRenderer != null) seedGridRenderer.enabled = false;
            if (seedPreviewRenderer != null) seedPreviewRenderer.enabled = false;
            // ğŸ”´ V3 æ¨¡å—Mï¼šé‡ç½® shader å åŠ è‰²
            if (previewOverlayMaterial != null)
                previewOverlayMaterial.SetColor("_OverlayColor", Color.clear);
            // ğŸ”´ è¡¥ä¸004 æ¨¡å—Cï¼ˆCP-C4ï¼‰ï¼šé‡ç½®æµ‡æ°´ç¼“å­˜
            _lastWateringCellPos = new Vector3Int(int.MinValue, int.MinValue, 0);
            _cachedPuddleVariant = -1;
            // æ³¨æ„ï¼šä¸æ¸…ç©ºé˜Ÿåˆ—é¢„è§ˆï¼ˆHide åªéšè—é¼ æ ‡è·Ÿéšé¢„è§ˆï¼‰
        }
        
        /// <summary>
        /// æ£€æŸ¥å½“å‰é¢„è§ˆæ˜¯å¦æœ‰æ•ˆ
        /// </summary>
        public bool IsValid()
        {
            return currentState == FarmPreviewState.Valid;
        }
        
        /// <summary>
        /// ğŸ”´ 003ä¿®å¤ï¼šå…¥é˜Ÿç¬é—´ç”± GameInputManager è°ƒç”¨ï¼Œç›´æ¥è®¾ç½®ä¸‹ä¸€æ¬¡çš„ puddleVariant
        /// </summary>
        public void SetPuddleVariant(int variant)
        {
            _cachedPuddleVariant = variant;
        }
        
        /// <summary>
        /// ğŸ”´ V6 æ¨¡å—Tï¼ˆCP-T4ï¼‰ï¼šæµ‡æ°´æ‰§è¡ŒæˆåŠŸåè°ƒç”¨ï¼Œæ ‡è®°éœ€è¦åœ¨ç§»å‡ºæ ¼å­æ—¶éšæœºæ–°æ ·å¼
        /// ğŸ”´ 003ä¿®å¤ï¼šä¸å†è®¾ç½® _needsNewPuddleVariantï¼ˆéšæœºå·²ç§»åˆ°å…¥é˜Ÿç¬é—´ï¼‰ï¼Œä»…è®°å½•ä½ç½®
        /// </summary>
        public void OnWaterExecuted(Vector3Int wateredCellPos)
        {
            // 003ä¿®å¤ï¼š_needsNewPuddleVariant å·²åºŸå¼ƒï¼Œéšæœºåœ¨å…¥é˜Ÿç¬é—´å®Œæˆ
            _lastWateringCellPos = wateredCellPos;
        }
        
        /// <summary>
        /// è·å–å½“å‰é¢„è§ˆçŠ¶æ€
        /// </summary>
        public FarmPreviewState GetState()
        {
            return currentState;
        }
        
        #endregion
        
        #region å†…éƒ¨æ–¹æ³•
        
        /// <summary>
        /// ğŸ”¥ 9.0.5 æ–°å¢ï¼šè½»é‡çº§å®æ—¶æ•°æ®æ›´æ–°ï¼ˆä¸è§¦ç¢°è§†è§‰æ¸²æŸ“ï¼‰
        /// é”å®šçŠ¶æ€ä¸‹ä¹Ÿä¼šè¢«è°ƒç”¨ï¼Œç¡®ä¿ GameInputManager èƒ½è¯»åˆ°æœ€æ–°çš„é¼ æ ‡ä½ç½®æ•°æ®
        /// </summary>
        private void UpdateRealtimeData(int layerIndex, Vector3Int cellPos, Vector3 cellCenter, Transform playerTransform, float reach)
        {
            CurrentCursorPos = cellCenter;
            CurrentCellPos = cellPos;
            CurrentLayerIndex = layerIndex;
            IsInRange = playerTransform != null ? IsWithinReach(playerTransform, cellCenter, reach) : true;
        }
        
        /// <summary>
        /// ğŸ”¥ ä¸€æ¬¡æ€§è¯Šæ–­æ—¥å¿—ï¼ˆåªåœ¨é¦–æ¬¡è°ƒç”¨æ—¶è¾“å‡ºï¼‰
        /// ç”¨äºæ’æŸ¥é¢„è§ˆä¸æ˜¾ç¤ºçš„é—®é¢˜
        /// </summary>
        private void LogDiagnosticsOnce()
        {
            if (_hasLoggedDiagnostics) return;
            _hasLoggedDiagnostics = true;
            
            Debug.Log("=== [FarmToolPreview] è¯Šæ–­ä¿¡æ¯ ===");
            
            // 1. æ£€æŸ¥ GhostTilemap
            if (ghostTilemap == null)
            {
                Debug.LogError("[FarmToolPreview] âŒ ghostTilemap ä¸º null");
            }
            else
            {
                Debug.Log($"[FarmToolPreview] âœ“ ghostTilemap å­˜åœ¨: {ghostTilemap.gameObject.name}");
                Debug.Log($"  - active: {ghostTilemap.gameObject.activeSelf}");
                Debug.Log($"  - parent Grid: {(ghostTilemap.layoutGrid != null ? ghostTilemap.layoutGrid.name : "null")}");
            }
            
            // 2. æ£€æŸ¥ GhostTilemapRenderer
            if (ghostTilemapRenderer == null)
            {
                Debug.LogError("[FarmToolPreview] âŒ ghostTilemapRenderer ä¸º null");
            }
            else
            {
                Debug.Log($"[FarmToolPreview] âœ“ ghostTilemapRenderer å­˜åœ¨");
                Debug.Log($"  - sortingLayerName: {ghostTilemapRenderer.sortingLayerName}");
                Debug.Log($"  - sortingOrder: {ghostTilemapRenderer.sortingOrder}");
                Debug.Log($"  - enabled: {ghostTilemapRenderer.enabled}");
            }
            
            // 3. æ£€æŸ¥ CursorRenderer
            if (cursorRenderer == null)
            {
                Debug.LogError("[FarmToolPreview] âŒ cursorRenderer ä¸º null");
            }
            else
            {
                Debug.Log($"[FarmToolPreview] âœ“ cursorRenderer å­˜åœ¨");
                Debug.Log($"  - sprite: {(cursorRenderer.sprite != null ? cursorRenderer.sprite.name : "null")}");
                Debug.Log($"  - sortingLayerName: {cursorRenderer.sortingLayerName}");
                Debug.Log($"  - sortingOrder: {cursorRenderer.sortingOrder}");
                Debug.Log($"  - color: {cursorRenderer.color}");
                Debug.Log($"  - enabled: {cursorRenderer.enabled}");
                Debug.Log($"  - active: {cursorRenderer.gameObject.activeSelf}");
            }
            
            // 4. æ£€æŸ¥ FarmlandBorderManager
            if (FarmlandBorderManager.Instance == null)
            {
                Debug.LogError("[FarmToolPreview] âŒ FarmlandBorderManager.Instance ä¸º nullï¼ˆåœºæ™¯ä¸­æ²¡æœ‰æ­¤ç»„ä»¶ï¼‰");
            }
            else
            {
                Debug.Log("[FarmToolPreview] âœ“ FarmlandBorderManager.Instance å­˜åœ¨");
                // éªŒè¯ Tile èµ„æº
                FarmlandBorderManager.Instance.ValidateTileResources();
            }
            
            // 5. æ£€æŸ¥ FarmTileManager
            if (FarmTileManager.Instance == null)
            {
                Debug.LogError("[FarmToolPreview] âŒ FarmTileManager.Instance ä¸º null");
            }
            else
            {
                Debug.Log($"[FarmToolPreview] âœ“ FarmTileManager.Instance å­˜åœ¨, LayerCount={FarmTileManager.Instance.LayerCount}");
            }
            
            // 6. æ£€æŸ¥ Sorting Layer æ˜¯å¦å­˜åœ¨
            Debug.Log("[FarmToolPreview] æ£€æŸ¥ Sorting Layers...");
            var sortingLayers = SortingLayer.layers;
            bool hasGround = false, hasEffects = false;
            foreach (var layer in sortingLayers)
            {
                if (layer.name == "Ground") hasGround = true;
                if (layer.name == "Effects") hasEffects = true;
            }
            Debug.Log($"  - Ground: {(hasGround ? "âœ“ å­˜åœ¨" : "âŒ ä¸å­˜åœ¨")}");
            Debug.Log($"  - Effects: {(hasEffects ? "âœ“ å­˜åœ¨" : "âŒ ä¸å­˜åœ¨")}");
            
            Debug.Log("=== è¯Šæ–­ç»“æŸ ===");
        }
        
        /// <summary>
        /// ğŸ”¥ ç¨‹åºåŒ–ç”Ÿæˆå…‰æ ‡ Sprite
        /// åˆ›å»ºä¸€ä¸ª 16x16 çš„ç™½è‰²æ–¹æ¡†ï¼ˆè¾¹æ¡† 2 åƒç´ ï¼‰
        /// </summary>
        private Sprite CreateProceduralCursorSprite()
        {
            int size = 16;
            int border = 2;
            
            var texture = new Texture2D(size, size, TextureFormat.RGBA32, false);
            texture.filterMode = FilterMode.Point;
            
            var pixels = new Color32[size * size];
            var white = new Color32(255, 255, 255, 255);
            var transparent = new Color32(0, 0, 0, 0);
            
            for (int y = 0; y < size; y++)
            {
                for (int x = 0; x < size; x++)
                {
                    // è¾¹æ¡†åŒºåŸŸä¸ºç™½è‰²ï¼Œå†…éƒ¨é€æ˜
                    bool isBorder = x < border || x >= size - border || 
                                    y < border || y >= size - border;
                    pixels[y * size + x] = isBorder ? white : transparent;
                }
            }
            
            texture.SetPixels32(pixels);
            texture.Apply();
            
            // åˆ›å»º Spriteï¼ˆ16 PPUï¼Œä¸ Tilemap å¯¹é½ï¼‰
            return Sprite.Create(texture, new Rect(0, 0, size, size), new Vector2(0.5f, 0.5f), 16f);
        }
        
        
        /// <summary>
        /// åˆ›å»ºæ ¼å­æ–¹æ¡† Spriteï¼ˆå¤åˆ» PlacementGridCell çš„ç¨‹åºåŒ–æ ¼å­ï¼‰
        /// </summary>
        private Sprite CreateGridSprite()
        {
            int size = 32;
            int border = 2;
            var texture = new Texture2D(size, size, TextureFormat.RGBA32, false);
            texture.filterMode = FilterMode.Point;
            var pixels = new Color32[size * size];
            var borderColor = new Color32(255, 255, 255, 204);  // alpha=0.8
            var fillColor = new Color32(255, 255, 255, 77);     // alpha=0.3
            for (int y = 0; y < size; y++)
            {
                for (int x = 0; x < size; x++)
                {
                    bool isBorder = x < border || x >= size - border || y < border || y >= size - border;
                    pixels[y * size + x] = isBorder ? borderColor : fillColor;
                }
            }
            texture.SetPixels32(pixels);
            texture.Apply();
            return Sprite.Create(texture, new Rect(0, 0, size, size), new Vector2(0.5f, 0.5f), 32f);
        }
        
        
        /// <summary>
        /// ä»å¯¹è±¡æ± è·å–æˆ–åˆ›å»ºç§å­é˜Ÿåˆ—é¢„è§ˆ SpriteRenderer
        /// </summary>
        private SpriteRenderer GetOrCreateSeedQueueRenderer()
        {
            if (seedQueuePool.Count > 0)
            {
                var sr = seedQueuePool[seedQueuePool.Count - 1];
                seedQueuePool.RemoveAt(seedQueuePool.Count - 1);
                return sr;
            }
            var go = new GameObject("SeedQueuePreview");
            go.transform.SetParent(transform, false);
            var renderer = go.AddComponent<SpriteRenderer>();
            renderer.sortingLayerName = "Layer 1";
            renderer.sortingOrder = 9998;
            return renderer;
        }
        
        /// <summary>
        /// æ¸…é™¤ GhostTilemap ä¸Šçš„æ‰€æœ‰é¢„è§ˆ Tiles
        /// </summary>
        private void ClearGhostTilemap()
        {
            if (ghostTilemap == null) return;
            
            foreach (var pos in currentPreviewPositions)
            {
                ghostTilemap.SetTile(pos, null);
            }
            currentPreviewPositions.Clear();
        }

        /// <summary>
        /// å…¥é˜Ÿæ—¶è°ƒç”¨ï¼šåœ¨æŒ‡å®šä½ç½®æ˜¾ç¤ºé˜Ÿåˆ—é”å®šé¢„è§ˆï¼ˆCP-H5ï¼‰
        /// </summary>
        public void AddQueuePreview(Vector3Int cellPos, int layerIndex, FarmActionType type, 
            int puddleVariant = -1, Dictionary<Vector3Int, TileBase> ghostTileData = null)
        {
            if (queuePreviewPositions.Contains(cellPos)) return;  // é˜²é‡å¤

            if (type == FarmActionType.PlantSeed)
            {
                // ç§å­é˜Ÿåˆ—é¢„è§ˆï¼šSpriteRenderer å¯¹è±¡æ± 
                var renderer = GetOrCreateSeedQueueRenderer();
                renderer.transform.position = GetCellCenterWorld(layerIndex, cellPos);
                // å°è¯•è·å–å½“å‰ç§å­çš„ç¬¬ä¸€é˜¶æ®µ sprite
                renderer.color = new Color(1f, 1f, 1f, queuePreviewAlpha);
                renderer.enabled = true;
                activeSeedQueuePreviews.Add((cellPos, renderer));
            }
            else
            {
                // è€•åœ°/æµ‡æ°´é˜Ÿåˆ—é¢„è§ˆï¼šqueuePreviewTilemap
                TileBase tile = null;
                if (type == FarmActionType.Water)
                {
                    // ğŸ”´ V3 æ¨¡å—Lï¼ˆCP-L1ï¼‰ï¼šä½¿ç”¨é¢„åˆ†é…çš„ puddleVariant è·å–ç¡®å®šæ€§ tile
                    if (puddleVariant >= 0)
                    {
                        var tiles = FarmVisualManager.Instance?.GetPuddleTiles();
                        if (tiles != null && puddleVariant < tiles.Length)
                            tile = tiles[puddleVariant];
                        else
                            tile = FarmVisualManager.Instance?.GetRandomPuddleTile(); // å…œåº•
                    }
                    else
                    {
                        tile = FarmVisualManager.Instance?.GetRandomPuddleTile(); // CP-L3ï¼šæœªåˆ†é…æ—¶å…œåº•éšæœº
                    }
                }
                else if (type == FarmActionType.Till)
                {
                    // ğŸ”´ 003ä¿®å¤ï¼šb å±‚ä¹Ÿéœ€è¦è”åˆé›†åˆï¼Œå¡«è¡¥æ‰§è¡Œæ€çœŸç©ºæœŸ
                    // ä¸å†ä¾èµ– ghostTileDataï¼ˆghost ç¼“å­˜çš„æ˜¯å¢é‡ tileï¼Œä¸é€‚åˆé˜Ÿåˆ—é¢„è§ˆï¼‰
                    Dictionary<Vector3Int, TileBase> tilesToPlace = new Dictionary<Vector3Int, TileBase>();
                    if (FarmlandBorderManager.Instance != null)
                    {
                        var combinedForQueue = new HashSet<Vector3Int>(queuePreviewPositions);
                        foreach (var key in executingTileGroups.Keys)
                            combinedForQueue.Add(key);
                        foreach (var pos in executingWaterPositions)
                            combinedForQueue.Add(pos);
                        
                        var previewTiles = FarmlandBorderManager.Instance.GetPreviewTiles(layerIndex, cellPos, combinedForQueue);
                        foreach (var kvp in previewTiles)
                        {
                            if (kvp.Value != null)
                                tilesToPlace[kvp.Key] = kvp.Value;
                        }
                    }
                    
                    // ğŸ”´ è¡¥ä¸004V3ï¼šb å±‚å¯¹ c å±‚åšå¢é‡è¿‡æ»¤ï¼ˆä¸æ˜¾ç¤ºä¸å®é™…è€•åœ°å®Œå…¨ç›¸åŒçš„ tileï¼‰
                    var tilemaps = FarmTileManager.Instance?.GetLayerTilemaps(layerIndex);
                    var actualCenterTilemap = tilemaps?.farmlandCenterTilemap;
                    var actualBorderTilemap = tilemaps?.farmlandBorderTilemap;
                    var borderManager = FarmlandBorderManager.Instance;
                    
                    var tilePositions = new List<Vector3Int>();
                    foreach (var kvp in tilesToPlace)
                    {
                        if (kvp.Value == null || queuePreviewTilemap == null) continue;
                        
                        // å¢é‡è¿‡æ»¤ï¼šå¯¹æ¯” c å±‚
                        TileBase actualTile;
                        if (kvp.Key == cellPos)
                            actualTile = actualCenterTilemap?.GetTile(kvp.Key);
                        else
                            actualTile = actualBorderTilemap?.GetTile(kvp.Key);
                        
                        if (kvp.Value == actualTile) continue;  // ä¸å®é™…è€•åœ°å®Œå…¨ç›¸åŒåˆ™è·³è¿‡
                        
                        // è¾¹ç•Œâ†’è¾¹ç•Œï¼šè®¡ç®—å¢é‡å·®é›†
                        TileBase tileToPlace = kvp.Value;
                        if (actualTile != null && borderManager != null 
                            && borderManager.IsBorderTile(actualTile) && borderManager.IsBorderTile(kvp.Value))
                        {
                            var actualDirs = borderManager.ParseDirections(actualTile);
                            var previewDirs = borderManager.ParseDirections(kvp.Value);
                            bool deltaU = previewDirs.hasU && !actualDirs.hasU;
                            bool deltaD = previewDirs.hasD && !actualDirs.hasD;
                            bool deltaL = previewDirs.hasL && !actualDirs.hasL;
                            bool deltaR = previewDirs.hasR && !actualDirs.hasR;
                            
                            if (!deltaU && !deltaD && !deltaL && !deltaR) continue;
                            
                            tileToPlace = borderManager.SelectBorderTile(deltaU, deltaD, deltaL, deltaR);
                            if (tileToPlace == null) continue;
                        }
                        
                        queuePreviewTilemap.SetTile(kvp.Key, tileToPlace);
                        queuePreviewTilemap.SetColor(kvp.Key, new Color(1f, 1f, 1f, queuePreviewAlpha));
                        tilePositions.Add(kvp.Key);
                    }
                    tillQueueTileGroups[cellPos] = tilePositions;
                }

                // ğŸ”´ V3 æ¨¡å—Kï¼šWater åˆ†æ”¯çš„ tile æ”¾ç½®ç§»åˆ°ä¸Šé¢çš„ if å—ä¸­å·²å¤„ç†
                if (tile != null && queuePreviewTilemap != null && type == FarmActionType.Water)
                {
                    queuePreviewTilemap.SetTile(cellPos, tile);
                    queuePreviewTilemap.SetColor(cellPos, new Color(1f, 1f, 1f, queuePreviewAlpha));
                }
            }

            queuePreviewPositions.Add(cellPos);
        }

        /// <summary>
        /// æ‰§è¡Œå®Œæˆæ—¶è°ƒç”¨ï¼šç§»é™¤æŒ‡å®šä½ç½®çš„é˜Ÿåˆ—é¢„è§ˆï¼ˆCP-H5ï¼‰
        /// </summary>
        public void RemoveQueuePreview(Vector3Int cellPos)
        {
            if (!queuePreviewPositions.Contains(cellPos)) return;

            // æ£€æŸ¥æ˜¯å¦æ˜¯ç§å­é˜Ÿåˆ—é¢„è§ˆ
            int seedIndex = activeSeedQueuePreviews.FindIndex(x => x.cellPos == cellPos);
            if (seedIndex >= 0)
            {
                var entry = activeSeedQueuePreviews[seedIndex];
                entry.renderer.enabled = false;
                seedQueuePool.Add(entry.renderer);  // å›æ”¶åˆ°å¯¹è±¡æ± 
                activeSeedQueuePreviews.RemoveAt(seedIndex);
            }
            // ğŸ”´ V3 æ¨¡å—Kï¼ˆCP-K2ï¼‰ï¼šè€•åœ°é˜Ÿåˆ—ä» tillQueueTileGroups è·å–å…³è”ä½ç½®åˆ—è¡¨
            else if (tillQueueTileGroups.TryGetValue(cellPos, out var tilePositions))
            {
                if (queuePreviewTilemap != null)
                {
                    foreach (var pos in tilePositions)
                    {
                        queuePreviewTilemap.SetTile(pos, null);
                    }
                }
                tillQueueTileGroups.Remove(cellPos);
            }
            else if (queuePreviewTilemap != null)
            {
                // æµ‡æ°´ç­‰ï¼šå•ç‚¹æ¸…é™¤
                queuePreviewTilemap.SetTile(cellPos, null);
            }

            queuePreviewPositions.Remove(cellPos);
        }

        /// <summary>
        /// æ¸…ç©ºæ‰€æœ‰é˜Ÿåˆ—é¢„è§ˆï¼ˆWASD ä¸­æ–­ / åˆ‡æ¢å·¥å…· / ESCï¼‰ï¼ˆCP-H5ï¼‰
        /// </summary>
        public void ClearAllQueuePreviews()
        {
            // ğŸ”´ è¡¥ä¸004 æ¨¡å—Eï¼ˆCP-E1/E2ï¼‰ï¼šæ¸…é™¤è€•åœ°é˜Ÿåˆ—çš„æ‰€æœ‰ tileï¼ˆä¸­å¿ƒå— + è¾¹ç•Œï¼‰ï¼Œè·³è¿‡æ‰§è¡Œé¢„è§ˆ
            if (queuePreviewTilemap != null)
            {
                foreach (var kvp in tillQueueTileGroups)
                {
                    if (executingTileGroups.ContainsKey(kvp.Key)) continue;  // CP-E3ï¼šè·³è¿‡æ‰§è¡Œé¢„è§ˆ
                    foreach (var pos in kvp.Value)
                        queuePreviewTilemap.SetTile(pos, null);
                }
                
                // æ¸…é™¤æµ‡æ°´ç­‰å•ç‚¹é˜Ÿåˆ—é¢„è§ˆï¼Œè·³è¿‡æ‰§è¡Œé¢„è§ˆ
                foreach (var pos in queuePreviewPositions)
                {
                    if (executingWaterPositions.Contains(pos)) continue;  // CP-E3ï¼šè·³è¿‡æ‰§è¡Œé¢„è§ˆ
                    if (tillQueueTileGroups.ContainsKey(pos)) continue;  // å·²åœ¨ä¸Šé¢å¤„ç†
                    queuePreviewTilemap.SetTile(pos, null);
                }
            }

            // å›æ”¶ç§å­é˜Ÿåˆ—é¢„è§ˆï¼ˆè·³è¿‡æ‰§è¡Œä¸­çš„ï¼‰
            for (int i = activeSeedQueuePreviews.Count - 1; i >= 0; i--)
            {
                var entry = activeSeedQueuePreviews[i];
                if (executingSeedPreviews.Exists(x => x.cellPos == entry.cellPos)) continue;
                entry.renderer.enabled = false;
                seedQueuePool.Add(entry.renderer);
                activeSeedQueuePreviews.RemoveAt(i);
            }
            activeSeedQueuePreviews.Clear();

            queuePreviewPositions.Clear();
            
            // ğŸ”´ V3 æ¨¡å—Kï¼ˆCP-K3ï¼‰ï¼šæ¸…ç©ºè€•åœ° tile ç»„è¿½è¸ªï¼ˆä¸æ¸… executing* æ•°æ®ï¼‰
            tillQueueTileGroups.Clear();
        }
        
        /// <summary>
        /// ğŸ”´ è¡¥ä¸004 æ¨¡å—Dï¼ˆCP-D1ï¼‰ï¼šå°†é˜Ÿåˆ—é¢„è§ˆæå‡ä¸ºæ‰§è¡Œé¢„è§ˆã€‚
        /// ProcessNextAction å‡ºé˜Ÿæ—¶è°ƒç”¨ã€‚tile ä¿ç•™åœ¨ queuePreviewTilemap ä¸Šï¼Œåªè½¬ç§»è¿½è¸ªæ•°æ®ã€‚
        /// </summary>
        public void PromoteToExecutingPreview(Vector3Int cellPos)
        {
            // è€•åœ°ï¼šä» tillQueueTileGroups è½¬ç§»åˆ° executingTileGroups
            if (tillQueueTileGroups.TryGetValue(cellPos, out var tilePositions))
            {
                executingTileGroups[cellPos] = tilePositions;
                tillQueueTileGroups.Remove(cellPos);
            }
            // æµ‡æ°´ï¼šä» queuePreviewPositions è½¬ç§»åˆ° executingWaterPositions
            else if (queuePreviewPositions.Contains(cellPos) && !activeSeedQueuePreviews.Exists(x => x.cellPos == cellPos))
            {
                executingWaterPositions.Add(cellPos);
            }
            // ç§å­ï¼šä» activeSeedQueuePreviews è½¬ç§»åˆ° executingSeedPreviews
            else
            {
                int idx = activeSeedQueuePreviews.FindIndex(x => x.cellPos == cellPos);
                if (idx >= 0)
                {
                    executingSeedPreviews.Add(activeSeedQueuePreviews[idx]);
                    activeSeedQueuePreviews.RemoveAt(idx);
                }
            }
            
            // ä»é˜Ÿåˆ—è¿½è¸ªä¸­ç§»é™¤ï¼ˆä½† tile ä¿ç•™åœ¨ tilemap ä¸Šï¼‰
            queuePreviewPositions.Remove(cellPos);
        }
        
        /// <summary>
        /// ğŸ”´ è¡¥ä¸004 æ¨¡å—Dï¼ˆCP-D2ï¼‰ï¼šæ¸…é™¤æ‰§è¡Œé¢„è§ˆã€‚
        /// åŠ¨ç”»å®Œæˆåè°ƒç”¨ï¼Œæ­¤æ—¶ tile å·²è½åœ°ï¼Œè§†è§‰æ— ç¼ã€‚
        /// </summary>
        public void RemoveExecutingPreview(Vector3Int cellPos)
                {
                    // è€•åœ°ï¼šæ¸…é™¤å…³è”çš„æ‰€æœ‰ tile
                    if (executingTileGroups.TryGetValue(cellPos, out var tilePositions))
                    {
                        if (queuePreviewTilemap != null)
                        {
                            foreach (var pos in tilePositions)
                            {
                                // ğŸ”´ è¡¥ä¸004V4ï¼ˆCP-V4-1/V4-2ï¼‰ï¼šæ£€æŸ¥ pos æ˜¯å¦è¢«å…¶ä»–é˜Ÿåˆ—é¢„è§ˆå ç”¨
                                bool isOccupiedByOtherQueue = false;
                                foreach (var kvp in tillQueueTileGroups)
                                {
                                    if (kvp.Value.Contains(pos))
                                    {
                                        isOccupiedByOtherQueue = true;
                                        break;
                                    }
                                }

                                if (!isOccupiedByOtherQueue)
                                {
                                    // ä¸è¢«å ç”¨ â†’ å®‰å…¨æ¸…ç©º
                                    queuePreviewTilemap.SetTile(pos, null);
                                }
                                // è¢«å ç”¨ â†’ ä¿ç•™é˜Ÿåˆ—é¢„è§ˆçš„ tileï¼ˆB å…¥é˜Ÿæ—¶å·²å†™å…¥ï¼Œæ— éœ€é‡æ–°å¡«å……ï¼‰
                            }
                        }
                        executingTileGroups.Remove(cellPos);
                        return;
                    }

                    // æµ‡æ°´ï¼šæ¸…é™¤å•ç‚¹
                    if (executingWaterPositions.Contains(cellPos))
                    {
                        queuePreviewTilemap?.SetTile(cellPos, null);
                        executingWaterPositions.Remove(cellPos);
                        return;
                    }

                    // ç§å­ï¼šå›æ”¶ SpriteRenderer
                    int idx = executingSeedPreviews.FindIndex(x => x.cellPos == cellPos);
                    if (idx >= 0)
                    {
                        var entry = executingSeedPreviews[idx];
                        entry.renderer.enabled = false;
                        seedQueuePool.Add(entry.renderer);
                        executingSeedPreviews.RemoveAt(idx);
                    }
                }


        
        /// <summary>
        /// æ›´æ–°å…‰æ ‡ä½ç½®å’Œé¢œè‰²
        /// </summary>
        private void UpdateCursor(int layerIndex, Vector3Int cellPos)
        {
            if (cursorRenderer == null) return;
            
            // è·å–æ ¼å­ä¸­å¿ƒä¸–ç•Œåæ ‡
            var tilemaps = FarmTileManager.Instance?.GetLayerTilemaps(layerIndex);
            Vector3 worldPos;
            
            if (tilemaps != null)
            {
                worldPos = tilemaps.GetCellCenterWorld(cellPos);
            }
            else
            {
                // å›é€€ï¼šä½¿ç”¨ PlacementGridCalculator
                worldPos = PlacementGridCalculator.GetCellCenter(new Vector3(cellPos.x, cellPos.y, 0));
            }
            
            cursorRenderer.transform.position = worldPos;
            
            // è®¾ç½®é¢œè‰²
            Color color;
            if (!isHoeMode && currentState == FarmPreviewState.Valid)
            {
                // æ°´å£¶æœ‰æ•ˆ = è“è‰²
                color = wateringColor;
            }
            else if (currentState == FarmPreviewState.Valid)
            {
                // é”„å¤´æœ‰æ•ˆ = ç»¿è‰²
                color = validColor;
            }
            else
            {
                // æ— æ•ˆ = çº¢è‰²
                color = invalidColor;
            }
            
            cursorRenderer.color = color;
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šæ›´æ–°ç§å­æ¨¡å¼çš„å…‰æ ‡
        /// </summary>
        private void UpdateCursorForSeed(Vector3 worldPos, bool isValid)
        {
            if (cursorRenderer == null) return;
            
            cursorRenderer.transform.position = worldPos;
            cursorRenderer.color = isValid ? seedValidColor : seedInvalidColor;
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šæ›´æ–° Sorting Layerï¼ˆè·Ÿéšç©å®¶æ¥¼å±‚ï¼‰
        /// </summary>
        private void UpdateSortingLayer(Transform playerTransform)
        {
            if (playerTransform == null) return;
            
            string playerSortingLayer = PlacementLayerDetector.GetPlayerSortingLayer(playerTransform);
            
            // åªåœ¨ Layer å˜åŒ–æ—¶æ›´æ–°
            if (playerSortingLayer != currentSortingLayer)
            {
                currentSortingLayer = playerSortingLayer;
                
                // æ›´æ–° GhostTilemap çš„ Sorting Layer
                if (ghostTilemapRenderer != null)
                {
                    ghostTilemapRenderer.sortingLayerName = currentSortingLayer;
                }
                
                // æ›´æ–° CursorRenderer çš„ Sorting Layer
                if (cursorRenderer != null)
                {
                    cursorRenderer.sortingLayerName = currentSortingLayer;
                }
                
                if (showDebugInfo)
                {
                    Debug.Log($"[FarmToolPreview] Sorting Layer æ›´æ–°ä¸º: {currentSortingLayer}");
                }
            }
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šè·å–ç©å®¶ä¸­å¿ƒä½ç½®
        /// </summary>
        private Vector2 GetPlayerCenter(Transform playerTransform)
        {
            if (playerTransform == null) return Vector2.zero;
            
            var collider = playerTransform.GetComponent<Collider2D>();
            return collider != null ? (Vector2)collider.bounds.center : (Vector2)playerTransform.position;
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šè·å–æ ¼å­ä¸­å¿ƒä¸–ç•Œåæ ‡
        /// </summary>
        private Vector3 GetCellCenterWorld(int layerIndex, Vector3Int cellPos)
        {
            var tilemaps = FarmTileManager.Instance?.GetLayerTilemaps(layerIndex);
            if (tilemaps != null)
            {
                return tilemaps.GetCellCenterWorld(cellPos);
            }
            
            // å›é€€ï¼šä½¿ç”¨ PlacementGridCalculator
            return PlacementGridCalculator.GetCellCenter(new Vector3(cellPos.x + 0.5f, cellPos.y + 0.5f, 0));
        }
        
        /// <summary>
        /// ğŸ”¥ æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦åœ¨ä½¿ç”¨è·ç¦»å†…
        /// </summary>
        private bool IsWithinReach(Transform playerTransform, Vector3 targetPos, float reach)
        {
            Vector2 playerCenter = GetPlayerCenter(playerTransform);
            float distance = Vector2.Distance(playerCenter, targetPos);
            return distance <= reach;
        }
        
        #endregion
    }
}
