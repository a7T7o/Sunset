# 农作物系统全面分析文档 V2

**创建日期**: 2026-02-11
**分析者**: Kiro（独立思考 + Gemini 设计协助综合）
**状态**: 待用户审核

---

## 一、核心设计决策

### 决策 1：种子袋 SO 设计 — 不需要单独的 SeedBagData

**结论：SeedData 本身就是种子袋，不需要新建 SO。**

**推理过程**：

1. 用户说"目前没有独立的种子，种子这个 SO 不会有数据"——这意味着游戏中不存在"散装种子"的概念，种子永远以袋子形式存在
2. 当前 `SeedData` 已经包含了种子的所有配置（生长天数、季节、收获作物 ID、生长阶段 Sprite 等）
3. 种子袋只是种子的"包装形态"，不是独立的物品类型

**如果新建 SeedBagData 会怎样**：
- 需要维护 SeedBagData → SeedData 的映射关系
- 打开种子袋后需要"转换"为 SeedData 物品
- 增加了一层不必要的间接性
- 违反了用户"SO 尽量精简"的原则

**最优方案**：在 `SeedData` 上新增种子袋相关字段：

```csharp
[Header("=== 种子袋配置 ===")]
[Tooltip("每袋种子数量")]
public int seedsPerBag = 5;

[Tooltip("未打开保质期（天）")]
public int shelfLifeClosed = 7;

[Tooltip("打开后保质期（天）")]
public int shelfLifeOpened = 2;

[Tooltip("已打开状态的图标")]
public Sprite iconOpened;
```

**运行时状态全部走 InventoryItem 动态属性**：
- `"bag_opened"` : bool — 是否已打开
- `"bag_remaining"` : int — 袋内剩余种子数
- `"shelf_expire_day"` : int — 过期的游戏总天数

**为什么这是最优解**：
- 零新增 SO 类型
- 利用已有的 `InventoryItem` 动态属性系统（已完善、已支持序列化）
- `CanStackWith()` 已经处理了"有动态属性的物品不能堆叠"——种子袋天然不可堆叠
- 存档自动支持，无需额外工作

---

### 决策 2：已打开/未打开样式 — 存同一个 SO

**结论：两个图标都存在 SeedData 中。**

- `icon`（继承自 ItemData）= 未打开的种子袋图标
- `iconOpened`（新增字段）= 已打开的种子袋图标

**运行时切换逻辑**：
- 背包 UI 渲染时，检查 `InventoryItem.GetPropertyBool("bag_opened")`
- 如果已打开，使用 `seedData.iconOpened`
- 如果未打开，使用 `seedData.icon`（默认）

**为什么不分两个 SO**：
- 打开/未打开是同一个物品的两种状态，不是两种物品
- 分两个 SO 会导致"打开"操作变成"删除旧物品 + 创建新物品"，增加复杂度
- 动态属性 + 双图标是最简洁的方案

---

### 决策 3：种子袋打开时机

**结论：右键在背包中打开 + 种植时自动打开。**

**两种触发方式**：

1. **背包右键打开**：玩家主动打开种子袋，查看/准备使用
   - 触发：背包界面右键点击未打开的种子袋
   - 效果：`bag_opened = true`，图标切换，保质期重算（取 Min）

2. **种植时自动打开**：如果种子袋还没打开，种植第一颗种子时自动打开
   - 触发：左键种植种子
   - 效果：消耗 1 个种子（`bag_remaining -= 1`），同时标记为已打开
   - 如果袋内种子用完（`bag_remaining <= 0`），整个物品消失

**保质期重算公式**（Gemini 方案，认同）：
```csharp
NewExpireDay = currentDay + Mathf.Min(remainingDays, shelfLifeOpened);
```
- 刚买的种子（剩 7 天），打开 → `Min(7, 2) = 2` 天后过期
- 放了很久的种子（剩 1 天），打开 → `Min(1, 2) = 1` 天后过期
- 永远不会出现"快过期了打开反而延寿"的漏洞

---

### 决策 4：收获交互设计 — 右键 + 导航集成

**结论：成熟作物右键收获，未成熟右键导航到附近。CropController 实现 IInteractable。**

**当前代码分析**：

`GameInputManager.HandleRightClickAutoNav()` 已有完整的交互链路：
1. 右键点击 → 检测 `IInteractable` → 导航到目标 → 到达后执行交互
2. `TryHarvestCropAtMouse()` 已存在但逻辑简陋（直接收获，无导航）

`PlayerAutoNavigator.FollowTarget()` 已支持：
- 导航到目标附近
- 到达后执行回调
- ClosestPoint 距离计算

**最优方案：CropController 实现 IInteractable**

```csharp
public class CropController : MonoBehaviour, IPersistentObject, IInteractable
{
    // IInteractable 实现
    public int InteractionPriority => 40; // 低于箱子(50)，高于普通物体(10)
    public float InteractionDistance => 1.2f; // 收获距离
    
    public bool CanInteract(InteractionContext context)
    {
        // 成熟或枯萎成熟 → 可收获
        // 未成熟 → 不可交互（右键只导航到附近）
        return IsMature() || IsWitheredMature();
    }
    
    public void OnInteract(InteractionContext context)
    {
        // 执行收获逻辑
        Harvest(context);
    }
    
    public string GetInteractionHint(InteractionContext context)
    {
        if (IsMature()) return "收获";
        if (IsWitheredMature()) return "收获（枯萎）";
        return ""; // 未成熟无提示
    }
}
```

**为什么选择 IInteractable 而不是 Tag**：

| 方案 | 优点 | 缺点 |
|------|------|------|
| IInteractable | 复用现有导航+交互链路、支持距离判断、支持优先级 | 需要 CropController 实现接口 |
| 新增 "Crop" Tag | 简单 | 需要在 GameInputManager 中新增 Tag 检测逻辑、无法复用交互链路 |
| 保持现有 TryHarvestCropAtMouse | 无需改动 | 无导航集成、无距离判断 |

**推荐 IInteractable**，理由：
1. `HandleRightClickAutoNav()` 已经有完整的 IInteractable 检测 → 导航 → 到达回调链路
2. 不需要新增任何 Tag
3. 不需要修改 GameInputManager 的核心逻辑
4. 距离判断、优先级排序全部复用现有机制

**右键交互完整流程**：

```
玩家右键点击作物位置
  ↓
HandleRightClickAutoNav() 检测到 CropController (IInteractable)
  ↓
检查 CanInteract()
  ├─ true（成熟/枯萎成熟）→ HandleInteractable() → 导航到附近 → 到达后 OnInteract() → 收获
  └─ false（未成熟）→ 不作为 IInteractable 处理 → 走普通导航逻辑 → 导航到作物附近
```

**关键细节**：未成熟作物的 `CanInteract()` 返回 false，但 CropController 的 GameObject 仍然存在于场景中。`HandleRightClickAutoNav()` 在 IInteractable 检测失败后，会走 Tag/Layer 检测或纯导航逻辑。所以未成熟时右键点击作物 = 导航到附近，这正是用户要求的行为。

**但有一个问题**：当前 `HandleRightClickAutoNav()` 通过 `ResourceNodeRegistry` 或 `Physics2D.OverlapPointAll` 检测 IInteractable。CropController 需要有 Collider 才能被检测到。

**解决方案**：CropController 的 GameObject 已有 SpriteRenderer，可以添加一个小的 BoxCollider2D (Trigger) 用于交互检测。或者，将 CropController 注册到 `ResourceNodeRegistry`（如果它实现了 IResourceNode）。

**我的建议**：给 CropController 添加 BoxCollider2D (Trigger)，这是最简单直接的方式。不需要实现 IResourceNode（那是给树木/石头等资源节点用的）。

---

### 决策 5：收获动画

**结论：暂时使用 collect 动画，不需要镰刀。**

- 收获时播放 collect 动画（已有）
- 收获动画由 `PlayerInteraction.RequestAction()` 触发
- 动画完成后执行实际的收获逻辑（物品掉落/添加到背包）

**在 OnInteract 中的实现思路**：
```csharp
public void OnInteract(InteractionContext context)
{
    // 1. 请求播放 collect 动画
    // 2. 动画完成回调中执行 Harvest()
    // 3. Harvest() 根据状态给予正常作物或枯萎作物
}
```

---

### 决策 6：枯萎系统设计

**结论：采用 Gemini 的"全阶段枯萎"方案，但简化实现。**

**Gemini 方案**：8 个场景表现（正常 4 + 枯萎 4）
**我的简化**：保持 4 个正常生长 Sprite + 1 个统一枯萎 Sprite

**理由**：
1. 用户原始需求是"7 个样式"，其中枯萎只有 1 个样式（不是 4 个）
2. 全阶段枯萎（4 个枯萎 Sprite）增加了美术工作量，但玩家感知差异不大
3. 枯萎后作物停止生长，视觉上只需要一个"枯萎"状态即可

**但保留扩展性**：SeedData 中使用数组而非单个 Sprite

```csharp
[Header("=== 枯萎样式 ===")]
[Tooltip("枯萎阶段Sprite（至少1个，可选多个对应不同生长阶段的枯萎样式）")]
public Sprite[] witheredStageSprites;
```

- 如果只配置 1 个 → 所有阶段枯萎都用这一个（当前需求）
- 如果配置 4 个 → 每个生长阶段有独立的枯萎样式（未来扩展）

**枯萎触发条件**（综合用户需求 + Gemini 方案）：

| 触发条件 | 影响范围 | 产出 |
|---------|---------|------|
| 成熟后 daysSinceMature >= 2 | 单株作物 | 枯萎作物（WitheredCropData） |
| 过季（OnSeasonChanged） | 当前楼层所有非全季节作物 | 未成熟枯萎无产出，成熟枯萎产出枯萎作物 |
| 连续未浇水 >= daysUntilWithered | 单株作物 | 未成熟枯萎无产出，成熟枯萎产出枯萎作物 |

**枯萎后的收获规则**（关键修正）：

| 枯萎时的阶段 | 收获操作 | 产出 |
|-------------|---------|------|
| 未成熟（Stage 0-2） | 锄头清除 | 无产出 |
| 成熟（Stage 3） | 右键收获（collect 动画） | WitheredCropData 物品 |

---

### 决策 7：CropData 继承重构

**结论：CropData 改为继承 FoodData。**

**当前**：`CropData : ItemData`
**目标**：`CropData : FoodData`

**理由**：用户明确说"收获的作物也是食物"。CropData 继承 FoodData 后自动获得 `energyRestore`、`healthRestore`、`buffType` 等字段。

**继承体系**：
```
ItemData
├── SeedData          (种子/种子袋)
├── FoodData          (食物基类)
│   ├── CropData      (正常作物，可食用)
│   └── WitheredCropData (枯萎作物，可食用，负面buff)
├── ToolData          (工具)
└── ...
```

**RottenFoodData 的处理**：
- 不需要单独的 `RottenFoodData` 类
- 直接用 `FoodData` 创建一个"腐烂的食物" SO 即可
- 配置负面 buff、可堆叠、无保质期

---

### 决策 8：保质期日结机制

**结论：InventoryService 订阅 OnDayChanged，遍历检查。**

**不新建 Service 的理由**：
- InventoryService 已经管理所有背包物品
- 保质期检查是背包物品的行为，归属 InventoryService 合理
- 每天检查一次，背包槽位有限（~48 个），性能无忧

**实现要点**：
```
OnDayChanged:
  遍历所有背包槽位:
    if item.HasProperty("shelf_expire_day"):
      if currentTotalDays >= item.GetPropertyInt("shelf_expire_day"):
        替换为"腐烂的食物"（ID: 5999）
```

---

## 二、SO 迭代方案

### SeedData 新增字段

```csharp
[Header("=== 种子袋配置 ===")]
[Tooltip("每袋种子数量")]
[Range(1, 20)]
public int seedsPerBag = 5;

[Tooltip("未打开保质期（天）")]
[Range(1, 28)]
public int shelfLifeClosed = 7;

[Tooltip("打开后保质期（天）")]
[Range(1, 14)]
public int shelfLifeOpened = 2;

[Tooltip("已打开状态的图标")]
public Sprite iconOpened;

[Header("=== 枯萎样式 ===")]
[Tooltip("枯萎阶段Sprite（至少1个）")]
public Sprite[] witheredStageSprites;
```

### CropData 重构

```csharp
// 改为继承 FoodData
public class CropData : FoodData
{
    [Header("=== 作物专属属性 ===")]
    public int seedID;
    public int harvestExp = 10;
    
    // 新增
    [Header("=== 枯萎作物关联 ===")]
    [Tooltip("对应的枯萎作物 ID（WitheredCropData）")]
    public int witheredCropID;
}
```

### WitheredCropData 新建

```csharp
[CreateAssetMenu(fileName = "WCrop_New", menuName = "Farm/Items/Withered Crop")]
public class WitheredCropData : FoodData
{
    [Header("=== 枯萎作物属性 ===")]
    [Tooltip("对应的正常作物 ID")]
    public int normalCropID;
    
    [Tooltip("对应的种子 ID")]
    public int seedID;
}
```

**ID 范围建议**：
- SeedData: 10XX（不变）
- CropData: 11XX（不变）
- WitheredCropData: 12XX（新增）
- 腐烂的食物: 5999（FoodData，单个 SO）

### CropInstanceData 新增字段

```csharp
/// <summary>
/// 成熟后经过的天数（用于过熟枯萎判断）
/// </summary>
public int daysSinceMature;
```

### CropSaveData 新增字段

```csharp
public int daysSinceMature;
```

---

## 三、CropController 重构方向

### 新增状态

```csharp
public enum CropState
{
    Growing,        // 生长中（Stage 0-2）
    Mature,         // 成熟（Stage 3，可收获）
    WitheredImmature, // 未成熟枯萎（缺水/过季，不可收获，锄头清除）
    WitheredMature    // 成熟枯萎（过熟/过季，可收获枯萎作物）
}
```

### IInteractable 实现

- `InteractionPriority = 40`
- `InteractionDistance = 1.2f`
- `CanInteract()` → 只有 Mature 和 WitheredMature 返回 true
- `OnInteract()` → 播放 collect 动画 → 收获

### OnDayChanged 逻辑扩展

```
if (state == Growing):
    检查浇水 → 生长或停滞
    检查缺水天数 → 可能变为 WitheredImmature
    检查是否达到成熟 → 转为 Mature
elif (state == Mature):
    if (!seedData.isReHarvestable):  // 可重复收获的不会过熟
        daysSinceMature++
        if daysSinceMature >= 2:
            state = WitheredMature
```

### 过季枯萎

```
OnSeasonChanged(newSeason):
    if (seedData.season != Season.AllSeason && seedData.season != newSeason):
        if (state == Mature):
            state = WitheredMature
        else:
            state = WitheredImmature
```

### 收获逻辑

```
Harvest(context):
    if (state == Mature):
        产出 CropData 物品
        数量 = Random(harvestAmountRange)
        品质 = 随机判定
        if (isReHarvestable): 重置到指定阶段
        else: 销毁
    elif (state == WitheredMature):
        产出 WitheredCropData 物品
        数量 = Random(harvestAmountRange)  // 与正常相同
        品质 = Normal（固定）
        销毁（枯萎作物不可重复收获）
```

---

## 四、收获交互完整流程

### 场景 A：成熟作物 + 玩家在附近

```
1. 玩家右键点击成熟作物
2. HandleRightClickAutoNav() 检测到 CropController (IInteractable)
3. CanInteract() = true（成熟）
4. HandleInteractable() 计算距离
5. 距离 <= InteractionDistance → 直接 OnInteract()
6. 播放 collect 动画
7. 动画完成 → Harvest() → 添加 CropData 到背包
8. 销毁作物 GameObject（或重置为可重复收获）
```

### 场景 B：成熟作物 + 玩家较远

```
1. 玩家右键点击成熟作物
2. HandleRightClickAutoNav() 检测到 CropController (IInteractable)
3. CanInteract() = true（成熟）
4. HandleInteractable() 计算距离
5. 距离 > InteractionDistance → FollowTarget() 导航
6. 到达后回调 → TryInteract() → OnInteract()
7. 播放 collect 动画
8. 动画完成 → Harvest() → 添加 CropData 到背包
```

### 场景 C：未成熟作物

```
1. 玩家右键点击未成熟作物
2. HandleRightClickAutoNav() 检测到 CropController (IInteractable)
3. CanInteract() = false（未成熟）
4. 不作为 IInteractable 处理
5. 走后续逻辑 → Physics2D.OverlapPointAll 或纯导航
6. 导航到作物附近（普通导航行为）
```

### 场景 D：枯萎成熟作物

```
1. 玩家右键点击枯萎成熟作物
2. HandleRightClickAutoNav() 检测到 CropController (IInteractable)
3. CanInteract() = true（枯萎成熟）
4. 同场景 A/B → OnInteract() → Harvest()
5. 产出 WitheredCropData 物品
```

### 场景 E：枯萎未成熟作物

```
1. 玩家右键点击 → 同场景 C（导航到附近）
2. 玩家左键使用锄头 → 清除枯萎作物（无产出）
3. 清除后耕地恢复为空耕地
```

---

## 五、与 Gemini 方案的对比

| 设计点 | Gemini 方案 | 我的方案 | 差异原因 |
|--------|-----------|---------|---------|
| 种子袋 SO | 未明确 | SeedData 本身就是种子袋 | 用户说"没有独立种子" |
| 枯萎 Sprite | 8 个（正常 4 + 枯萎 4） | 4+1（可扩展为 4+4） | 用户需求是 7 样式，简化美术工作量 |
| CropData 继承 | FoodData | FoodData | 一致 |
| BuffEntry 结构 | 独立结构体 | 沿用现有 FoodData 的 BuffType | 现有系统已够用，后续统一完善 |
| 保质期公式 | Min(当前剩余, 打开后最大) | 相同 | 认同 Gemini 方案 |
| 收获交互 | 未详细设计 | IInteractable + 导航集成 | 补全了 Gemini 未覆盖的部分 |
| RottenFoodData | 独立 SO 类 | 直接用 FoodData SO | 不需要独立类，一个 SO 实例即可 |

---

## 六、待用户确认的问题

### Q1：种子袋内种子数量的消耗方式

- 方案 A：每次种植消耗 1 个种子，`bag_remaining -= 1`，用完后物品消失
- 方案 B：每次种植消耗整个种子袋（一次性种植所有种子）

**我的推荐**：方案 A（逐个消耗），更符合游戏直觉

### Q2：未成熟枯萎作物的清除方式

- 方案 A：锄头清除（需要消耗锄头耐久）
- 方案 B：右键直接清除（无需工具）
- 方案 C：任意工具左键清除

**我的推荐**：方案 A（锄头清除），与农田系统一致

### Q3：CropController 的交互检测方式

- 方案 A：添加 BoxCollider2D (Trigger) 用于 Physics2D 检测
- 方案 B：注册到 ResourceNodeRegistry，通过 Sprite Bounds 检测

**我的推荐**：方案 A（BoxCollider2D Trigger），更简单直接

### Q4：腐烂食物的 ID

**建议 5999**（食品类 5XXX 范围末尾）

### Q5：WitheredCropData 的 ID 范围

**建议 12XX**（紧跟 CropData 的 11XX）

---

## 七、实施路线建议

### Phase 1：SO 层（低风险）
1. SeedData 新增种子袋配置 + 枯萎样式字段
2. CropData 改为继承 FoodData
3. 新建 WitheredCropData : FoodData
4. CropInstanceData 新增 daysSinceMature
5. 创建"腐烂的食物" FoodData SO（ID: 5999）

### Phase 2：CropController 重构（中风险）
1. 新增 CropState 枚举
2. 实现 IInteractable 接口
3. 添加 BoxCollider2D (Trigger)
4. 重构 OnDayChanged（加入过熟检查）
5. 重构 UpdateVisuals（支持枯萎样式）
6. 新增 Harvest 方法（区分正常/枯萎）
7. 订阅 SeasonManager.OnSeasonChanged（过季枯萎）
8. 更新 Save/Load（新增字段）

### Phase 3：种子袋保质期（中风险）
1. InventoryService 新增 OnDayChanged 保质期检查
2. 种植时消耗种子 + 自动打开种子袋
3. 背包右键打开种子袋
4. 过期替换为腐烂食物

### Phase 4：收获交互集成（低风险）
1. 移除旧的 TryHarvestCropAtMouse 逻辑
2. 通过 IInteractable 链路自动处理收获
3. collect 动画集成
4. 收获物品添加到背包

### Phase 5：集成测试
1. 种植 → 生长 → 成熟 → 收割完整流程
2. 成熟 → 过熟枯萎 → 枯萎收割流程
3. 过季枯萎流程
4. 种子袋保质期 → 过期 → 腐烂流程
5. 存档/读档兼容性
