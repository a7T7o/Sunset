# 农作物控制器设计与SO迭代 - 全面分析文档

**创建日期**: 2026-02-10
**分析范围**: 种子袋保质期系统、作物7样式生长系统、CropController重构、SO迭代方案

---

## 一、需求理解

### 1.1 用户核心需求

用户需要对农作物系统进行全面设计，包含两大模块：

**模块A：种子袋保质期系统**
- 所有种子用袋子装，袋子有"未打开"和"打开"两个状态
- 未打开保质期：默认7天
- 打开后保质期：默认2天
- 过期后变成"腐烂的食物"（独立物品，无保质期）
- 所有食物腐烂后都变成同一个"腐烂的食物"

**模块B：作物7样式生长系统**
- 4个生长阶段样式（种子→小苗→成长→成熟）
- 1个拔出来的作物样式（收割后获得的物品外观）
- 1个枯萎样式（成熟后超过2天未收割）
- 1个枯萎拔出来的作物样式
- 共7个样式
- 生长阶段间隔在Controller里控制
- SO只有两个：种子和作物
- 成熟后收割的作物获取由Controller处理

### 1.2 关键约束
- 种子袋是背包物品，需要考虑与背包系统的交互
- 作物样式切换学习TreeController的模式
- SO尽量精简，只有SeedData和CropData两个


---

## 二、现有代码分析

### 2.1 当前SO结构

| SO类 | 继承关系 | ID范围 | 用途 |
|------|---------|--------|------|
| `ItemData` | ScriptableObject | 0-9999 | 所有物品基类 |
| `SeedData` | ItemData | 10XX | 种子数据 |
| `CropData` | ItemData | 11XX | 作物数据 |
| `FoodData` | ItemData | 5XXX | 食物数据 |

### 2.2 SeedData 现有字段

```
基础（继承自ItemData）: itemID, itemName, icon, bagSprite, maxStackSize...
种植专属:
  - growthDays: int (生长所需天数)
  - season: Season (适合种植的季节)
  - harvestCropID: int (收获的作物ID)
  - harvestAmountRange: Vector2Int (收获数量范围)
  - isReHarvestable: bool (是否可重复收获)
  - reHarvestDays: int (重复收获间隔)
  - maxHarvestCount: int (最大收获次数)
  - growthStageSprites: Sprite[] (生长阶段图)
  - needsTrellis, needsWatering, plantingExp, harvestingExp
```

### 2.3 CropData 现有字段

```
基础（继承自ItemData）: itemID, itemName, icon...
作物专属:
  - seedID: int (对应种子ID)
  - harvestExp: int (收获经验)
  - canBeCrafted: bool
  - usedInRecipes: string
```

### 2.4 InventoryItem 动态属性系统

`InventoryItem` 已经支持动态属性（`Dictionary<string, string>`），可以存储：
- `SetProperty(key, value)` / `GetProperty(key)`
- `SetProperty(key, int)` / `GetPropertyInt(key)`
- `SetProperty(key, bool)` / `GetPropertyBool(key)`

**这是实现保质期系统的关键基础设施** — 不需要修改SO，可以在运行时通过动态属性记录保质期状态。

### 2.5 CropController 现有能力

- 自治模式：订阅 `TimeManager.OnDayChanged`，自己检查脚下土地
- 生长逻辑：基于 `grownDays` 线性分布到各阶段
- 枯萎逻辑：连续未浇水 `daysUntilWithered` 天后枯萎
- 视觉更新：`UpdateVisuals()` 根据阶段切换 Sprite
- 存档支持：实现 `IPersistentObject`

### 2.6 TreeController 的Sprite切换模式（参考）

TreeController 使用 `TreeSpriteConfig` + `StageSpriteData` 结构：
- 每个阶段有独立的 `StageSpriteData`
- 每个 `StageSpriteData` 包含：正常状态（季节Sprite集合）、枯萎状态、树桩状态
- 通过 `spriteConfig.GetStageData(stageIndex)` 获取当前阶段数据
- 通过 `normal.GetSprite(vegetationSeason)` 获取季节对应Sprite

---

## 三、方案分析

### 3.1 种子袋保质期方案

#### 方案A：修改SeedData SO（❌ 不推荐）

在 `SeedData` 中新增保质期字段：
```csharp
public int unopenedShelfLife = 7;  // 未打开保质期
public int openedShelfLife = 2;    // 打开后保质期
```

**问题**：
- 保质期是**运行时状态**，不是**静态定义**
- SO是共享的，所有同类种子共用一个SO
- "是否打开"、"剩余天数"是每个物品实例独有的

#### 方案B：利用InventoryItem动态属性（✅ 推荐）

利用现有的 `InventoryItem.SetProperty/GetProperty` 系统：

```csharp
// 种子袋状态属性
"seed_opened"     : bool  // 是否已打开
"seed_expire_day" : int   // 过期的游戏天数（绝对值）
"seed_created_day": int   // 创建时的游戏天数
```

**优势**：
- 不需要修改任何SO
- 每个物品实例独立追踪状态
- 利用现有基础设施，零新增依赖
- 存档自动支持（InventoryItem已有序列化）

**SeedData 只需新增静态配置**：
```csharp
[Header("=== 保质期配置 ===")]
public int unopenedShelfLife = 7;  // 未打开保质期（天）
public int openedShelfLife = 2;    // 打开后保质期（天）
```

**运行时流程**：
1. 获得种子时 → `SetProperty("seed_expire_day", currentDay + unopenedShelfLife)`
2. 打开种子袋时 → `SetProperty("seed_opened", true)` + 重算过期天数
3. 每天检查 → 当前天数 >= expire_day → 替换为"腐烂的食物"

#### 方案C：新建SeedBagData SO（❌ 过度设计）

创建独立的 `SeedBagData` SO 来表示种子袋。

**问题**：用户明确说"SO只有两个，就是种子和作物"，不应新增SO类型。


### 3.2 种子袋"打开"操作的触发时机

**关键问题**：什么时候算"打开"种子袋？

| 方案 | 触发时机 | 优缺点 |
|------|---------|--------|
| A | 种植时自动打开 | 简单直接，但种植=消耗，打开后立刻少一个 |
| B | 右键使用打开 | 需要额外交互步骤，但语义清晰 |
| C | 从堆叠中取出时打开 | 复杂，不直观 |

**推荐方案A**：种植时自动标记为"已打开"。

**理由**：
- 种子袋在背包中默认是"未打开"状态
- 玩家种植一颗种子时，消耗1个种子，剩余的种子自动变为"已打开"状态
- 这符合现实逻辑：打开袋子取出种子种下去，剩余的种子暴露在空气中
- 如果整袋种子一次性种完，就不存在"打开后保质期"的问题

**堆叠处理**：
- 未打开的种子袋可以堆叠（同类种子）
- 打开后的种子袋**不能与未打开的堆叠**（因为动态属性不同）
- `InventoryItem.CanStackWith()` 已经处理了这个逻辑（有动态属性的物品不能堆叠）

**⚠️ 重要发现**：当前 `CanStackWith()` 的逻辑是"有动态属性的物品不能堆叠"。这意味着：
- 一旦种子被标记为"已打开"，它就无法与其他种子堆叠
- 这可能导致背包空间浪费（每个打开的种子占一个槽位）
- **需要用户确认**：打开后的种子是否应该可以互相堆叠？

### 3.3 "腐烂的食物"物品设计

**需要新建一个独立的ItemData SO**：

```
ID: 待定（建议 5900 或 7900，取决于分类）
名称: 腐烂的食物
类型: 可以是 Food（5XXX）或 Special（7XXX）
特点: 无保质期、可丢弃、可能有少量售价
```

**所有食物腐烂后都变成这一个物品**，包括：
- 过期的种子袋 → 腐烂的食物
- 过期的食物（如果未来食物也有保质期）→ 腐烂的食物

**建议ID**: `5900_腐烂的食物`（归入食品类）

### 3.4 保质期检查机制

**谁来检查保质期？**

| 方案 | 实现方式 | 优缺点 |
|------|---------|--------|
| A | InventoryService 订阅 OnDayChanged | 集中管理，但增加 InventoryService 复杂度 |
| B | 新建 ShelfLifeService | 职责清晰，但新增一个服务 |
| C | InventoryItem 自检 | 不合适，数据类不应有行为 |

**推荐方案A**：在 `InventoryService` 中添加保质期检查逻辑。

**理由**：
- InventoryService 已经管理所有背包物品
- 每天检查一次，遍历所有槽位
- 发现过期物品 → 替换为"腐烂的食物"
- 不需要新增服务，保持架构简洁

---

## 四、作物7样式系统分析

### 4.1 样式清单

| 编号 | 样式名称 | 触发条件 | 说明 |
|------|---------|---------|------|
| 0 | 种子阶段 | 刚种下 | 种子刚入土的样子 |
| 1 | 小苗阶段 | 生长第一阶段 | 小苗冒出 |
| 2 | 成长阶段 | 生长第二阶段 | 植株长大 |
| 3 | 成熟阶段 | 生长完成 | 果实成熟，可收割 |
| 4 | 收获作物 | 收割时获得 | 拔出来的作物外观（背包图标/世界掉落物） |
| 5 | 枯萎阶段 | 成熟后2天未收割 | 植株枯萎 |
| 6 | 枯萎作物 | 收割枯萎作物 | 枯萎拔出来的作物外观 |

### 4.2 样式存储位置分析

**问题**：7个样式应该放在哪个SO里？

| 样式 | 归属 | 理由 |
|------|------|------|
| 0-3（生长阶段） | SeedData | 生长过程由种子决定 |
| 4（收获作物） | CropData | 收获物的外观由作物决定 |
| 5（枯萎阶段） | SeedData | 枯萎是生长过程的一部分 |
| 6（枯萎作物） | CropData | 枯萎收获物的外观由作物决定 |

**SeedData 需要新增**：
```csharp
[Header("=== 枯萎样式 ===")]
public Sprite witheredSprite;  // 枯萎阶段样式（样式5）
```

**CropData 需要新增**：
```csharp
[Header("=== 作物样式 ===")]
public Sprite harvestSprite;        // 收获作物样式（样式4）
public Sprite witheredHarvestSprite; // 枯萎收获作物样式（样式6）
```

**注意**：SeedData 现有的 `growthStageSprites` 数组已经存储了样式0-3（4个生长阶段），只需新增枯萎样式。

### 4.3 CropController 重构方向

**学习TreeController的模式**，但简化（作物不需要季节变化）：

```
当前CropController的Sprite切换：
  - growthStageSprites[currentStage] → 直接从SeedData数组取

需要改为：
  - 正常生长：growthStageSprites[currentStage]（样式0-3）
  - 成熟状态：growthStageSprites[最后一个]（样式3）
  - 枯萎状态：witheredSprite（样式5）
  - 收割时：根据是否枯萎，给予不同的作物物品
```

### 4.4 成熟后枯萎机制

**当前CropController的枯萎逻辑**：
- 基于"连续未浇水天数"（`daysWithoutWater >= daysUntilWithered`）

**用户新需求**：
- 成熟后超过2天未收割 → 枯萎

**需要新增**：
```csharp
[Header("成熟后枯萎")]
[Tooltip("成熟后多少天未收割会枯萎")]
[SerializeField] private int daysUntilOverripe = 2;

// CropInstanceData 新增
public int daysSinceMature;  // 成熟后经过的天数
```

**OnDayChanged 逻辑扩展**：
```
if (已成熟 && !已枯萎):
    daysSinceMature++
    if daysSinceMature >= daysUntilOverripe:
        设置枯萎
```

### 4.5 收割逻辑

**正常收割（成熟状态）**：
1. 播放收割动画
2. 获得 CropData 对应的作物物品（使用 `harvestSprite` 作为图标）
3. 数量由 `harvestAmountRange` 决定
4. 品质随机判定
5. 如果 `isReHarvestable`，重置到指定阶段继续生长
6. 如果不可重复收获，销毁作物GameObject

**枯萎收割**：
1. 播放收割动画
2. 获得枯萎作物物品（使用 `witheredHarvestSprite` 作为图标）
3. 数量固定为1（或减半）
4. 品质固定为 Normal
5. 销毁作物GameObject（枯萎作物不可重复收获）

**⚠️ 关键问题**：枯萎作物是独立的物品还是同一个CropData的不同状态？

| 方案 | 说明 | 优缺点 |
|------|------|--------|
| A | 同一个CropData，品质标记为"枯萎" | 简单，但品质系统被污染 |
| B | 独立的"枯萎作物"ItemData | 需要为每种作物创建枯萎版本SO |
| C | 同一个CropData，通过InventoryItem动态属性标记 | 灵活，不污染品质系统 |

**推荐方案C**：使用动态属性 `"is_withered": true` 标记枯萎状态。
- 枯萎作物的图标通过 `witheredHarvestSprite` 显示
- 售价降低（或为0）
- 不影响品质系统


---

## 五、SO迭代方案总结

### 5.1 SeedData 修改清单

```csharp
// === 新增字段 ===

[Header("=== 保质期配置 ===")]
[Tooltip("未打开保质期（天）")]
public int unopenedShelfLife = 7;

[Tooltip("打开后保质期（天）")]
public int openedShelfLife = 2;

[Header("=== 枯萎样式 ===")]
[Tooltip("枯萎阶段的Sprite（成熟后未收割枯萎）")]
public Sprite witheredStageSprite;

// === 现有字段保持不变 ===
// growthStageSprites[] 继续存储4个生长阶段样式
```

### 5.2 CropData 修改清单

```csharp
// === 新增字段 ===

[Header("=== 收获样式 ===")]
[Tooltip("正常收获的作物Sprite")]
public Sprite harvestSprite;

[Tooltip("枯萎收获的作物Sprite")]
public Sprite witheredHarvestSprite;

// === 现有字段保持不变 ===
```

### 5.3 新增SO：腐烂的食物

```
类型: ItemData（基类即可，不需要特殊子类）
ID: 5900
名称: 腐烂的食物
描述: 已经腐烂的食物，散发着难闻的气味
图标: [需要美术资源]
售价: 1（或0）
堆叠: 99
无保质期
```

### 5.4 InventoryItem 动态属性约定

| 属性Key | 类型 | 说明 | 适用物品 |
|---------|------|------|---------|
| `shelf_opened` | bool | 是否已打开 | SeedData |
| `shelf_expire_day` | int | 过期的游戏总天数 | SeedData, FoodData |
| `shelf_created_day` | int | 创建时的游戏总天数 | SeedData, FoodData |
| `is_withered_crop` | bool | 是否为枯萎收获物 | CropData |

### 5.5 CropInstanceData 修改清单

```csharp
// === 新增字段 ===

/// <summary>
/// 成熟后经过的天数（用于判断是否过熟枯萎）
/// </summary>
public int daysSinceMature;

/// <summary>
/// 是否因过熟而枯萎（区别于缺水枯萎）
/// </summary>
public bool isOverripe;
```

---

## 六、CropController 重构设计

### 6.1 状态机设计

```
CropState 枚举:
  - Growing     // 生长中（阶段0-2）
  - Mature      // 成熟（阶段3，可收割）
  - Overripe    // 过熟枯萎（成熟后2天未收割）
  - Withered    // 缺水枯萎（连续未浇水）
```

### 6.2 Sprite切换逻辑

```
GetCurrentSprite():
  if state == Overripe || state == Withered:
    return seedData.witheredStageSprite  // 枯萎样式
  else:
    return seedData.growthStageSprites[currentStage]  // 正常生长样式
```

### 6.3 收割逻辑

```
Harvest():
  if state == Mature:
    // 正常收割
    dropItem = CropData (harvestSprite)
    amount = Random(harvestAmountRange)
    quality = RandomQuality()
  elif state == Overripe:
    // 枯萎收割
    dropItem = CropData (witheredHarvestSprite, 标记 is_withered_crop=true)
    amount = 1
    quality = Normal
  
  if isReHarvestable && state == Mature:
    ResetForReHarvest()
  else:
    DestroyCrop()
```

### 6.4 每日更新逻辑

```
OnDayChanged():
  if state == Growing:
    检查浇水 → 生长或停滞
    检查缺水天数 → 可能枯萎
    检查是否达到成熟 → 转为 Mature
  elif state == Mature:
    daysSinceMature++
    if daysSinceMature >= daysUntilOverripe:
      state = Overripe
      UpdateVisuals()
```

---

## 七、与现有系统的交互分析

### 7.1 背包系统交互

| 操作 | 触发点 | 影响 |
|------|--------|------|
| 获得种子 | 商店购买/掉落拾取 | 设置 shelf_expire_day |
| 种植种子 | GameInputManager.TryPlantSeed | 消耗1个，剩余标记为opened |
| 每日检查 | InventoryService.OnDayChanged | 检查过期，替换为腐烂食物 |
| 收割作物 | CropController.Harvest | 添加CropData到背包 |

### 7.2 存档系统交互

| 数据 | 存储位置 | 说明 |
|------|---------|------|
| 种子保质期状态 | InventoryItem.properties | 随背包存档自动保存 |
| 作物生长状态 | CropController.Save() | 需要新增 daysSinceMature 字段 |
| 腐烂食物 | 普通ItemData | 无特殊存档需求 |

### 7.3 时间系统交互

| 事件 | 响应者 | 行为 |
|------|--------|------|
| OnDayChanged | CropController | 生长/枯萎检查 |
| OnDayChanged | InventoryService（新增） | 保质期检查 |

---

## 八、风险评估

| 风险 | 等级 | 说明 | 缓解措施 |
|------|------|------|---------|
| 堆叠问题 | 🟡 中 | 打开的种子无法堆叠，占用背包空间 | 需要用户确认是否接受 |
| 存档兼容 | 🟡 中 | CropInstanceData 新增字段，旧存档需要兼容 | 新字段默认值为0 |
| 性能 | 🟢 低 | 每日遍历背包检查保质期 | 背包槽位有限，性能无忧 |
| SO资产 | 🟢 低 | 需要为每种种子/作物配置新字段 | 编辑器工具批量处理 |

---

## 九、待用户确认的问题

### Q1：打开后的种子堆叠问题
当前 `InventoryItem.CanStackWith()` 逻辑：有动态属性的物品不能堆叠。
- 选项A：打开后的同类种子可以互相堆叠（需要修改堆叠逻辑）
- 选项B：打开后的种子不能堆叠，每个占一个槽位（当前默认行为）
- 选项C：打开种子袋时，整袋一起打开（所有种子共享同一个过期时间）

### Q2：枯萎作物的物品处理
- 选项A：枯萎作物是同一个CropData，通过动态属性标记（推荐）
- 选项B：枯萎作物是独立的ItemData SO
- 选项C：枯萎作物直接变成"腐烂的食物"

### Q3：腐烂食物的ID分配
- 选项A：5900（归入食品类 5XXX）
- 选项B：7900（归入特殊物品 7XXX）

### Q4：种子袋的视觉表现
- 种子袋在背包中是否需要显示"未打开/已打开"的不同图标？
- 是否需要显示剩余保质期天数？

### Q5：成熟后枯萎天数
- 用户说"超过2天"，确认：是成熟后第3天枯萎，还是成熟后经过2个完整天后枯萎？

---

## 十、推荐实施路线

### Phase 1：SO迭代（低风险）
1. SeedData 新增保质期配置 + 枯萎样式字段
2. CropData 新增收获样式 + 枯萎收获样式字段
3. CropInstanceData 新增 daysSinceMature + isOverripe
4. 创建"腐烂的食物" ItemData SO

### Phase 2：CropController 重构（中风险）
1. 新增 CropState 枚举
2. 重构 OnDayChanged 逻辑（加入过熟检查）
3. 重构 UpdateVisuals（支持枯萎样式）
4. 新增 Harvest 方法（区分正常/枯萎收割）
5. 更新存档 Save/Load（新增字段）

### Phase 3：保质期系统（中风险）
1. InventoryService 新增 CheckShelfLife 方法
2. 种植时标记种子为"已打开"
3. 过期检查 + 替换为腐烂食物
4. UI显示保质期状态（可选）

### Phase 4：集成测试
1. 种植→生长→成熟→收割 完整流程
2. 成熟→枯萎→枯萎收割 流程
3. 种子保质期→过期→腐烂 流程
4. 存档/读档兼容性测试
