# 农作物设计与完善 - 需求全面审视报告

**审视日期**: 2026-02-11
**审视者**: Kiro
**审视范围**: requirements.md + 现有代码架构

---

## 一、架构现状分析

### 1.1 现有代码架构

**ItemData 继承体系**：
```
ItemData (基类)
├── SeedData (种子)
├── CropData (作物) - 当前不继承 FoodData
├── FoodData (食物)
└── ToolData (工具)
```

**关键发现**：
- ✅ `InventoryItem` 已有完善的动态属性系统（`SetProperty/GetProperty`）
- ✅ `CropController` 已实现自治模式（订阅 TimeManager 事件）
- ✅ `CropInstanceData` 已有基础字段（currentStage, grownDays, daysWithoutWater, isWithered）
- ❌ **CropData 当前不继承 FoodData**，需要重构继承关系
- ❌ **没有 WitheredCropData**，需要新建
- ❌ **没有 RottenFoodData**，需要新建

### 1.2 存档系统现状

**持久化机制**：
- ✅ `IPersistentObject` 接口已完善
- ✅ `CropController` 已实现 `Save()/Load()`
- ✅ `WorldObjectSaveData` 支持 `genericData` 字段（JSON 序列化）
- ✅ `InventoryItem` 的动态属性可序列化（`PrepareForSerialization()`）

**结论**：存档系统已完善，可持久化要求可以满足。

---

## 二、需求文档深度审视

### 2.1 US-1：种子袋保质期系统

#### 2.1.1 核心需求分析

**AC-1.7：种子袋不可堆叠**
- ✅ 技术可行：`ItemData.stackable = false`
- ✅ 逻辑合理：每个种子袋保质期独立
- ⚠️ **潜在问题**：种子袋不可堆叠会导致背包空间压力巨大
  - 假设玩家有 10 种作物，每种 3 个种子袋 = 30 个背包槽位
  - 建议：考虑增加"种子箱"或"种子仓库"系统

**AC-1.8：一个种子袋内有一定数量的种子**
- ✅ 技术可行：`SeedData` 新增 `seedsPerBag` 字段
- ⚠️ **设计疑问**：
  - Q1：播种时消耗 1 个种子，种子袋内种子数量减少，还是直接消耗整个种子袋？
  - Q2：如果种子袋内种子数量可变，那么种子袋是否应该可堆叠（相同种子数量的可堆叠）？
  - **建议**：明确"种子袋"与"种子"的关系
    - 方案 A：种子袋是容器，内含 N 个种子，播种消耗 1 个种子，种子袋可重复使用
    - 方案 B：种子袋是一次性物品，播种时消耗整个种子袋（内含 N 个种子），一次性种植 N 株作物

**AC-1.9：保质期状态可持久化**
- ✅ 技术可行：利用 `InventoryItem.SetProperty("expiryDate", value)`
- ✅ 已有机制：`InventoryItem` 的动态属性会随存档保存
- ⚠️ **实现细节**：
  - 保质期存储格式：`totalDays`（游戏内总天数）
  - 打开状态存储：`SetProperty("isOpened", true)`
  - 过期检查时机：每天开始时（`TimeManager.OnDayChanged`）

#### 2.1.2 保质期检查逻辑

**问题**：谁负责检查保质期？
- 选项 A：`InventoryService` 每天遍历所有物品检查
- 选项 B：`SeedData` 自己检查（但 SO 不应该有运行时逻辑）
- 选项 C：新增 `ExpiryManager` 专门管理保质期

**建议**：选项 A + 优化
- `InventoryService` 订阅 `TimeManager.OnDayChanged`
- 只检查有 `expiryDate` 属性的物品（避免全遍历）
- 过期后调用 `ReplaceItem(oldItem, rottenFoodItem)`

#### 2.1.3 腐烂食物设计

**AC-1.5：腐烂的食物是独立物品（FoodData），可堆叠**
- ✅ 技术可行：新建 `RottenFoodData : FoodData`
- ✅ 逻辑合理：所有过期食物都变成同一个物品
- ⚠️ **设计疑问**：
  - Q3：腐烂食物的 ID 是多少？（建议：5999，食物 ID 范围末尾）
  - Q4：腐烂食物的图标是什么？（建议：统一的"腐烂堆"图标）
  - Q5：腐烂食物的售价是多少？（建议：1 金币，象征性价格）

---

### 2.2 US-2：作物 7 样式生长系统

#### 2.2.1 样式配置分析

**当前 SeedData 配置**：
```csharp
public Sprite[] growthStageSprites; // 4 个生长阶段
```

**需求要求**：
- 4 个生长阶段（种子→小苗→成长→成熟）
- 1 个收获样式（拔出来的作物外观）
- 1 个枯萎样式（成熟后过期）
- 1 个枯萎收获样式（枯萎作物拔出来的外观）

**问题**：
- ❌ **收获样式不应该在 SeedData 中**，应该在 CropData 中（`CropData.icon`）
- ❌ **枯萎样式不应该在 SeedData 中**，应该在 WitheredCropData 中
- ✅ **生长阶段样式在 SeedData 中是合理的**

**建议的样式配置**：
```csharp
// SeedData.cs
public Sprite[] growthStageSprites; // 4 个：种子→小苗→成长→成熟

// CropData.cs (继承 FoodData)
public Sprite icon; // 收获样式（继承自 ItemData）

// WitheredCropData.cs (继承 FoodData)
public Sprite icon; // 枯萎收获样式（继承自 ItemData）
```

**枯萎样式的显示**：
- 当前 `CropController` 使用颜色变化表示枯萎（`WitheredColor`）
- 需求要求独立的枯萎 Sprite
- **建议**：
  - 方案 A：`SeedData` 新增 `witheredSprite` 字段，`CropController` 枯萎时切换 Sprite
  - 方案 B：`CropController` 枯萎时切换到 `WitheredCropData`，使用其 `icon`（但这样会失去生长阶段信息）
  - **推荐方案 A**：保持 `CropController` 的简洁性

#### 2.2.2 枯萎作物独立 SO

**AC-2.6：枯萎作物是独立的 SO（WitheredCropData）**
- ✅ 技术可行：新建 `WitheredCropData : FoodData`
- ✅ 逻辑合理：枯萎作物与正常作物是不同物品
- ⚠️ **设计疑问**：
  - Q6：WitheredCropData 的 ID 范围是多少？（建议：1200-1299）
  - Q7：每种作物都需要对应的 WitheredCropData 吗？（建议：是的）
  - Q8：WitheredCropData 的售价是正常作物的多少？（建议：10%-20%）

**AC-2.7：CropController 需要索引两种 SO**
- ⚠️ **架构问题**：`CropController` 当前只引用 `SeedData`
- **建议的重构**：
  ```csharp
  // CropController.cs
  private SeedData seedData;           // 种子数据（生长配置）
  private CropData normalCropData;     // 正常作物数据（收获时用）
  private WitheredCropData witheredCropData; // 枯萎作物数据（枯萎收获时用）
  ```
- **问题**：如何获取 `normalCropData` 和 `witheredCropData`？
  - 方案 A：`SeedData` 新增 `harvestCropData` 和 `witheredCropData` 引用
  - 方案 B：通过 `ItemDatabase` 查询（`seedData.harvestCropID` → `CropData`）
  - **推荐方案 B**：避免 SO 之间的循环引用

---

### 2.3 US-3：作物生长控制与枯萎机制

#### 2.3.1 成熟后枯萎计时

**AC-3.4：成熟后枯萎计时精确定义**
- ✅ 逻辑清晰：daysSinceMature 累计逻辑
- ⚠️ **实现细节**：
  - `CropInstanceData` 需要新增 `daysSinceMature` 字段
  - `CropController.OnDayChanged()` 需要新增逻辑：
    ```csharp
    if (IsMature())
    {
        instanceData.daysSinceMature++;
        if (instanceData.daysSinceMature >= 2)
        {
            SetWithered();
        }
    }
    ```
- ⚠️ **边界情况**：
  - Q9：可重复收获的作物（如草莓）成熟后是否也会枯萎？
  - **当前需求**：E-4 说"可重复收获的作物成熟后不会枯萎"
  - **建议**：`SeedData` 新增 `canOverripe` 字段，控制是否会过熟枯萎

#### 2.3.2 过季枯萎

**AC-3.5：过季枯萎**
- ✅ 逻辑合理：增加游戏策略性
- ⚠️ **实现细节**：
  - `CropController` 需要订阅 `SeasonManager.OnSeasonChanged`
  - 季节切换时，所有作物调用 `SetWithered()`
- ⚠️ **边界情况**：
  - Q10：全季节作物（`Season.AllSeason`）是否也会过季枯萎？
  - **建议**：全季节作物不受季节影响，不会过季枯萎

#### 2.3.3 可持久化要求

**AC-3.6：枯萎状态可持久化**
- ✅ 已实现：`CropInstanceData.isWithered` 已在 `CropSaveData` 中
- ✅ 已实现：`CropController.Save()/Load()` 已处理
- ⚠️ **新增字段**：
  - `daysSinceMature` 需要加入 `CropSaveData`
  - `currentSeason` 需要加入 `CropSaveData`（用于检测过季）

---

### 2.4 US-4：成熟收割系统

#### 2.4.1 作物可食用

**AC-4.5：收获的作物是食物**
- ❌ **当前架构不支持**：`CropData` 不继承 `FoodData`
- ✅ **重构方案**：
  ```csharp
  // 修改继承关系
  public class CropData : FoodData
  {
      // 保留原有字段
      public int seedID;
      public int harvestExp;
      // ...
  }
  ```
- ⚠️ **影响评估**：
  - 需要修改所有现有的 `CropData` SO（添加 `energyRestore`, `healthRestore` 等字段）
  - 需要修改 `CropController` 的收割逻辑（返回 `FoodData` 而非 `CropData`）

#### 2.4.2 腐烂食物特性

**AC-4.6：腐烂的食物也是食物**
- ✅ 技术可行：`RottenFoodData : FoodData`
- ✅ 逻辑合理：可堆叠、可作为配方材料、可食用
- ⚠️ **设计细节**：
  - `energyRestore = -10`（负面效果）
  - `healthRestore = -5`（负面效果）
  - `buffType = BuffType.Poisoned`（中毒 buff）
  - `buffDuration = 60f`（持续 60 秒）

---

## 三、设计约束审视

### 3.1 C-1：SO 精简原则

**约束内容**：
- 有三个 SO 类型：SeedData、CropData、WitheredCropData
- 种子袋不可堆叠（stackable = false）

**审视结果**：
- ✅ 三个 SO 类型是合理的
- ⚠️ **遗漏**：还需要 `RottenFoodData`（腐烂食物）
- **建议**：更新为"四个 SO 类型"

### 3.2 C-2：架构一致性

**约束内容**：
- 作物 Sprite 切换参考 TreeController 模式
- CropController 保持自治模式
- 所有运行时状态必须可持久化

**审视结果**：
- ✅ `CropController` 已是自治模式（订阅 TimeManager 事件）
- ✅ 持久化机制已完善
- ⚠️ **TreeController 模式**：
  - `TreeController` 使用 `TreeSpriteData` 配置 Sprite
  - `CropController` 使用 `SeedData.growthStageSprites` 数组
  - **差异**：TreeController 有更复杂的 Sprite 配置（不同季节、不同阶段）
  - **建议**：保持当前简单的数组模式，不需要完全模仿 TreeController

### 3.3 C-4：食物系统一致性

**约束内容**：
- 作物（CropData）继承自 FoodData
- 枯萎作物（WitheredCropData）继承自 FoodData
- 腐烂食物（RottenFoodData）继承自 FoodData

**审视结果**：
- ❌ **当前不满足**：`CropData` 不继承 `FoodData`
- ✅ **重构可行**：修改继承关系即可
- ⚠️ **影响评估**：
  - 需要修改所有现有的 `CropData` SO
  - 需要修改所有引用 `CropData` 的代码（检查是否依赖特定字段）

---

## 四、边界情况审视

### 4.1 E-1：种子堆叠

**边界情况**：种子袋不可堆叠，每个种子袋独立

**审视结果**：
- ✅ 逻辑合理
- ⚠️ **用户体验问题**：
  - 背包空间压力巨大
  - 建议：增加"种子箱"或"种子仓库"系统
  - 或者：增加背包容量（从 36 增加到 48 或更多）

### 4.2 E-2：存档兼容

**边界情况**：旧存档兼容性

**审视结果**：
- ✅ `CropInstanceData` 新增字段使用默认值（0/false）
- ✅ `InventoryItem` 动态属性不影响旧存档
- ⚠️ **潜在问题**：
  - 旧存档中的 `CropData` 不是 `FoodData`，加载后可能缺少食物属性
  - **建议**：在 `CropData` 中为食物属性设置合理默认值

### 4.3 E-3：季节影响

**边界情况**：过季全部枯萎

**审视结果**：
- ✅ 逻辑合理
- ⚠️ **实现细节**：
  - 需要订阅 `SeasonManager.OnSeasonChanged`
  - 需要检查 `SeedData.season` 是否匹配当前季节
  - 全季节作物（`Season.AllSeason`）不受影响

### 4.4 E-4：可重复收获作物

**边界情况**：可重复收获的作物成熟后不会枯萎

**审视结果**：
- ✅ 逻辑合理
- ⚠️ **实现细节**：
  - 需要在 `CropController.OnDayChanged()` 中检查 `seedData.isReHarvestable`
  - 如果是可重复收获，跳过 `daysSinceMature` 累计逻辑
- ⚠️ **边界情况**：
  - 可重复收获的作物在季节切换时仍然会枯萎（E-3）
  - 这是合理的，避免跨季种植

### 4.5 E-5：腐烂食物

**边界情况**：腐烂食物的特性

**审视结果**：
- ✅ 可堆叠、可作为配方材料、可食用
- ⚠️ **设计细节**：
  - `stackable = true`
  - `maxStackSize = 99`（建议）
  - `sellPrice = 1`（象征性价格）
  - `energyRestore = -10`（负面效果）
  - `buffType = BuffType.Poisoned`（中毒 buff）

### 4.6 E-6：枯萎作物收割

**边界情况**：枯萎作物可以收割

**审视结果**：
- ✅ 逻辑合理
- ⚠️ **实现细节**：
  - `CropController` 收割时检查 `instanceData.isWithered`
  - 如果枯萎，返回 `WitheredCropData` 而非 `CropData`
  - 收割数量与正常收割相同（`seedData.harvestAmountRange`）

---

## 五、关键问题汇总

### 5.1 必须明确的问题

| # | 问题 | 影响 | 建议 |
|---|------|------|------|
| Q1 | 种子袋与种子的关系？ | 核心玩法 | 明确是容器还是一次性物品 |
| Q2 | 种子袋内种子数量可变吗？ | 堆叠逻辑 | 建议固定数量，简化逻辑 |
| Q3 | 腐烂食物的 ID 是多少？ | 数据配置 | 建议 5999 |
| Q6 | WitheredCropData 的 ID 范围？ | 数据配置 | 建议 1200-1299 |
| Q9 | 可重复收获作物是否会过熟枯萎？ | 游戏平衡 | 建议不会（已在 E-4 中明确） |
| Q10 | 全季节作物是否会过季枯萎？ | 游戏平衡 | 建议不会 |

### 5.2 架构重构清单

| # | 重构项 | 优先级 | 工作量 |
|---|--------|--------|--------|
| R1 | `CropData` 继承 `FoodData` | P0 | 中 |
| R2 | 新建 `WitheredCropData : FoodData` | P0 | 低 |
| R3 | 新建 `RottenFoodData : FoodData` | P0 | 低 |
| R4 | `SeedData` 新增字段（seedsPerBag, witheredSprite, canOverripe） | P0 | 低 |
| R5 | `CropInstanceData` 新增字段（daysSinceMature, currentSeason） | P0 | 低 |
| R6 | `CropController` 新增枯萎逻辑 | P0 | 中 |
| R7 | `CropController` 订阅 `SeasonManager.OnSeasonChanged` | P0 | 低 |
| R8 | `InventoryService` 新增保质期检查逻辑 | P0 | 中 |
| R9 | `CropController` 收割逻辑重构（支持 WitheredCropData） | P0 | 中 |

### 5.3 数据配置清单

| # | 配置项 | 数量 | 工作量 |
|---|--------|------|--------|
| D1 | 修改所有 `CropData` SO（添加食物属性） | ~10 个 | 中 |
| D2 | 创建所有 `WitheredCropData` SO | ~10 个 | 中 |
| D3 | 创建 `RottenFoodData` SO | 1 个 | 低 |
| D4 | 修改所有 `SeedData` SO（添加新字段） | ~10 个 | 低 |

---

## 六、优化建议

### 6.1 用户体验优化

1. **种子箱系统**：
   - 新增"种子箱"物品，可存储多个种子袋
   - 种子箱可放置在农场，类似箱子系统
   - 减轻背包压力

2. **保质期提示**：
   - 物品槽 UI 显示保质期倒计时
   - 即将过期的物品高亮显示（黄色边框）
   - 已过期的物品显示"腐烂"标记

3. **枯萎预警**：
   - 作物即将枯萎时（daysSinceMature = 1）显示警告图标
   - 玩家可以提前收割，避免损失

### 6.2 性能优化

1. **保质期检查优化**：
   - 不要每天遍历所有物品
   - 维护一个"有保质期物品"列表
   - 只检查列表中的物品

2. **作物枯萎检查优化**：
   - 不要每天遍历所有作物
   - `CropController` 自治模式已经很高效
   - 无需额外优化

### 6.3 代码质量优化

1. **枚举定义**：
   - 新增 `CropState` 枚举：`Growing`, `Mature`, `Overripe`, `Withered`
   - 替代多个 bool 标志（`isMature`, `isWithered`）

2. **事件系统**：
   - 新增 `OnCropWithered` 事件（用于成就系统、统计系统）
   - 新增 `OnCropHarvested` 事件

3. **单元测试**：
   - 为保质期逻辑编写单元测试
   - 为枯萎逻辑编写单元测试
   - 为过季枯萎逻辑编写单元测试

---

## 七、风险评估

### 7.1 高风险项

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| `CropData` 继承重构导致现有代码崩溃 | 高 | 中 | 全面测试，逐步迁移 |
| 保质期检查性能问题 | 中 | 低 | 优化检查逻辑，只检查有保质期的物品 |
| 存档兼容性问题 | 高 | 低 | 为新字段设置合理默认值 |

### 7.2 中风险项

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|---------|
| 种子袋不可堆叠导致背包空间不足 | 中 | 高 | 增加背包容量或种子箱系统 |
| 过季枯萎导致玩家体验不佳 | 中 | 中 | 提供预警提示，增加全季节作物 |
| WitheredCropData 配置工作量大 | 低 | 高 | 使用编辑器工具批量生成 |

---

## 八、总结与建议

### 8.1 需求文档质量评估

| 维度 | 评分 | 说明 |
|------|------|------|
| 完整性 | 8/10 | 核心需求清晰，但缺少部分细节（种子袋与种子的关系） |
| 一致性 | 9/10 | 需求之间逻辑一致，无明显矛盾 |
| 可实现性 | 9/10 | 技术上完全可行，现有架构支持良好 |
| 可测试性 | 8/10 | 大部分需求可测试，但缺少性能指标 |

### 8.2 核心建议

1. **立即明确**：
   - 种子袋与种子的关系（容器 vs 一次性物品）
   - 腐烂食物和枯萎作物的 ID 范围

2. **优先重构**：
   - `CropData` 继承 `FoodData`（影响最大）
   - 新建 `WitheredCropData` 和 `RottenFoodData`

3. **分阶段实施**：
   - Phase 1：SO 重构 + 基础字段新增
   - Phase 2：保质期系统实现
   - Phase 3：枯萎机制实现
   - Phase 4：过季枯萎实现

4. **用户体验优先**：
   - 增加种子箱系统（缓解背包压力）
   - 增加保质期和枯萎预警（提升用户体验）

### 8.3 下一步行动

1. **用户确认**：
   - 确认 Q1-Q10 的问题
   - 确认架构重构方案
   - 确认数据配置方案

2. **进入设计阶段**：
   - 创建 `design.md`
   - 详细设计 SO 结构
   - 详细设计 CropController 重构方案
   - 详细设计保质期检查逻辑

3. **创建任务列表**：
   - 创建 `tasks.md`
   - 分解为可执行的小任务
   - 估算工作量和优先级

---

**审视完成日期**: 2026-02-11
**审视者签名**: Kiro
