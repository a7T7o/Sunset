# 10.0.2 迭代需求 001 — CropStageConfig 深度学习树木模式 + 收获改用 DropTable

## 一、需求来源

用户在验收 10.0.2 后提出的进一步优化需求，核心诉求：
1. CropStageConfig 应该更深度地学习 TreeController 的 StageConfig 模式
2. 农作物固定 4 个阶段（种子→幼苗→生长→成熟），每个阶段有独立的生长天数
3. 不需要血量（农作物只用 Collect 动作拔起来，不像树木需要砍伐）
4. 收获产出改用 DropTable（与树木掉落系统统一），只有成熟时才可收获
5. 收获动画只用 Collect（拔起来）

## 二、现状分析

### 2.1 当前 CropStageConfig（10.0.2 已完成）

```csharp
public struct CropStageConfig
{
    public Sprite normalSprite;
    public Sprite witheredSprite;
}
```

只有 Sprite 配置，没有生长天数。阶段数量由数组长度决定（不固定）。

### 2.2 树木 StageConfig（参考对象）

```csharp
public class StageConfig
{
    public int daysToNextStage;     // 每阶段独立天数
    public int health;              // 血量
    public bool hasStump;           // 树桩
    public int stumpHealth;         // 树桩血量
    public bool enableCollider;     // 碰撞
    public bool enableOcclusion;    // 遮挡
    public DropTable dropTable;     // 掉落表
    public DropTable stumpDropTable; // 树桩掉落表
    public ToolType acceptedToolType; // 工具类型
    public float verticalMargin;    // 成长边距
    public float horizontalMargin;  // 成长边距
}
```

树木有 6 个固定阶段（STAGE_COUNT = 6），每阶段有独立的 daysToNextStage。

### 2.3 当前 CropController 的生长天数计算

当前使用 SeedData.growthDays（总天数）均匀分配到各阶段：
```csharp
float daysPerStage = (float)growthDays / (totalStages - 1);
```

这意味着所有阶段的生长时间相同，不够灵活。

### 2.4 当前收获机制

- 通过 IInteractable 接口的 Collect 交互
- 成熟时：通过 seedData.harvestCropID 获取 CropData，直接 AddItem 到背包
- 枯萎成熟时：通过 CropData.witheredCropID 获取枯萎作物
- 背包满时：调用 DropItemToWorld 掉落到地面
- 没有使用 DropTable，而是硬编码的 itemID + amount 逻辑

### 2.5 树木的掉落机制

- StageConfig 中配置 DropTable SO 引用
- 砍倒时调用 SpawnDrops()，从 DropTable.GenerateDrops() 获取掉落列表
- 通过 WorldSpawnService.SpawnMultiple() 生成掉落物
- DropTable 支持：多物品、概率、数量范围、品质、散布半径

## 三、差异对比与适配方案

| 维度 | 树木 StageConfig | 当前 CropStageConfig | 适配方案 |
|------|-----------------|---------------------|---------|
| 阶段数量 | 固定 6 阶段 | 数组长度不固定 | 固定 4 阶段（STAGE_COUNT = 4） |
| 生长天数 | 每阶段独立 daysToNextStage | 总天数均分 | 每阶段独立 daysToNextStage |
| 血量 | 有（砍伐用） | 无 | 不需要（Collect 拔起来） |
| 树桩 | 有 | 无 | 不需要 |
| 碰撞/遮挡 | 有 | 无 | 不需要（作物不阻挡） |
| 掉落表 | DropTable SO | 无（硬编码 itemID） | 新增 DropTable 字段 |
| 工具类型 | 各阶段不同 | 无 | 不需要（统一 Collect） |
| Sprite | TreeSpriteConfig（季节变化） | normalSprite + witheredSprite | 保留当前设计 |
| 成长边距 | 有（空间检测） | 无 | 不需要（作物在农田格子里） |

### 3.1 CropStageConfig 需要新增的字段

```
daysToNextStage  — 该阶段到下一阶段需要的天数（最后阶段设为 0）
```

### 3.2 CropController 需要新增的字段

```
dropTable        — 成熟时的掉落表（DropTable SO 引用）
```

### 3.3 不需要的字段（与树木的差异）

- health / stumpHealth — 农作物不需要血量
- hasStump — 农作物没有树桩
- enableCollider / enableOcclusion — 农作物不阻挡
- acceptedToolType — 统一 Collect
- verticalMargin / horizontalMargin — 农作物在格子里不需要空间检测

## 四、4 阶段设计

| 阶段 | 名称 | 说明 | daysToNextStage 示例 |
|------|------|------|---------------------|
| 0 | 种子 | 刚种下，地面有小点 | 1 |
| 1 | 幼苗 | 冒出小芽 | 2 |
| 2 | 生长 | 植株长大 | 2 |
| 3 | 成熟 | 可收获状态 | 0（不再生长） |

常量定义：
```
CROP_STAGE_COUNT = 4
CROP_STAGE_SEED = 0
CROP_STAGE_SPROUT = 1
CROP_STAGE_GROWING = 2
CROP_STAGE_MATURE = 3
```

## 五、收获机制改造

### 5.1 当前流程（需要改造）
1. 玩家 Collect 交互 → CropController.OnInteract()
2. 检查 state == Mature → HarvestMature()
3. 通过 seedData.harvestCropID 获取物品 ID
4. inventory.AddItem(cropID, quality, amount)
5. 背包满 → DropItemToWorld()

### 5.2 改造后流程（学习树木）
1. 玩家 Collect 交互 → CropController.OnInteract()
2. 检查 state == Mature → HarvestMature()
3. 从 CropController 的 dropTable 字段获取 DropTable SO
4. dropTable.GenerateDrops() 生成掉落列表
5. WorldSpawnService.SpawnMultiple() 掉落到地面
6. 销毁作物（或重复收获重置）

### 5.3 关键变化
- 收获产出从"直接加背包"改为"掉落到地面"（与树木一致）
- 产出配置从 SeedData 的 harvestCropID + harvestAmountRange 改为 DropTable SO
- 品质由 DropTable 的 DropConfig.quality 控制，不再由 DetermineHarvestQuality() 随机
- 枯萎收获同理，可以配置单独的枯萎 DropTable 或不配置（枯萎直接清除）

## 六、对现有代码的影响评估

### 6.1 需要修改的文件
| 文件 | 改动 |
|------|------|
| CropStageConfig.cs | 新增 daysToNextStage 字段 |
| CropController.cs | 固定 4 阶段常量、新增 dropTable 字段、重写生长天数计算、重写收获逻辑 |
| SeedData.cs | 可能移除 harvestCropID / harvestAmountRange（由 DropTable 替代） |
| CropManager.cs | TryHarvest 适配新收获逻辑 |
| CropSystemTests.cs | 适配新的阶段计算和收获逻辑 |

### 6.2 存档兼容性
- CropSaveData 存的是 currentStage + grownDays，不存 DropTable 引用
- 阶段数从动态改为固定 4，旧存档的 currentStage 值（0-3）仍然有效
- 生长天数计算方式改变，但 grownDays 仍然有效（只是阶段判定逻辑变了）
- 需要注意：如果旧存档的 stages 数组不是 4 个元素，需要兼容处理

### 6.3 SeedData 字段处理
- harvestCropID：可能保留用于其他用途（如 UI 显示），或移除
- harvestAmountRange：由 DropTable 替代，可移除
- growthDays：由 CropStageConfig.daysToNextStage 替代，可移除
- isReHarvestable / reHarvestDays / maxHarvestCount：保留（重复收获逻辑不变）

## 七、Collect 动画现状

当前 CropController 实现了 IInteractable 接口：
- CanInteract：state == Mature || state == WitheredMature
- OnInteract：调用 Harvest()
- GetInteractionHint：返回"收获"/"收获（枯萎）"

交互系统通过 IInteractable 触发，玩家靠近后按交互键执行 Collect 动作。
这部分已经实现，不需要额外改动动画系统。

## 八、本工作区执行范围

根据用户要求，本工作区（10.0.2）只完成：
1. ✅ CropStageConfig 新增 daysToNextStage 字段
2. ✅ CropController 固定 4 阶段常量
3. ✅ 重写生长天数计算（从均分改为每阶段独立天数）
4. ✅ 更新 CropSystemTests 适配新的阶段计算

以下内容放到下一个工作区（10.0.3）：
- 收获改用 DropTable
- SeedData 字段精简（移除 harvestCropID 等）
- 枯萎收获逻辑调整

## 九、待用户确认的问题

1. 固定 4 阶段是否满足所有作物需求？（有些作物可能需要更多阶段？）
2. 收获改用 DropTable 后，品质系统如何处理？（当前有随机品质逻辑）
3. 枯萎作物是否还需要收获？（当前枯萎成熟可以收获枯萎作物）
4. SeedData 的 growthDays 是否完全移除？（还是保留作为总天数参考？）


## 十、用户确认（2026-02-14）

### 对第九章待确认问题的回复

1. **固定 4 阶段** — 确认，4 阶段满足需求
2. **品质系统** — 放到 10.0.3 一起处理（DropTable 的 DropConfig.quality 控制）
3. **枯萎作物收获** — 放到 10.0.3 一起处理
4. **SeedData.growthDays** — 放到 10.0.3 处理（由 CropStageConfig.daysToNextStage 替代后移除）

### 用户补充需求（收获交互机制）

用户明确了收获交互的完整流程：
- 右键点击成熟作物 → 导航到作物附近 → 播放 Collect 动画 → 第4~5帧触发收获逻辑
- Collect 不是工具动画，是一个动作动画（AnimState.Collect = 4）
- 当前 TryInteract 直接调用 OnInteract，没有播放 Collect 动画
- 需要在 GameInputManager 或相关位置集成 Collect 动画触发

### 本工作区（10.0.2）执行范围确认

1. CropStageConfig 新增 `daysToNextStage` 字段
2. CropController 固定 4 阶段常量（CROP_STAGE_COUNT = 4）
3. 重写生长天数计算（从均分改为每阶段独立天数累加）
4. 更新 CropSystemTests 适配新的阶段计算

### 10.0.3 工作区待做内容

1. 收获改用 DropTable（掉落到地面）
2. 收获交互集成 Collect 动画（第4~5帧触发）
3. SeedData 字段精简（移除 growthDays / harvestCropID / harvestAmountRange）
4. 枯萎收获逻辑调整
5. 品质系统适配（DropTable 的 DropConfig.quality）
