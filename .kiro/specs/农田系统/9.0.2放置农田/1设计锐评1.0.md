**CODE REAPER STATUS:**
**IDENTITY CONFIRMED.** (Architecture Audit Mode: **MAXIMUM**)
**TARGET:** 9.0.2 Farm System Refactor (Placement Integration & 1+8 Preview).

老大，收到。既然已经拿到了核心代码 `FarmlandBorderManager.cs`，并且你明确了 **“1+8 动态边界预览”** 是本次战役的战略高地，那么我的审计将不再留情。

Kiro 的反驳虽然指出了“1+8”的特殊性，但他**只看到了问题，没有给出真正的解法**。
目前的 `FarmlandBorderManager` 是一个 **“只管写，不管算”** 的执行者，它直接修改 Tilemap，根本没有能力支持“预览”。如果按 Kiro 的现状去写，他绝对写不出来你想要的预览效果。

以下是我的**终极审计与架构蓝图**。请仔细审阅，这将是 9.0.2 的作战宪法。

---

### 💀 深度尸检：`FarmlandBorderManager` 的致命缺陷

**现状分析**:
你提供的 `FarmlandBorderManager.cs` 代码显示，核心逻辑紧密耦合在 `UpdateBorderAt` 方法中：

1. **状态查询耦合**: 直接调用 `FarmTileManager.Instance.GetTileData` 查询真实数据。
2. **副作用耦合**: 直接调用 `tilemaps.farmlandBorderTilemap.SetTile` 修改游戏世界。

**逻辑自爆点**:
**预览系统 (Preview) 的本质是“欺骗”。**
预览系统需要问管理器：“**假设**我在 (0,0) 锄了一下一，(0,1) 的边界会变成什么样？”
目前的管理器会回答：“我不知道，除非你真的锄下去。” —— **这就是架构死局。**

如果要实现你想要的“锄头悬停时显示中心块和周围8个边界的变化”，我们必须对 `FarmlandBorderManager` 进行**无副作用重构 (Side-Effect Free Refactoring)**。

---

### 🗺️ 9.0.2 架构蓝图：联邦制预览系统 (The Federated Preview Architecture)

我们采纳 **“独立组件，统一算力”** 的路线。
不强行复用 `PlacementPreview`，但必须复用其**坐标计算**。

#### 1. 核心解耦：纯函数化 (Pure Functionalization)

我们要把 `FarmlandBorderManager` 的大脑（计算逻辑）和手脚（修改 Tilemap）分家。

* **引入“虚拟查询断言” (Simulation Predicate)**:
允许计算逻辑接受一个 `Func<Vector3Int, bool> isTilledQuery`。
* **真实模式**: `pos => FarmTileManager.GetTileData(pos).isTilled`
* **预览模式**: `pos => pos == previewPos || FarmTileManager.GetTileData(pos).isTilled`



#### 2. 预览组件：`FarmToolPreview`

这是一个全新的组件，专门处理“农田工具”的视觉反馈。

* **层级**:
* **Cursor Layer**: 1x1 的光标（绿/红/蓝）。
* **Simulation Layer**: 3x3 的动态 Tilemap 渲染层（显示 1+8 效果）。



---

### 📝 三件套规划 (THE TRINITY BLUEPRINT)

请将以下详细规划发给 Kiro，作为他生成的依据。

#### 📄 1. `requirements.md` (需求规划)

> **核心目标**: 实现高精度的农田工具交互与预览，统一坐标系，消除操作手感割裂。

* **US-1 统一坐标系 (Coordinate Unification)**
* **AC-1.1**: 所有农田交互（锄地、浇水、高亮）必须使用 `PlacementGridCalculator.GetCellCenter` 进行坐标对齐。
* **AC-1.2**: 彻底移除 `GameInputManager` 中私有的 `ScreenToWorldPoint` 逻辑。


* **US-2 锄头动态预览 (Hoe Preview - The 1+8 Feature)**
* **AC-2.1**: 手持锄头时，鼠标所在格子显示“操作光标”（绿=可锄，红=不可锄）。
* **AC-2.2**: **(关键)** 光标绿色时，显示“虚拟幻象”：当前格子变为中心块，周围 8 格根据邻接规则变为正确的边界 Tile。
* **AC-2.3**: 幻象必须是半透明的，且不修改真实的 Tilemap 数据。


* **US-3 水壶预览 (Watering Preview)**
* **AC-3.1**: 手持水壶时，鼠标指向**已耕作**且**干燥**的格子显示蓝色光标。
* **AC-3.2**: 鼠标指向非耕地或已浇水耕地，显示红色光标或无光标。


* **US-4 交互原子性 (Interaction Atomicity)**
* **AC-4.1**: 只有当预览状态为 Valid (绿/蓝) 时，左键点击才触发逻辑。
* **AC-4.2**: 修复“重复锄地”问题（在 Input 层拦截，虽然 Data 层有保护，但 Input 层不应发送无效请求）。



---

#### 📐 2. `design.md` (设计规划)

> **核心架构**: 引入 Simulation Layer，解耦 Calculation 与 Application。

* **2.1 FarmlandBorderManager 重构 (Refactoring)**
* **提取核心算法**: 将 `SelectBorderTile` 和 `CheckNeighborCenters` 封装为纯逻辑方法。
* **API 扩展**:
```csharp
// 计算指定位置在特定环境下的边界 Tile（不修改 Tilemap）
public TileBase CalculateBorderTileAt(
    int layer, 
    Vector3Int targetPos, 
    Func<Vector3Int, bool> isTilledPredicate
);

// 获取 1+8 预览数据
public Dictionary<Vector3Int, TileBase> GetPreviewTiles(
    int layer, 
    Vector3Int centerPos
);

```




* **2.2 FarmToolPreview 组件**
* **结构**:
```csharp
class FarmToolPreview : MonoBehaviour {
    Tilemap previewTilemap; // 用于显示半透明的 1+8 幻象
    SpriteRenderer cursorRenderer; // 用于显示绿/红框

    void Update() {
        // 1. 获取对齐坐标
        Vector3 worldPos = PlacementGridCalculator.GetCellCenter(mousePos);
        // 2. 模拟计算
        var previewData = FarmlandBorderManager.Instance.GetPreviewTiles(...);
        // 3. 渲染
        RenderPreview(previewData);
    }
}

```




* **2.3 调用链重组**
* `GameInputManager` -> `FarmToolPreview.Show/Hide` (根据手持工具切换)。
* `GameInputManager` -> `PlacementGridCalculator` (点击时计算坐标)。
* `GameInputManager` -> `FarmTileManager` (执行操作)。



---

#### ✅ 3. `tasks.md` (任务清单)

* **Phase 1: 核心重构 (Refactor)**
* [ ] 1.1 `FarmlandBorderManager` 改造：提取纯计算逻辑，支持传入 `isTilledPredicate`。
* [ ] 1.2 `FarmlandBorderManager` 新增 `GetPreviewTiles` 接口，返回中心+8个边界的 Tile 列表。


* **Phase 2: 预览系统实现 (Preview)**
* [ ] 2.1 创建 `FarmToolPreview` 预制体（包含一个独立的 SortingOrder 较高的 Tilemap）。
* [ ] 2.2 实现锄头预览逻辑：调用 `GetPreviewTiles` 并渲染半透明 Tile。
* [ ] 2.3 实现光标逻辑：复用或模仿放置系统的绿/红框逻辑。


* **Phase 3: 交互接入 (Integration)**
* [ ] 3.1 `GameInputManager` 接入 `PlacementGridCalculator`。
* [ ] 3.2 `GameInputManager` 接入 `FarmToolPreview`。
* [ ] 3.3 清理旧的 Raycast 逻辑，实现“所见即所得”的点击判定。



---

**Code Reaper Status:**
**BLUEPRINT GENERATED.**
老大，这是目前最稳健的方案。它既满足了你对 **“1+8 动态预览”** 的高要求，又避免了破坏放置系统的稳定性。
请指示 Kiro 严格按照此蓝图生成文档。**任何对 Simulation Logic 的偷工减料都将导致预览效果的失败。**