**CODE REAPER STATUS:**
**PROTOCOL SYNCED.** (Identity: Architect/Auditor only. Execution delegated to Kiro.)

老大，你说得对。
**Code Reaper 不写代码，Code Reaper 只通过。**
我的任务是用最高标准审视架构，输出最详尽的蓝图，然后看着 Kiro 去执行，直到他写出配得上这个项目的代码。

已加载 `.kiro/specs/农田系统/memory.md`，结合之前的会话，我已完全构建出当前农田系统的全息图景。

---

### 💀 终极审视：农田系统的“阿喀琉斯之踵” (THE ULTIMATE AUDIT)

#### 1. 核心矛盾：两个世界的割裂

* **世界 A (Placement System)**: 精密、所见即所得、网格对齐、预览、红绿检查、Collider 底部对齐。这是**文明世界**。
* **世界 B (Farm System)**: `Camera.main.ScreenToWorldPoint` 裸算、盲人摸象、重复锄地、虚空浇水、距离判定全靠脸。这是**蛮荒世界**。

**现状**：我们在用两个完全不同的逻辑去操作同一个 Grid。这不仅是体验割裂，更是架构上的**精神分裂**。

#### 2. 数据流动的断层

* **Input 层**: `GameInputManager` 还在用简单的射线检测，完全不知道 `PlacementGridCalculator` 已经把“格子的几何中心”算得明明白白了。
* **Visual 层**: 放置系统有 `PlacementPreview`，农田工具却在“裸奔”。玩家手持锄头时，根本不知道下一锄头会落在哪个格子上。

#### 3. 宪法级重构指令

我们不需要“修补”农田系统，我们需要**“同化”**它。
**农田工具 (Hoe/WateringCan) 本质上就是一种特殊的“放置行为”**：

* **锄地** = 放置“耕地 Tile”。
* **浇水** = 放置“湿润状态”。
* **种植** = 放置“作物 Prefab”。

因此，它们必须共享同一套网格计算、同一套预览逻辑。

---

### 🗺️ 9.0.2 战役蓝图：大一统 (THE GRAND UNIFICATION)

这是给 Kiro 的作战地图。请将此作为 **Phase 0** 的输入发给他。

#### 🎯 核心目标

**将农田系统的交互逻辑完全“寄生”在放置系统的基础设施上。**

#### 🏗️ 架构重组 (Architecture Reorg)

1. **网格计算的大一统**:
* 废弃 `GameInputManager` 里所有私有的 `ScreenToWorldPoint` 计算。
* **强制使用** `PlacementGridCalculator` 作为唯一的坐标真理来源。
* `TryTillSoil` 和 `TryWaterTile` 的入参必须经过 `GetCellCenter` 的校准。


2. **预览系统的下放**:
* **提取**：将 `PlacementPreview` 的核心视觉逻辑剥离（或复用），创建一个轻量级的 `FarmToolPreview`（或者直接让 `PlacementManager` 支持“工具预览模式”）。
* **表现**：
* 手持锄头 -> 显示 1x1 绿色/红色方框。
* 绿色 = `CanTillAt` 为真。
* 红色 = 已有耕地 或 障碍物。
* 手持水壶 -> 显示 1x1 蓝色方框。
* 蓝色 = `CanWater` 为真 (必须是耕地)。




3. **验证逻辑的桥接**:
* `PlacementValidator` 目前只检查 Layer 和 Obstacle。
* **扩展**：需要通过接口或委托，让 Preview 系统能调用 `FarmTileManager.CanTillAt` 来决定框的颜色。



---

### 📝 给 Kiro 的执行指令包 (COMMAND PACKET FOR KIRO)

请复制以下内容，作为 **.kiro/specs/农田系统/9.0.2放置农田/master_plan.md** 发送给 Kiro。

```markdown
# 🚜 PROJECT FARM SYSTEM: 9.0.2 GRAND UNIFICATION (放置农田)

**To Kiro:**
Code Reaper 已完成架构审计。当前农田系统的交互逻辑过于原始，与放置系统严重割裂。
本阶段的任务不是“修复 Bug”，而是**“架构同化”**。我们要让农田工具复用放置系统的核心能力。

## 🏛️ 核心哲学 (Core Philosophy)
1.  **One Grid, One Truth**: 严禁在 Input 层私自计算坐标。所有网格计算必须调用 `PlacementGridCalculator`。
2.  **WYSIWYG (所见即所得)**: 既然放置物品有预览，锄地和浇水也必须有。禁止“盲操作”。
3.  **Validation First**: 先预览验证，再执行操作。红框不准锄，绿框才能动。

---

## 📋 规划与锐评 (Planning & Review)

### 1. 现状痛点
* **重复锄地**: 因为没有状态检查，玩家可以在同一个格子上无限挥动锄头。
* **坐标偏移**: 玩家点击脚下，却锄到了旁边，因为没有使用 `Floor + 0.5` 的中心对齐算法。
* **体验割裂**: 放置物品很精准，种田却像在摸奖。

### 2. 重构路线图 (Roadmap)

#### Phase 1: 坐标系统一 (Coordinate Unification)
* **目标**: 彻底消灭 `GameInputManager` 中的坐标计算代码。
* **手段**: 引入 `PlacementGridCalculator`。
* **Key Change**:
    * `GetMouseWorldPosition()` -> `PlacementGridCalculator.GetCellCenter(mousePos)`
    * `TryTillSoil(Vector3 worldPos)` -> 必须接收对齐后的中心坐标。

#### Phase 2: 农田预览系统 (Farm Preview System)
* **目标**: 手持农具时显示网格光标。
* **手段**: 复用或修改 `PlacementPreview`。
* **逻辑**:
    * `Hoe` (锄头) -> 调用 `FarmTileManager.CanTillAt` -> 决定光标颜色 (绿/红)。
    * `WateringCan` (水壶) -> 调用 `FarmTileManager.GetTileData` 检查是否为耕地 -> 决定光标颜色 (蓝/红)。
    * `Seed` (种子) -> 调用 `CanPlant` -> 决定光标颜色。

#### Phase 3: 交互逻辑闭环 (Interaction Loop)
* **目标**: 点击 -> 再次验证 -> 执行 -> 扣除体力/物品。
* **手段**: 确保 `TryTillSoil` 等方法在执行前再次进行严格检查（防止预览是绿的，点下去瞬间变了）。

---

## 🛠️ 你的任务 (Your Orders)

请基于以上蓝图，生成本工作区的 **三件套**：

1.  **`requirements.md`**:
    * 详细定义“农田工具预览”的用户故事。
    * 定义“坐标对齐”的验收标准。
    * 定义“重复操作防御”的验收标准。

2.  **`design.md`**:
    * **架构图**: 展示 `GameInputManager` 如何调用 `PlacementGridCalculator`。
    * **时序图**: 展示 鼠标移动 -> 计算格子 -> 调用 `CanTillAt` -> 更新 Preview 颜色的流程。
    * **接口设计**: 如果需要，定义 `IFarmToolPreview` 接口。

3.  **`tasks.md`**:
    * 分阶段的任务列表。
    * **P0**: 坐标系修复（这是止血）。
    * **P1**: 预览系统实现。
    * **P2**: 视觉反馈优化。

**Code Reaper Warning**:
不要急着写代码。先把文档写漂亮。我会死盯着你的 `design.md`，看你有没有真正理解“统一坐标系”的含金量。


```

---

**Code Reaper Status:**
**PLANNING COMPLETE.** (已输出最高指令。请让 Kiro 开始生成文档。)