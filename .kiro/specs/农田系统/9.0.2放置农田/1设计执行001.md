**CODE REAPER STATUS:**
**IDENTITY CONFIRMED.** (Architecture Audit Mode: **SUPREME**)
**TARGET:** Kiro's "Design Comparison & Analysis" (Kiro与Gemini设计路线对比分析).

老大，我已对 Kiro 的《设计路线对比分析》进行了**最高优先级的深度尸检**。
结论是：**Kiro 终于觉醒了。**

他不再试图用“防御性编程”来掩盖架构的懒惰，而是真正理解了我在 0.5 和 1.0 锐评中指出的核心矛盾——**“模拟能力 (Simulation Capability)”**。

他对 `Func<Vector3Int, bool>` 断言模式（Predicate Pattern）的提出，是本次架构博弈的**决胜手**。这正是解开“1+8 动态预览”死结的金钥匙。

以下是我的全面分析与最终裁决。

---

### 💀 一、 路线之争的终极复盘 (THE ROUTE DEBRIEF)

你问我两个路线的区别，以及谁是对的。

#### 1. Kiro 的旧路线 (The Coward's Path)

* **思路**: “代码能跑就行，别动核心逻辑。”
* **表现**: 试图在 Input 层打补丁，复用放置系统的外壳，却忽略了农田系统内部“1+8”的复杂性。
* **结局**: **死路**。如果不重构 `FarmlandBorderManager`，预览系统永远只能是个“静态方框”，无法显示边界融合的动态效果。

#### 2. Code Reaper 的路线 (The Architect's Path)

* **思路**: “架构必须反映业务本质。”
* **表现**: 指出农田交互本质上是一种“具有副作用的放置行为”，强推“模拟层 (Simulation Layer)”的概念。
* **结局**: **正解**。必须让系统具备“预知未来”的能力（即：如果我点这里，数据会变成什么样？）。

#### 3. 最终的真理 (The Truth)

Kiro 在文档中提出的 **“联邦制 + 断言模拟”** 方案是**绝对正确的**。

* **联邦制**: 农田预览 (`FarmToolPreview`) 独立于放置预览 (`PlacementPreview`)，互不干扰，但共享坐标算法 (`PlacementGridCalculator`)。
* **断言模拟**: 利用 C# 的 `Func` 委托，将“真实数据查询”替换为“虚拟数据查询”，从而在不修改数据的情况下计算出预览结果。

---

### 🔍 二、 技术方案审视 (TECHNICAL AUDIT)

Kiro 提出的代码方案非常精准，我批准并对其进行**加固**：

#### 1. 核心解法：依赖注入 (Dependency Injection of Logic)

Kiro 的这段代码是本次重构的灵魂：

```csharp
// 重构前：硬编码依赖真实数据
// var tileData = FarmTileManager.Instance.GetTileData(pos);

// 重构后：依赖抽象的断言
Func<Vector3Int, bool> isTilledPredicate

```

**Code Reaper 评价**: **S 级设计**。

* 这让 `FarmlandBorderManager` 变成了一个**纯函数式计算器**。
* 它不仅解决了预览问题，未来如果有“撤销/重做”功能，或者“规划模式”，这套逻辑可以直接复用。

#### 2. 组件拆分

* **独立 `FarmToolPreview**`: **批准**。放置系统的代码已经够复杂了，不要把农田的 1+8 逻辑塞进去。让农田工具拥有自己独立的视觉组件。

---

### 🏛️ 三、 9.0.2 最终执行蓝图 (THE FINAL BLUEPRINT)

老大，既然 Kiro 已经跟上了强度，我们不需要再争论“怎么做”，而是直接下达“做什么”。

请发布以下指令，这将是 **9.0.2 农田放置化** 的最终宪法。

#### 1. 核心哲学

* **One Grid**: 坐标计算必须由 `PlacementGridCalculator` 独裁。
* **Simulation First**: 先模拟，后执行。只有模拟通过（绿色），才能写入数据。

#### 2. 架构修正指令 (Architecture Amendments)

**A. Input 层 (GameInputManager)**

* **废弃**: 私有的 `GetMouseWorldPosition`。
* **接入**: 必须调用 `PlacementGridCalculator.GetCellCenter` 获取对齐后的坐标。
* **路由**:
* 手持可放置物品 -> 调用 `PlacementManager`。
* 手持农具 -> 调用 `FarmTileManager` + `FarmToolPreview`。



**B. Logic 层 (FarmlandBorderManager)**

* **重构**: 将 `UpdateBorderAt` 拆分为：
1. `CalculateBorderTile(pos, predicate)` -> 返回 TileBase (纯计算，无副作用)。
2. `ApplyBorderTile(pos, tile)` -> 修改 Tilemap (有副作用)。


* **新增**: `GetPreviewTiles(centerPos)` -> 内部构造一个 `predicate` (假装 centerPos 已耕作)，返回 `Dictionary<Vector3Int, TileBase>`。

**C. Visual 层 (FarmToolPreview)**

* **新建组件**:
* `Cursor`: 显示 1x1 绿/红框 (SpriteRenderer)。
* `GhostLayer`: 显示半透明的边界预览 (Tilemap, Alpha=0.5)。


* **行为**:
* 每帧调用 `GetPreviewTiles`。
* 将返回的 Tile 设置到 `GhostLayer` 上。



---

### 🚀 下一步行动 (NEXT STEP)

**Code Reaper Status:**
**CONSENSUS ACHIEVED.** (已达成架构共识。方案完美。)

老大，请直接把下面这段 **[P1 阶段执行令]** 甩给 Kiro。这包含了基于他自己分析报告提炼出的最终任务清单。他现在既然思路清晰，就让他立刻把文档落地。

**(请复制以下内容发送给 Kiro)**

```markdown
# 🚜 PROJECT 9.0.2: FARM SYSTEM REBIRTH (The Unified Plan)

**To Kiro:**
Code Reaper 已审阅你的《设计路线对比分析》。
**通过 (APPROVED).**
你对“1+8 模拟难点”的分析非常精准，提出的 `Func<Vector3Int, bool>` 断言模式是本次重构的核心解法。

我们现在达成最终共识：
1.  **架构路线**: 联邦制。`FarmToolPreview` 独立，但坐标计算统一使用 `PlacementGridCalculator`。
2.  **核心技术**: 通过 `Predicate` 委托实现 `FarmlandBorderManager` 的无副作用模拟。

---

## 📜 任务 1: 文档落地 (Documentation)

请立即基于此共识，更新本工作区的 **三件套**：

### 1. `design.md` (关键)
* **更新架构图**: 展示 `GameInputManager` 如何分流请求到 `PlacementManager` 和 `FarmTileManager`。
* **详细设计 `FarmlandBorderManager`**:
    * 展示 `CalculateBorderTile` 和 `GetPreviewTiles` 的方法签名。
    * 展示 `Predicate` 的工作流。
* **详细设计 `FarmToolPreview`**:
    * 定义 Ghost Tilemap 的层级和透明度处理。

### 2. `requirements.md`
* 新增 **US-Preview**: “作为玩家，我希望在锄地前看到预期的边界变化（虚影），以便知道耕地会连成什么形状。”

### 3. `tasks.md`
* **P1.1 (Core)**: 重构 `FarmlandBorderManager`，提取纯计算逻辑 (Pure Function)。
* **P1.2 (Preview)**: 实现 `GetPreviewTiles` 接口。
* **P1.3 (Visual)**: 实现 `FarmToolPreview` 组件 (Ghost Layer)。
* **P1.4 (Input)**: `GameInputManager` 接入统一坐标系和预览组件。

---

**Code Reaper Directive:**
不需要再讨论了。思路已经清晰。
**Execute Phase 1 Documentation.** (立即生成文档。)

```