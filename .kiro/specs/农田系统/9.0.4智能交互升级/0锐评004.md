**CODE REAPER STATUS:**
**IDENTITY RE-CALIBRATED.** (Mode: Objective, Professional, Comprehensive. Drama: OFF.)

老大，批评接受。我之前确实陷入了“为了炫技而设计”的陷阱，忽略了现有代码的实际情况，甚至在未读取代码前就预设了方案，这是严重的专业失误。

现在，我已详细阅读了你上传的 `PlayerAutoNavigator.cs` 源码，并结合 Kiro 的 `锐评003审视报告` 进行了**完全基于事实**的客观分析。

这里是**去除所有情绪化表达、基于代码事实**的最终审视报告与执行规划。

---

### 🔍 一、 核心矛盾的客观裁决 (OBJECTIVE AUDIT)

Kiro 在报告中拒绝了“协程”，坚持“回调/状态机”，并声称基础设施已就绪。
通过阅读源码，我发现 **Kiro 的评估存在事实性错误，但他的架构直觉（拒绝过度设计）是合理的。**

#### 1. 事实核查：`PlayerAutoNavigator.cs` 的能力缺失

Kiro 认为可以直接用回调。
**代码事实**：目前的 `PlayerAutoNavigator.cs` **根本不支持** 单次导航的回调。

* **证据**：第 108 行 `public void SetDestination(Vector3 target)`。它没有任何 `Action onComplete` 参数。
* **证据**：第 154 行 `public event System.Action OnDestinationReached;`。这是一个**广播事件**。
* **风险**：如果使用广播事件，任何物体到达终点都会触发（比如自动寻路 NPC），这会导致逻辑污染。
* **结论**：Kiro 的方案目前无法落地，必须修改底层代码。

#### 2. 事实核查：中断机制

Kiro 声称已有 `ForceCancel`。
**代码事实**：`PlayerAutoNavigator.cs` 中**不存在** 名为 `ForceCancel` 的方法。

* **证据**：只有 `public void Stop()` (第 121 行)。
* **结论**：Kiro 记忆有误，需要统一术语。

#### 3. 架构裁决：协程 vs 状态机

* **我的前次观点**：用协程锁死生命周期。
* **Kiro 的观点**：用 `Update` 状态机管理，协程太复杂。
* **客观裁决**：**Kiro 胜。** 在 `GameInputManager` 这种重型 Input 类中，维护一个 `_farmingState` 枚举比嵌套协程更易读，也更容易调试。
* **修正**：我们要采纳 Kiro 的“状态机”路线，但必须补全 `PlayerAutoNavigator` 的能力。

---

### 🗺️ 二、 9.0.4 综合实施方案 (COMPREHENSIVE PLAN)

我们不引入“事务ID”这种复杂概念，也不用“协程”。
我们采用 **“扩展回调 + 状态锁定”** 的标准工业方案。

#### 🛠️ 步骤 1：基础设施补全 (Infrastructure)

**目标**：让 `PlayerAutoNavigator` 支持“带回调的移动”。

修改 `PlayerAutoNavigator.cs`：

1. **新增字段**：`private System.Action _onCurrentNavComplete;`
2. **修改方法**：
```csharp
// 重载一个支持回调的方法
public void SetDestination(Vector3 target, System.Action onComplete = null) {
    _onCurrentNavComplete = onComplete; // 存储回调
    // ... 原有的移动逻辑 ...
}

```


3. **触发回调**：
在 `Update` 检测到达逻辑中（第 90 行左右）：
```csharp
if (distanceToTarget <= stopDistance) {
    // ... 停止逻辑 ...
    _onCurrentNavComplete?.Invoke(); // 🔥 执行回调
    _onCurrentNavComplete = null;    // 🔥 执行后立即清空，防止重复
    OnDestinationReached?.Invoke();  // 原有的广播继续保留
}

```


4. **安全清理**：
在 `Stop()` 方法中（第 121 行）：
```csharp
_onCurrentNavComplete = null; // 🔥 强行停止时，必须杀掉回调，防止意外触发

```



#### 🧠 步骤 2：交互逻辑重构 (Interaction Logic)

**目标**：在 `GameInputManager` 中实现“智能分流”。

采用 Kiro 提倡的状态管理，而非协程。

1. **定义状态**：
```csharp
private enum FarmingInteractState { Idle, Navigating, Executing }
private FarmingInteractState _interactState = FarmingInteractState.Idle;

```


2. **实现分流 (`TryExecuteAction`)**：
```csharp
if (preview.IsValid) {
    if (preview.IsInRange) {
        // A. 距离够：立即执行
        ExecuteActionImmediate();
    } else {
        // B. 距离不够：启动导航
        _interactState = FarmingInteractState.Navigating;

        // 使用我们刚加的回调方法
        autoNavigator.SetDestination(targetPos, onComplete: () => {
            // 回调：到达后检查
            if (_interactState == FarmingInteractState.Navigating) {
                // 二次检查（防止环境变化）
                if (preview.IsValid) {
                    ExecuteActionImmediate();
                } else {
                    // 反馈：播放失败音效/动画
                    ShowFailureFeedback(); 
                }
                _interactState = FarmingInteractState.Idle;
            }
        });
    }
}

```



#### 🛡️ 步骤 3：全局中断 (Global Interrupt)

**目标**：确保任何操作都能打断导航。

在 `GameInputManager` 中创建一个统一中断方法：

```csharp
private void CancelSmartInteraction() {
    if (_interactState == FarmingInteractState.Navigating) {
        autoNavigator.Stop(); // 这会清空 navigator 内部的回调
        _interactState = FarmingInteractState.Idle;
    }
}

```

**插入点**：

* `HandleMovement`: 玩家按下 WASD -> `CancelSmartInteraction()`
* `HandleHotbar`: 玩家切换物品 -> `CancelSmartInteraction()`
* `ToggleInventory`: 打开 UI -> `CancelSmartInteraction()`

---

### ⚔️ 给 Kiro 的最终指令 (EXECUTION ORDER)

老大，请将这份经过客观审视、剔除个人偏好、结合了代码事实的指令发给 Kiro。

**To Kiro:**
Code Reaper 已完成对源码 `PlayerAutoNavigator.cs` 的客观审计。
之前的分歧（协程 vs 回调）已翻篇。我们根据**代码现状**制定了最终方案。

**关键事实确认**：

1. 现有的 `PlayerAutoNavigator` **不支持** 局部回调（只有全局广播），必须修改。
2. 现有的 `PlayerAutoNavigator` **没有** `ForceCancel` 方法（只有 `Stop`）。
3. 我们采纳你的 **“状态机”** 思路，弃用协程。

**执行任务清单 (9.0.4 最终版):**

1. **修改 `PlayerAutoNavigator.cs**` (必须先做)
* 新增 `SetDestination` 的重载，接受 `Action onComplete`。
* 在到达目标时调用并清空该 `Action`。
* 在 `Stop()` 时清空该 `Action` (防止逻辑残留)。


2. **修改 `FarmToolPreview.cs**`
* **解耦**: `IsValid` 只管红绿（逻辑/物理），`IsInRange` 只管远近。
* **公开**: 提供 `CurrentCursorPos` 给导航器使用。


3. **修改 `GameInputManager.cs**`
* **状态管理**: 引入简单的状态标记 (Navigating/Idle)。
* **智能分流**: 近处直接执行，远处调用 `autoNavigator.SetDestination(..., onComplete: ...)`。
* **中断保护**: 在移动输入、切快捷栏、开背包时，强制调用 `autoNavigator.Stop()` 重置状态。
* **失败反馈**: 在 `onComplete` 二次检查失败时，输出 Log 或播放反馈。



**Execute.**