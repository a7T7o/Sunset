**CODE REAPER STATUS:**
**INTENSITY LEVEL: MAXIMUM.**
**PROTOCOL:** GRANDMASTER AUDIT.

老大，收到你的鞭策。
既然 Kiro 祭出了 **《交互矩阵 (Interaction Matrix)》** 这种重型武器，说明他不再满足于做一个“写代码的”，而是开始像一个“系统设计师”那样思考了。

这份矩阵文档（`交互矩阵.md`）覆盖了 **15 种交互场景** 和 **8 个边界测试用例**，特别是对 **“导航中途被截胡 (TH07/TH08)”** 的预判，达到了 S 级水准。

我已悉数阅毕所有文档。现在，我将以 **Code Reaper 的完全体形态**，对他这份看似完美的计划进行 **压力测试**，找出他逻辑缝隙中的每一粒沙子。

---

### 💀 深度压力测试 (STRESS TEST REPORT)

#### 1. 导航系统的“黑盒风险” (The Black Box Risk)

Kiro 在 `锐评001审视报告.md` 中谦虚地提到：“需要验证 `PlayerAutoNavigator` 是否支持回调”。
**Code Reaper 锐评**：
这不是“验证”，这是 **死生之地**。
如果导航器不支持精准的 `onComplete` 回调，或者回调时机在 Update 循环中不确定（例如：刚到位置下一帧才回调），会导致 `ExecuteAction` 执行时玩家位置产生微小滑步，进而导致 `FarmTileManager` 判定“距离过远”而失败。
**风险等级：CRITICAL**。必须优先拆弹。

#### 2. “二次检查”的时空悖论 (The Time-Space Paradox)

Kiro 在 `design.md` 中定义了 P5 属性：`ExecuteAction() ⟹ (preview.IsValid ∧ preview.IsInRange)`。
这非常正确。但有一个隐患：

* **场景**：玩家在 A 点点击 B 点锄地（导航开始）。
* **突发**：在走路的这 2 秒内，B 点被一个自动生成的杂草（或者 NPC 走过去）占据了。
* **结果**：到达后，`FarmToolPreview` 变红。
* **缺失**：这时候玩家会呆站在那里。我们需要一个 **“操作失败反馈”**（比如摇摇头，或者播放一个 Error 音效），否则玩家会以为是 Bug（点了没反应）。

#### 3. 交互优先级的“战争迷雾” (Priority Fog)

在 `交互矩阵.md` 中，Kiro 提到了 `CancelFarmingNavigation`。
**Code Reaper 锐评**：
你需要明确 **Input 的吞噬逻辑**。

* 如果我正在导航去锄地（Farming Nav），此时我点了一下地板（Movement Nav）。
* 逻辑是：**立刻取消** Farming Nav，转而执行 Movement Nav。
* 这意味着 `GameInputManager` 的 `HandleMovement` 必须拥有 **最高中断权**。Kiro 的 `tasks.md` 3.3 提到了这一点，但这需要代码层面的绝对保证。

---

### 🗺️ 9.0.4 终极执行蓝图 (THE FINAL BLUEPRINT)

基于 Kiro 的出色文档和我上述的压力测试，这是修正后的 **9.0.4 战役图**。

#### Phase 0: 基础设施核验 (Infrastructure check)

在动 `GameInputManager` 之前，必须先打开 **`PlayerAutoNavigator.cs`**。

* **检查**: 是否有 `MoveTo(Vector3 target, Action onComplete)`？
* **如果没有**: 必须先给它装上。且必须确保 `onComplete` 在 `Stop()` 之后、下一帧逻辑开始之前被调用。

#### Phase 1: 视觉解耦 (Visual Decoupling)

执行 `FarmToolPreview.cs` 的修改。

* **逻辑**: 彻底分离 `IsValid` (绿/红) 和 `IsInRange` (远/近)。
* **视觉**: 无论多远，只要是空地，就是 **绿框**。不要搞“暗绿色”那种花里胡哨的，那是 P2 的事。现在就要**纯粹的绿**。

#### Phase 2: 大脑重构 (Brain Surgery)

执行 `GameInputManager.cs` 的核心手术。

* **引入协程管理**: `Coroutine _farmingSequence`。
* **实现分流**:
```csharp
if (preview.IsInRange) {
    ExecuteImmediate();
} else {
    _farmingSequence = StartCoroutine(NavigateAndExecute(targetPos));
}

```


* **二次检查**: 在 `MapsAndExecute` 到达后，**必须再次调用** `FarmToolPreview.IsValid`。如果失败，输出 Debug Log "Target invalidated during navigation"。

#### Phase 3: 中断机制 (Interrupt Protocol)

这是最容易被遗忘的一环。

* **移动打断**: `HandleMovement` 被触发 -> `StopCoroutine(_farmingSequence)`。
* **换道具打断**: `HandleHotbar` 被触发 -> `StopCoroutine(_farmingSequence)`。
* **UI 打断**: 打开背包 -> `StopCoroutine(_farmingSequence)`。

---

### ⚔️ 给 Kiro 的最终执行令 (EXECUTE ORDER 9.0.4)

**To Kiro:**
老大和我已经审阅了你的全套方案。
**《交互矩阵》令人印象深刻。你终于跟上了我的节奏。**

现在，为了配得上这份文档，你的代码必须完美无缺。
请执行 **9.0.4 全量落地 (Full Implementation)**。

**必需产出物 (Deliverables):**

1. **`PlayerAutoNavigator.cs` (检查/修改)**
* 确保支持回调机制。如果不支持，现场添加。


2. **`FarmToolPreview.cs` (逻辑降级)**
* 实现 `IsValid` 与 `IsInRange` 的解耦。
* 提供 `CurrentCursorPos` 等公开属性。


3. **`GameInputManager.cs` (智能交互)**
* 实现 `Try...` 方法的 **"立即执行 vs 导航执行"** 分流。
* 实现 **"导航协程"** 与 **"二次检查"**。
* 实现 **"三大中断"** (移动、换道具、UI)。



**Code Reaper Warning:**
特别注意 `GameInputManager` 中的 **协程生命周期**。不要让僵尸协程在后台跑，那是交互 Bug 的万恶之源。

**Go.**