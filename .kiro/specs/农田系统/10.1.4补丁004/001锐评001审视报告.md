# 000锐评001 审视报告

> 审视时间：2026-02-21（会话2续15）
> 锐评来源：`.kiro/specs/农田系统/10.1.4补丁004/000锐评001.md`
> 路径判断：🟡 路径 B（核心正确，有细节需说明）

---

## 一、锐评核心观点摘要

Gemini 对 V5 全面审查报告提出三个"致命雷区"：

1. **P3 移除 Shader 方案将导致"视觉灾难"**：`ghostTilemap.color` 是乘法混合，棕色泥土纹理 × 绿色 = 脏黑色，不是绿色高亮
2. **P1 修复 + 增量过滤 = "幽灵消失悖论"**：canTill=false 时如果走增量过滤，已入队位置的预览 tile 与 b 层完全相同会被 `continue` 跳过，ghost 为空
3. **R1 浇水红色预览同样陷阱**：`isValid=false` 时不放置水渍 tile，shader 变红但无载体

---

## 二、事实核查结果

### 声明1：Shader 必要性（`ghostTilemap.color` 是乘法混合）

| 声明 | 代码事实 | 结论 |
|------|---------|------|
| 放置系统用纯白色方框 | `PlacementGridCell.CreateGridSprite()` 生成 `Color.white` 填充 + `new Color(1,1,1,0.3f)` 内部 | ✅ 正确 |
| `SpriteRenderer.color` 是乘法混合 | Unity 文档确认：顶点色与纹理色相乘 | ✅ 正确 |
| 白色 × 绿色 = 绿色 | `(1,1,1) × (0,1,0) = (0,1,0)` | ✅ 正确 |
| 棕色 × 绿色 = 脏黑色 | `(0.47,0.27,0.08) × (0,1,0) = (0,0.27,0)` — 极暗的深绿 | ✅ 正确 |
| 当前 Shader 用 lerp 不是乘法 | `c.rgb = lerp(c.rgb, _OverlayColor.rgb, _OverlayColor.a)` — 线性插值 | ✅ 正确 |
| V5 提议移除 Shader 改用 `ghostTilemap.color` | V5 报告模块 O 明确写了"移除 `previewOverlayMaterial`，通过 `ghostTilemap.color` 控制整体颜色" | ✅ 正确 |

**核查结论：✅ 完全正确。**

V5 报告第八章"ghostTilemap.color 的工作原理"写道："`Tilemap.color` 是一个全局颜色乘数，会影响该 Tilemap 上所有 tile 的渲染颜色。设置为 `new Color(0, 1, 0, 0.5)` 时，所有 tile 会显示为绿色半透明。这正是我们需要的效果。"

这段描述是**错误的**。`Tilemap.color` 确实是乘法混合，但"绿色半透明"只在底图为白色时成立。对于棕色泥土纹理，乘法结果是极暗的脏绿色，完全不是"绿色半透明高亮"效果。

**Shader 的 lerp 混合是不可替代的**——它能在保留原始纹理的基础上叠加颜色，而乘法混合会破坏原始颜色。

### 声明2：增量过滤"幽灵消失悖论"

| 声明 | 代码事实 | 结论 |
|------|---------|------|
| 当前代码 canTill=false 时进入 else 分支 | `if (canTill && FarmlandBorderManager.Instance != null)` — canTill=false 不进入 | ✅ 正确 |
| V5 方案要求 canTill=false 也显示 1+8 | V5 模块 O "canTill=false 也计算并显示 1+8 预览 tile" | ✅ 正确 |
| 增量过滤会跳过与 b 层相同的 tile | `if (kvp.Value == actualTile) continue;` + `actualTile = queuePreviewTilemap.GetTile(kvp.Key)` | ✅ 正确 |
| 已入队位置的预览 tile 与 b 层完全相同 | b 层入队时用 `GetPreviewTiles` 计算完整预览，ghost 也用同一方法 → 结果相同 | ✅ 正确 |

**核查结论：⚠️ 部分正确。**

锐评描述的悖论是**V5 方案如果执行会遇到的问题**，不是当前代码的 bug。V5 报告第八章"关键设计决策说明"已经意识到了这一点，明确写道："canTill=false 时显示完整预览（不做增量过滤）"。

但锐评的表述更精确、更有警示价值——V5 报告虽然在第八章提到了"不做增量过滤"，但模块 O 的代码示例中并没有体现这一点（代码示例只是简单地遍历 `previewTiles` 并 `SetTile`，没有显式标注"此处跳过增量过滤"）。如果实施者只看模块 O 的代码而忽略第八章的说明，确实可能踩坑。

**锐评的核心贡献**：将"canTill=false 时必须绕过增量过滤"从一个散落在第八章的注释提升为一个显式的、不可忽略的设计约束。

### 声明3：浇水红色预览同样陷阱

| 声明 | 代码事实 | 结论 |
|------|---------|------|
| `isValid=false` 时不放置水渍 tile | `if (isValid) { ghostTilemap.SetTile(...) }` — false 时不进入 | ✅ 正确 |
| Shader 变红但无载体 | `previewOverlayMaterial.SetColor("_OverlayColor", overlayInvalidColor)` 执行了，但 ghostTilemap 上无 tile | ✅ 正确 |

**核查结论：✅ 完全正确。**

V5 报告的 R3 修复方案只说了"统一改为 `ghostTilemap.color` 控制"，没有提到 `!isValid` 时也需要放置 tile。这是一个真实的遗漏。

---

## 三、锐评提出的 V6 方案评估

### 3.1 "保留 Shader" — ✅ 完全认同

理由已在声明1核查中充分论证。lerp 混合是实现"颜色叠加而非颜色替换"的正确方式。

### 3.2 "canTill=false 时跳过增量过滤，全量铺 1+8" — ✅ 完全认同

这是 V5 第八章已经意识到但没有在代码方案中显式体现的设计约束。锐评将其提升为显式规则是正确的。

### 3.3 "浇水 !isValid 时也放置 tile" — ✅ 完全认同

V5 遗漏了这一点。如果要实现红色反馈，必须有 tile 作为 shader 的载体。

### 3.4 "isValid 拦截而非修改 canTill" — ⚠️ 需要讨论

锐评建议：
```csharp
if (isValid && queuePreviewPositions.Contains(cellPos))
    isValid = false;
```

V5 方案：
```csharp
if (canTill && queuePreviewPositions.Contains(cellPos))
    canTill = false;
```

两者的区别：
- V5 方案修改 `canTill` → `isValid` 也变为 false（因为 `isValid = !hasObstacle && (canTill || canClearWithered)`）
- 锐评方案直接修改 `isValid` → `canTill` 保持 true

锐评的理由是"保证我们知道这里本质上是能耕地的，只是当前状态不可用"。但在当前代码中，`canTill` 的值决定了是否进入 1+8 预览计算分支（`if (canTill && ...)`）。如果 `canTill` 保持 true 但 `isValid` 为 false，代码会进入 canTill=true 分支并走增量过滤——这正是声明2描述的"幽灵消失悖论"。

**所以锐评的 V6 伪代码中"isValid=false 时跳过增量过滤"是必须配合的**。锐评的伪代码确实体现了这一点：
```
if (isValid)
    // 增量过滤
if (!isValid)
    // 跳过过滤，全量铺
```

但这意味着渲染分支的判断条件从 `canTill` 变成了 `isValid`，这是一个更大的重构。V5 方案修改 `canTill` 更简洁——canTill=false 直接进入 else 分支，在 else 分支中全量铺 1+8 + shader 染红。

**结论**：两种方案都能工作，但 V5 修改 `canTill` 的方案更简洁，不需要重构渲染分支的判断条件。锐评修改 `isValid` 的方案语义更清晰但改动更大。

### 3.5 "废弃白框" — ✅ 完全认同

V5 的 P2 已经提出统一用 1+8 染色表达，锐评进一步确认了这个方向。

---

## 四、V5 报告需要修正的内容

基于锐评的事实核查，V5 报告以下部分需要修正：

| 编号 | V5 原文 | 问题 | 修正方向 |
|------|---------|------|---------|
| P3 | "移除 `previewOverlayMaterial`，通过 `ghostTilemap.color` 控制整体颜色" | `ghostTilemap.color` 是乘法混合，棕色纹理会变脏 | **保留 Shader**，继续用 `previewOverlayMaterial.SetColor` |
| 第八章 | "`Tilemap.color` 是一个全局颜色乘数...这正是我们需要的效果" | 对乘法混合的理解错误 | 删除此段，改为说明 Shader lerp 混合的必要性 |
| 模块 O | canTill=false 时的代码示例没有显式标注"跳过增量过滤" | 实施者可能踩坑 | 在代码示例中显式标注 |
| R3 | 浇水修复方案只改颜色控制，没提到 `!isValid` 时也放置 tile | 红色反馈无载体 | 补充：`!isValid` 时也放置水渍 tile |

---

## 五、最终采纳决策

| 锐评观点 | 采纳程度 | 说明 |
|---------|---------|------|
| 保留 Shader | ✅ 完全采纳 | lerp 混合不可替代 |
| canTill=false 全量铺 1+8 | ✅ 完全采纳 | V5 已有此意图但表述不够显式 |
| 浇水 !isValid 也放置 tile | ✅ 完全采纳 | V5 遗漏 |
| 修改 isValid 而非 canTill | ⚠️ 不采纳 | V5 修改 canTill 更简洁，效果等价 |
| 废弃白框 | ✅ 完全采纳 | 与 V5 P2 方向一致 |

---

## 六、修正后的执行方案（V5.1）

基于 V5 + 锐评修正，最终执行方案：

### 模块 N（P1）：a 层 canTill 纳入 b 层 — 不变
```csharp
if (canTill && queuePreviewPositions.Contains(cellPos))
    canTill = false;
```

### 模块 O（P2 + P3）：统一颜色控制 — 重大修正

**保留 Shader**，不移除 `previewOverlayMaterial`。

修改点：
1. `EnsureComponents`：保留 shader Material 创建和赋值（不变）
2. `UpdateHoePreview` canTill=true 分支：保留增量过滤 + `previewOverlayMaterial.SetColor(overlayValidColor)`（不变）
3. `UpdateHoePreview` canTill=false 分支（**核心修改**）：
   - 调用 `GetPreviewTiles` 计算完整 1+8 预览
   - **不做增量过滤**，直接全量 `SetTile`
   - `previewOverlayMaterial.SetColor(overlayInvalidColor)` 染红
   - 移除 `cursorRenderer.enabled = true`（废弃白框）
4. `UpdateWateringPreview` isValid=false 分支（**新增**）：
   - 也放置水渍 tile（使用缓存的 variant）
   - `previewOverlayMaterial.SetColor(overlayInvalidColor)` 染红

### 模块 P（R1 + R2）：浇水/播种 ghost 纳入 b 层检查 — 不变

---

## 七、给 Gemini 的信息补充

1. V5 报告第八章"关键设计决策说明"已经意识到 canTill=false 时需要跳过增量过滤，但确实没有在模块 O 的代码方案中显式体现。感谢锐评将这个隐含约束提升为显式规则。

2. 关于"修改 isValid 还是 canTill"：两种方案效果等价，但修改 canTill 不需要重构渲染分支的判断条件（当前代码用 `if (canTill && ...)` 控制分支），改动更小更安全。

3. Shader 的 lerp 混合确实是不可替代的。V5 对 `Tilemap.color` 工作原理的理解有误，这是一个严重的认知错误。感谢锐评的精准打击。

4. 当前 `FarmPreviewOverlay.shader` 的混合模式是 `Blend One OneMinusSrcAlpha`（预乘 Alpha），fragment shader 中先 lerp 再 `c.rgb *= c.a`。这个 shader 设计是正确的，能在保留原始纹理细节的同时叠加颜色。
