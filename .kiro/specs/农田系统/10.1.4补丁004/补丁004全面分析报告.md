# 补丁004 全面分析报告

## 用户原始 Prompt 完整记录

> 现在请你进入补丁004阶段并新建相关工作区，然后下面几点请你认真分析和深入思考：
>
> 1、首先你的耕地8+1的预览逻辑全面bug，首先你的预览并不需要处理已经有的耕地的部分也就是如图这样，预览处于一块耕地的左部，你直接更新8+1的预览是错误的，不需要更新已经存在内容的边界位置，如图这个情况你只需要处理1+5，因为右边三个地方都已经满了，其实预览就是修改后的实际内容，只是相同的内容不重复显示预览，难道不是吗
>
> 2、然后对于耕地创建后你只会清理队列预览的中心块内容，边界你没有清理，也就是队列预览创建的时候创建了1+8，动画执行完毕创建完成后就只清理掉中心块，留下剩余的8，这是不对的
>
> 3、对于你现在的耕地和浇水交互都存在一个巨大问题就是在动画播放时我输入移动，你直接把当前正在执行的预览也删了，也就是如果我刚开始耕地，然后紧接着输入wasd内容后当前正在执行位置的预览就先消失了，导致我现在耕地动作还没达到触发耕地创建的时候预览就先消失了，就好像凭空出现一样，正在执行的预览我希望你不放在队列里面，而是取出进行保护，也就是进程全都是单独的且有条有紊的，你需要彻底厘清这些进程的顺序和独立情况
>
> 4、对于以上三点还有需要补充你所需要注意的地方就是我认为ghost预览是第一层，预览队列直接照抄ghost预览的内容，然后实际落地直接照搬预览队列的内容，你进行数据分离且正确处理即可，我认为这就是一步到位的事情，你觉得呢？但是对于第一点中提到的更新变为1+N-M的情况的前提是中心块先创建的前提，也就是1是必须先有的，减少的是边界的处理和适配，你当然需要重新回到1+8的原始设计部分去回顾，并彻底分析三个阶段的1+8处理方法的异同，我认为就应该从ghost就直接用最准确的1+8，后续复制，就会避免很多问题，这样垂直是统一的起码，不会出现其他情况
>
> 5、对于预览浇水不是让你一直更新，我前面的prompt绝对详细讲清楚了我要的浇水就是例如你鼠标放到耕地a时候预览是样式1然后不会再变，你此时只要鼠标不移出耕地a的中心块区域，也就是只要不移入其他单元格就不进行随机样式，你现在确实是点击后会与队列预览一致，但是你的ghost为什么要锁定？这是不对的吧，你现在是浇水动画开始的那一瞬间才会让ghost解除，这是不对的，耕地预览也是这个bug，再一个浇水也是需要遵守第四点的情况，ghost到队列预览再到落地，这个流程是我认为必须要遵守的

---

## 逐点分析

### 第一点：耕地 ghost 预览 8+1 逻辑全面 bug — 不应覆盖已有耕地的边界

**用户核心诉求**：ghost 预览（鼠标跟随层）显示的应该是"修改后的实际内容"，已经存在的耕地边界不需要重复显示预览。如果预览位置左边已有耕地，右边三个邻居位置已经是耕地了，那预览只需要处理 1+5（中心块 + 5个需要变化的边界），而不是完整的 1+8。

**代码事实剖析**：

当前 `FarmlandBorderManager.GetPreviewTiles()` 的逻辑：

```csharp
// 构造断言：假装 centerPos 已经被耕作
Func<Vector3Int, bool> predicate = (pos) =>
{
    if (pos == centerPos) return true;  // 预览位置假装已耕作
    return IsCenterBlock(layerIndex, pos);  // 其他位置用真实数据
};

// 1. 中心块：固定使用 centerTileUnfertilized
result[centerPos] = centerTileUnfertilized;

// 2. 遍历周围 8 格，全部计算边界 tile
for (int dx = -1; dx <= 1; dx++)
    for (int dy = -1; dy <= 1; dy++)
    {
        if (dx == 0 && dy == 0) continue;
        Vector3Int neighborPos = centerPos + new Vector3Int(dx, dy, 0);
        TileBase tile = CalculateBorderTileAt(layerIndex, neighborPos, predicate);
        result[neighborPos] = tile;  // ← 无论邻居是否已有耕地，都写入结果
    }
```

`GetPreviewTiles` 返回的 Dictionary 包含中心块 + 8个邻居位置的 tile。问题在于：**它不区分邻居位置是否已经有耕地**。如果邻居位置已经是耕地且边界 tile 已经正确，`CalculateBorderTileAt` 会返回一个与当前实际显示相同的 tile，然后 ghost 预览层会在该位置重复放置一个相同的 tile。

**我的判断**：

用户说得完全正确。当前的 ghost 预览确实存在"无差别覆盖"问题。`GetPreviewTiles` 的计算逻辑本身没错（它正确计算了"如果这里新增耕地后，周围边界应该长什么样"），但问题出在 **ghost 预览层不应该显示那些"与当前实际显示完全相同"的 tile**。

具体来说：
- `GetPreviewTiles` 返回 9 个位置的 tile
- 其中某些邻居位置已经有耕地，且边界 tile 在新增中心块后不会发生变化（比如邻居已经是完整的中心块，它的边界不受新增位置影响）
- 这些"不变"的位置不应该出现在 ghost 预览中

**但这里有一个微妙之处**：有些邻居位置虽然已经有耕地，但它的边界 tile 会因为新增中心块而发生变化（比如原来是"右边界"，新增后变成"中间"）。这些位置的 tile 确实需要在预览中显示。

所以正确的做法是：**对比 `GetPreviewTiles` 返回的 tile 与当前实际 Tilemap 上的 tile，只在 ghost 预览层显示那些"会发生变化"的位置**。这就是用户说的"1+N-M"逻辑。

**结论**：✅ 完全认可用户的分析。ghost 预览应该只显示"差异"，不重复显示已有内容。

---

### 第二点：耕地创建后只清理队列预览的中心块，边界残留

**用户核心诉求**：队列预览入队时创建了 1+8（中心块 + 8个边界 tile），但动画执行完毕后 `RemoveQueuePreview` 只清理了中心块，剩余 8 个边界 tile 残留在 queuePreviewTilemap 上。

**代码事实剖析**：

`RemoveQueuePreview` 的逻辑：
```csharp
// 检查是否是耕地队列（有 tileGroup）
if (tillQueueTileGroups.TryGetValue(cellPos, out var tilePositions))
{
    if (queuePreviewTilemap != null)
    {
        foreach (var pos in tilePositions)
        {
            queuePreviewTilemap.SetTile(pos, null);
        }
    }
    tillQueueTileGroups.Remove(cellPos);
}
```

这段代码看起来是正确的——它从 `tillQueueTileGroups` 获取关联的所有 tile 位置（包括边界），然后逐个清除。

但问题可能出在 `AddQueuePreview` 中 `tillQueueTileGroups` 的记录是否完整。让我再看：

```csharp
// AddQueuePreview Till 分支：
var previewTiles = FarmlandBorderManager.Instance.GetPreviewTiles(layerIndex, cellPos);
var tilePositions = new List<Vector3Int>();
foreach (var kvp in previewTiles)
{
    if (kvp.Value != null && queuePreviewTilemap != null)
    {
        queuePreviewTilemap.SetTile(kvp.Key, kvp.Value);
        queuePreviewTilemap.SetColor(kvp.Key, new Color(1f, 1f, 1f, queuePreviewAlpha));
        tilePositions.Add(kvp.Key);
    }
}
tillQueueTileGroups[cellPos] = tilePositions;
```

这里有一个关键条件：`if (kvp.Value != null)`。`GetPreviewTiles` 返回的 Dictionary 中，某些邻居位置的 tile 可能是 `null`（表示该位置不需要边界 tile）。这些 `null` 位置不会被加入 `tilePositions`，但 `SetTile(pos, null)` 实际上也不会在 Tilemap 上放置任何东西，所以这不是问题。

**但是**，`GetPreviewTiles` 的注释写的是"只记录有变化的位置（tile 可能为 null，表示清除）"。也就是说 `result[neighborPos] = tile` 中 tile 为 null 时，含义是"清除该位置的 tile"。如果 `AddQueuePreview` 跳过了 null tile，那么这些需要"清除"的位置就不会被记录到 `tilePositions` 中。

不过更关键的问题可能是：**`OnFarmActionAnimationComplete` 调用的是 `RemoveQueuePreview(_currentProcessingRequest.cellPos)`**，而 `_currentProcessingRequest.cellPos` 是中心块的 cellPos。`RemoveQueuePreview` 用这个 cellPos 去 `tillQueueTileGroups` 查找，如果 key 匹配就能找到完整的 tile 列表。

让我再仔细看一下调用链... `ProcessNextAction` 出队时设置 `_currentProcessingRequest = request`，然后 `OnFarmActionAnimationComplete` 用 `_currentProcessingRequest.cellPos` 调用 `RemoveQueuePreview`。这个 cellPos 就是入队时的中心块 cellPos，与 `tillQueueTileGroups` 的 key 一致。

**所以从代码逻辑上看，`RemoveQueuePreview` 应该能正确清理所有 1+8 的 tile**。

但用户说实际观察到边界残留，可能的原因：
1. `_currentProcessingRequest` 在某些路径下被重置为 default（比如 `ClearActionQueue` 中 `_currentProcessingRequest = default`），导致后续 `RemoveQueuePreview` 用错误的 cellPos 查找
2. 或者是第三点提到的 WASD 中断场景：`ClearActionQueue` 调用 `ClearAllQueuePreviews`，但 `ClearAllQueuePreviews` 的清理逻辑有问题

让我再看 `ClearAllQueuePreviews`：
```csharp
// 清空 queuePreviewTilemap
foreach (var pos in queuePreviewPositions)
{
    queuePreviewTilemap.SetTile(pos, null);
}
```

这里只遍历 `queuePreviewPositions`（HashSet），而 `queuePreviewPositions` 只记录了中心块的 cellPos（`queuePreviewPositions.Add(cellPos)` 在 `AddQueuePreview` 末尾）。**边界位置没有被加入 `queuePreviewPositions`！**

这就是 bug 所在：`ClearAllQueuePreviews` 用 `queuePreviewPositions` 遍历清除，但 `queuePreviewPositions` 只有中心块位置，边界位置只记录在 `tillQueueTileGroups` 中。虽然后面有 `tillQueueTileGroups.Clear()`，但那只是清空了追踪数据，没有清除 Tilemap 上的 tile。

**结论**：✅ 用户说得对。`ClearAllQueuePreviews` 确实存在边界残留 bug。`RemoveQueuePreview` 单个移除时逻辑正确（通过 `tillQueueTileGroups` 找到所有位置），但 `ClearAllQueuePreviews` 批量清除时只清了中心块。

---

### 第三点：WASD 中断时删除了正在执行的预览 — 耕地/浇水"凭空出现"

**用户核心诉求**：动画播放期间输入 WASD，当前正在执行位置的预览被清除了。耕地动作还没达到触发 tile 创建的进度（50%），预览就先消失了，导致耕地"凭空出现"。用户希望正在执行的预览被"取出保护"，不受队列清空影响。

**代码事实剖析**：

`HandleMovement` 中的 WASD 中断逻辑：
```csharp
if (hasWASD && hasActiveQueue)
{
    ClearActionQueue();           // ← 清空队列 + 清空所有队列预览
    CancelFarmingNavigation();
    FarmToolPreview.Instance?.UnlockPosition();  // ← 解锁 ghost 预览
    ToolActionLockManager.Instance?.ForceUnlock();
}
```

`ClearActionQueue` 内部调用 `ClearAllQueuePreviews()`，这会清除 queuePreviewTilemap 上的所有 tile。

同时 `UnlockPosition()` 解锁 ghost 预览，ghost 预览恢复鼠标跟随模式，之前锁定在执行位置的 ghost 预览也消失了。

**问题链条**：
1. 玩家点击位置 A → 入队 → `ProcessNextAction` 出队 → `LockPosition` 锁定 ghost 预览到 A → `ExecuteFarmAction` 开始动画
2. 动画播放中（进度 < 50%，tile 还没创建）
3. 玩家按 WASD → `ClearActionQueue()` 清空队列预览 + `UnlockPosition()` 解锁 ghost
4. 此时位置 A 的预览完全消失（ghost 解锁跟随鼠标，队列预览被清空）
5. 动画继续播放到 50% → tile 创建 → 耕地"凭空出现"

用户的方案是：**正在执行的操作应该有独立的"执行预览"，不属于队列预览，WASD 中断时只清空队列中未执行的预览，不清除正在执行的预览**。

**我的判断**：

✅ 完全认可。这是一个严重的体验 bug。正在执行的操作和队列中等待的操作是两个不同的生命周期阶段，它们的预览应该独立管理。

当前的问题是 `ProcessNextAction` 出队后，该操作的预览仍然留在 `queuePreviewTilemap` 上（直到 `OnFarmActionAnimationComplete` 才调用 `RemoveQueuePreview`）。WASD 中断时 `ClearAllQueuePreviews` 把它一起清了。

正确的做法：`ProcessNextAction` 出队时，应该把当前操作的预览从"队列预览"转移到"执行预览"（一个独立的保护区域），WASD 中断只清空队列预览，不动执行预览。执行预览在 tile 实际创建后（动画进度 >= 50%）或动画完成后才清除。

**结论**：✅ 完全认可。需要引入"执行预览"概念，与队列预览分离。

---

### 第四点：三层数据流 — ghost → 队列预览 → 实际落地

**用户核心诉求**：
1. ghost 预览是第一层（鼠标跟随，最准确的 1+8）
2. 队列预览直接照抄 ghost 预览的内容
3. 实际落地直接照搬队列预览的内容
4. 三层垂直统一，数据分离但内容一致

用户还强调：从 ghost 就应该用最准确的 1+8，后续复制就不会出问题。

**代码事实剖析**：

当前三层的数据来源：

| 层级 | 数据来源 | 问题 |
|------|---------|------|
| ghost 预览 | `UpdateHoePreview` → `GetPreviewTiles` → ghostTilemap | 每帧重新计算，但不过滤已有耕地（第一点的 bug） |
| 队列预览 | `AddQueuePreview` → `GetPreviewTiles` → queuePreviewTilemap | 独立调用 `GetPreviewTiles`，与 ghost 是两次独立计算 |
| 实际落地 | `ExecuteTillSoil` → `FarmTileManager.TillAt` → `UpdateBorderAt` | 又是独立的边界计算 |

三层各自独立计算，没有数据传递关系。这意味着：
- ghost 和队列预览可能因为时序差异（比如入队时和显示时的周围耕地状态不同）而显示不一致
- 队列预览和实际落地也可能不一致

**我的判断**：

✅ 用户的"垂直统一"思路是正确的。理想的数据流应该是：

```
ghost 计算 1+8（最准确，考虑已有耕地的差异过滤）
    ↓ 入队时复制 ghost 的计算结果
队列预览（照搬 ghost 的 tile 数据）
    ↓ 执行时复制队列预览的数据
实际落地（照搬队列预览的 tile 数据）
```

但这里有一个实际问题需要考虑：**队列中多个操作之间的边界叠加**。比如玩家连续点击 A 和 B 两个相邻位置，B 入队时 A 还没执行，但 B 的边界计算应该考虑 A 的存在。当前 `GetPreviewTiles` 的 predicate 只假装当前位置已耕作，不考虑队列中其他位置。

不过这个问题在 designV3 中已经讨论过（2.4 边界 tile 叠加问题），结论是"接受简单实现，每次入队独立计算"。用户现在的要求是"ghost 就用最准确的 1+8"，这个"最准确"指的是考虑已有耕地的差异过滤，而不是考虑队列中其他位置。

**结论**：✅ 认可垂直统一的数据流设计。ghost 层计算最准确的差异化 1+8，入队时复制 ghost 数据到队列预览，执行时复制队列预览数据到实际落地。

**但有一个补充建议**：实际落地阶段不应该"照搬队列预览的 tile 数据"，因为实际落地需要调用 `FarmTileManager.TillAt` 来更新数据层（`FarmTileData.isTilled = true`），然后 `UpdateBorderAt` 会根据最新的数据层重新计算边界。如果照搬队列预览的 tile 数据，可能会跳过数据层更新。

所以更准确的说法是：
- ghost → 队列预览：tile 数据复制 ✅
- 队列预览 → 实际落地：**数据层更新 + 视觉层由数据层驱动**（不是直接复制 tile）

实际落地的视觉结果应该与队列预览一致（因为数据层更新后的边界计算结果相同），但驱动方式不同。

---

### 第五点：浇水 ghost 预览不应每帧随机 + ghost 锁定时机错误

**用户核心诉求**：
1. 浇水 ghost 预览：鼠标放到耕地 A 时随机一个水渍样式，只要鼠标不移出 A 的中心块区域就不重新随机
2. ghost 预览不应该在点击后被锁定（`LockPosition`），当前是浇水/耕地动画开始的瞬间才解除锁定，这是错误的
3. 浇水也要遵守第四点的三层数据流：ghost → 队列预览 → 落地

**代码事实剖析**：

当前 `UpdateWateringPreview` 的逻辑：
```csharp
// 每次调用都重新获取随机水渍 tile
if (isValid)
{
    var puddleTile = FarmVisualManager.Instance?.GetRandomPuddleTile();
    if (puddleTile != null)
    {
        ghostTilemap.SetTile(cellPos, puddleTile);
        currentPreviewPositions.Add(cellPos);
    }
}
```

`UpdateWateringPreview` 在 `UpdatePreviews` → `UpdateFarmToolPreview` 中每帧被调用。每帧都调用 `GetRandomPuddleTile()`，意味着每帧都可能随机到不同的水渍样式。

但实际上，由于 `_isLocked` 机制的存在：
- 点击后 `LockPosition` 被调用，`_isLocked = true`
- 后续帧 `UpdateWateringPreview` 执行到 `if (_isLocked) return;` 就返回了
- 所以点击后 ghost 预览确实不会再更新

**问题 1：每帧随机**

在未锁定状态下（鼠标跟随），每帧都会调用 `GetRandomPuddleTile()`。如果鼠标停在同一个格子上，每帧都会重新随机。这确实是 bug——用户期望的是"进入格子时随机一次，不移出就不变"。

当前代码没有"上一帧的 cellPos"缓存来判断是否移入了新格子。`lastCellPosition` 虽然存在，但它在方法末尾才更新，且没有用于"是否需要重新随机"的判断。

**问题 2：ghost 锁定时机**

当前流程：
1. 玩家点击 → `TryEnqueueFarmTool` 入队
2. `EnqueueAction` → `ProcessNextAction` → `LockPosition`（锁定 ghost 到目标位置）
3. `ExecuteFarmAction` → 开始动画
4. 动画完成 → `OnFarmActionAnimationComplete` → `ProcessNextAction`
5. 如果队列空 → `UnlockPosition`（解锁 ghost）

用户认为 ghost 不应该被锁定。ghost 应该始终跟随鼠标，点击后的"锁定显示"应该由队列预览层承担。

这与第四点的三层数据流一致：
- ghost 层：始终跟随鼠标，实时显示"如果在这里操作会怎样"
- 队列预览层：点击后锁定显示，表示"这些操作已经排队等待执行"
- 执行预览层（第三点新增）：正在执行的操作的预览，受保护不被 WASD 清除

**我的判断**：

✅ 用户说得对。当前的 `LockPosition` 机制把 ghost 预览和队列预览混为一谈了。ghost 预览应该始终自由跟随鼠标，锁定显示的职责应该交给队列预览层。

对于浇水每帧随机的问题，解决方案是：在 `UpdateWateringPreview` 中缓存 `lastCellPosition`，只有当 cellPos 变化时才重新随机水渍样式。

**但这里有一个需要讨论的点**：如果 ghost 不再锁定，那么 `ProcessNextAction` 中的 `LockPosition` 调用需要移除。但 `LockPosition` 还有另一个作用——它在锁定时执行了一次完整的 GhostTilemap 渲染（补丁002 P3 修复）。如果移除锁定，这个渲染逻辑需要迁移到队列预览层。

**结论**：✅ 认可。ghost 预览不应被锁定，浇水不应每帧随机。需要重构锁定机制，将"锁定显示"职责从 ghost 层转移到队列预览层。

---

## 综合分析：三层预览架构重构方案

基于以上五点分析，核心问题可以归纳为一个架构缺陷：**当前系统没有清晰的三层预览分离**。

### 目标架构

```
┌─────────────────────────────────────────────────────┐
│ 第一层：Ghost 预览（鼠标跟随层）                       │
│ - 始终跟随鼠标，永不锁定                              │
│ - 显示"如果在这里操作会怎样"的差异化预览               │
│ - 耕地：只显示与当前实际不同的 tile（1+N-M）           │
│ - 浇水：进入新格子时随机一次样式，不移出不变            │
│ - 使用 shader 叠加色（绿/红）                         │
│ - Tilemap: ghostTilemap                              │
├─────────────────────────────────────────────────────┤
│ 第二层：队列预览（已入队等待执行）                      │
│ - 点击入队时，复制 ghost 的计算结果                    │
│ - 静态显示，不随鼠标移动                              │
│ - 无 shader 叠加色，使用原始 tile + 半透明             │
│ - WASD 中断时清空                                    │
│ - Tilemap: queuePreviewTilemap                       │
├─────────────────────────────────────────────────────┤
│ 第三层：执行预览（正在执行的操作）                      │
│ - ProcessNextAction 出队时，从队列预览转移到执行预览    │
│ - 受保护，WASD 中断不清除                             │
│ - 动画进度 >= 50% 后（tile 实际创建后）清除            │
│ - 或动画完成后清除                                    │
│ - 可复用 queuePreviewTilemap 或独立 Tilemap           │
└─────────────────────────────────────────────────────┘
```

### 需要修改的核心逻辑

| 编号 | 修改点 | 涉及文件 |
|------|--------|---------|
| R1 | ghost 预览差异化过滤（只显示变化的 tile） | FarmToolPreview.cs |
| R2 | ghost 预览移除 LockPosition 机制 | FarmToolPreview.cs, GameInputManager.cs |
| R3 | 浇水 ghost 预览：进入新格子才随机 | FarmToolPreview.cs |
| R4 | 队列预览入队时复制 ghost 数据（而非独立计算） | FarmToolPreview.cs |
| R5 | ClearAllQueuePreviews 修复边界残留 | FarmToolPreview.cs |
| R6 | 引入执行预览层，ProcessNextAction 出队时转移 | FarmToolPreview.cs, GameInputManager.cs |
| R7 | WASD 中断只清空队列预览，不动执行预览 | GameInputManager.cs |
| R8 | 执行预览在 tile 创建后或动画完成后清除 | GameInputManager.cs |

### 对用户方案的异议（仅一处）

用户第四点说"实际落地直接照搬预览队列的内容"。我认为实际落地不应该直接复制 tile 数据，而应该通过 `FarmTileManager.TillAt` 更新数据层，让数据层驱动视觉更新。原因：
1. 数据层（`FarmTileData.isTilled`）必须更新，否则后续的浇水、种植等操作无法正确判断
2. `UpdateBorderAt` 会根据最新数据层重新计算边界，结果应该与预览一致
3. 如果直接复制 tile 跳过数据层，会导致数据层和视觉层不同步

视觉结果应该一致（因为计算逻辑相同），但驱动方式必须是"数据层更新 → 视觉层跟随"，不能反过来。

---

## 修改文件清单

- `补丁004全面分析报告.md` - 新建，本文件
