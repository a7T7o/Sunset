# 补丁004V6 全面审查报告

> 创建时间：2026-02-22（会话2续23）
> 触发原因：锐评005 纠正 + 用户要求彻底全面回顾 + 生成最终审查报告
> 基础文档：V5.2 全面审查报告 + 锐评004审视报告 + 锐评005 + 锐评002-003审核报告 + V5 全面审查报告 + V4 全面审查报告 + 所有历史版本
> 核心转变：模块Q从"立即中断+手动清理"回归"绝对锁定，拒绝强行中断"

---

## 零、版本演进总览

| 版本 | 时间 | 核心内容 | 状态 |
|------|------|---------|------|
| V1 | 续1 | 三层预览架构初版（6 US、7 模块 A-G） | ✅ 已实施 |
| V2 | 续3 | 按修改目标重组（22 条 CP） | ✅ 已实施 |
| V3 | 续8 | 验收后修复（模块 H/I/J/K） | ✅ 已实施 |
| V3代码 | 续10 | 三层增量 + b 层 1+8 | ✅ 已实施 |
| V4 | 续11-12 | RemoveExecutingPreview 误删队列预览修复 | ✅ 已实施 |
| V5 | 续14 | a 层 canTill 纳入 b 层 + 统一颜色控制 | 📋 报告完成，未实施 |
| V5.1 | 续15-17 | 锐评001 审视（保留 Shader）+ 锐评002-003 审核（枯萎作物统一拦截） | 📋 方案敲定，未实施 |
| V5.2 | 续19 | 用户5点新需求（极限操作/种子放置化/锄头农作物/浇水随机/浇水b层） | 📋 报告完成，未实施 |
| 锐评004审视 | 续22 | 4个致命雷区核查 + 模块Q/R/S/T/V 修正方案 | 📋 报告完成 |
| **V6（本报告）** | **续23** | **锐评005 纠正 + 全面回顾 + 最终定论** | **📋 待审核** |

---

## 一、锐评005 审核

### 1.1 锐评005 核心转变

Gemini 在被用户训导后，彻底接受了"农田动作绝对锁定，不可打断"的设计理念，推翻了锐评004中"WASD 必须允许玩家立即移动"的建议。

### 1.2 事实核查

| 锐评005 声明 | 代码事实 | 结论 |
|-------------|---------|------|
| Bug1 模块Q：锐评004审视报告错误采纳了"立即中断+手动清理" | ✅ 审视报告第4.1节确实采纳了此方案 | ✅ 正确 |
| 农田系统不是动作游戏，不存在打断动作躲避怪物的需求 | ✅ 项目是农场游戏，无战斗系统 | ✅ 正确 |
| ForceUnlock 在动画中途会制造"状态泄漏"隐患 | ✅ 代码验证：CancelFarmingNavigation 无条件清除 _isExecutingFarming → 回调链断裂 → isPerformingAction 永久 true | ✅ 正确 |
| WASD 只能清空等待队列，不能碰当前执行的流程 | 这是设计原则，需要代码实现 | ✅ 方向正确 |
| Bug2/3/4/V 的审视报告方案"非常透彻精准" | 需要逐一确认 | 见下文 |

### 1.3 采纳决策

| 项目 | 采纳 | 说明 |
|------|------|------|
| 模块Q 回归"绝对锁定" | ✅ 完全采纳 | 推翻锐评004审视报告的"立即中断"方案 |
| Bug2/3/4/V 方案认可 | ✅ 采纳 | 审视报告中的方案保持不变 |
| 直接输出 V6 design+tasks | ❌ 不采纳 | 用户认为激进，先出审查报告 |

### 1.4 路径判断

🟢 路径 A — 锐评005 的核心纠正完全正确，无异议。模块Q方案需要重写，其余模块保持审视报告方案。


---

## 二、模块Q — Bug1 极限操作（🔴 最高优先级）— 方案重写

### 2.1 问题回顾

玩家在左键耕地动画开始瞬间按 WASD → 动画播放但耕地不出现、预览不消失。

### 2.2 根因链（V5.2 已确认，代码事实不变）

```
帧N：左键 → ExecuteFarmAction → _isExecutingFarming = true → RequestAction(Crush) → IsLocked = true
帧N+1：WASD → ClearActionQueue（模块H保护_pendingTileUpdate）
       → CancelFarmingNavigation → _isExecutingFarming = false（🔴 无条件清除）
       → ForceUnlock → 玩家移动 → Crush 动画中断 → OnActionComplete 永不触发
       → isPerformingAction 永久 true + 执行预览永不清除
```

### 2.3 方案演进历史

| 版本 | 方案 | 问题 |
|------|------|------|
| V5.2 | 等动画播完（wasExecuting 检查，跳过 CancelFarmingNavigation 和 ForceUnlock） | 锐评004 指出"锁死玩家" |
| 锐评004审视 | 立即中断+手动清理（RemoveExecutingPreview + 7项状态重置 + ForceUnlock） | 锐评005 指出"状态泄漏灾难" |
| **V6（最终）** | **绝对锁定：_isExecutingFarming=true 时 WASD 只清空队列，不取消执行，不解锁移动** | **零风险** |

### 2.4 V6 最终方案 — 绝对锁定

核心原则：**`_isExecutingFarming = true` 时，天王老子来了也不能打断当前动作。**

**Q1：修改 HandleMovement 中 WASD 中断分支**

当前代码（第454-458行）：
```csharp
if (hasWASD && hasActiveQueue)
{
    ClearActionQueue();
    CancelFarmingNavigation();
    ToolActionLockManager.Instance?.ForceUnlock();
}
```

V6 方案：
```csharp
if (hasWASD && hasActiveQueue)
{
    // 🔴 V6 模块Q（CP-Q1）：绝对锁定原则
    bool wasExecuting = _isExecutingFarming;
    ClearActionQueue();  // 清空等待队列（模块H已保护执行状态）
    
    if (!wasExecuting)
    {
        // 没有动画在执行（导航途中或空闲）→ 正常取消一切
        CancelFarmingNavigation();
        ToolActionLockManager.Instance?.ForceUnlock();
    }
    // else: 动画执行中 → 只清空队列，不取消导航/不解锁移动
    // 动画完成后由 OnFarmActionAnimationComplete 回调链正常清理一切
}
```

**Q2：CancelFarmingNavigation 增加执行保护（防御性编程）**

即使 Q1 已经在上层拦截，CancelFarmingNavigation 内部也应该有自我保护：

```csharp
private void CancelFarmingNavigation()
{
    if (_farmNavState == FarmNavState.Idle || _farmNavState == FarmNavState.Preview) return;
    
    // 停止协程
    if (_farmingNavigationCoroutine != null)
    {
        StopCoroutine(_farmingNavigationCoroutine);
        _farmingNavigationCoroutine = null;
    }
    
    // 🔴 V6 模块Q（CP-Q3）：执行中不清除标志，不解锁
    if (_isExecutingFarming)
    {
        // 动画正在执行，只清理导航相关状态，保留执行状态
        _farmNavState = FarmNavState.Preview;
        _farmNavigationAction = null;
        _cachedSeedData = null;
        ClearSnapshot();
        return;  // 不清除 _isExecutingFarming，不 ForceUnlock
    }
    
    // 原有逻辑（非执行状态）
    _farmNavState = IsHoldingFarmTool() ? FarmNavState.Preview : FarmNavState.Idle;
    _farmNavigationAction = null;
    _cachedSeedData = null;
    _isExecutingFarming = false;
    ClearSnapshot();
    
    var lockMgr = ToolActionLockManager.Instance;
    if (lockMgr != null && lockMgr.IsLocked)
        lockMgr.ForceUnlock();
}
```

### 2.5 为什么"绝对锁定"是最优解

1. **零状态泄漏风险**：动画完成后 `OnFarmActionAnimationComplete` 正常触发，回调链完整清理所有状态（_pendingTileUpdate、_isExecutingFarming、RemoveExecutingPreview、ProcessNextAction）
2. **代码改动极小**：只需在 HandleMovement 加一个 `wasExecuting` 检查 + CancelFarmingNavigation 加一个执行保护
3. **玩家体验无感知**：耕地动画只有几百毫秒，玩家几乎感觉不到硬直
4. **与项目设计哲学一致**：GameInputManager 的设计就是"动画触发就不取消"，之前大量 bug 都是中途打断导致的

### 2.6 正确性属性

| 编号 | 属性 | 验证方式 |
|------|------|---------|
| CP-Q1 | `_isExecutingFarming = true` 时，WASD 不调用 `CancelFarmingNavigation` | 代码审查 |
| CP-Q2 | `_isExecutingFarming = true` 时，WASD 不调用 `ForceUnlock` | 代码审查 |
| CP-Q3 | `CancelFarmingNavigation` 中 `_isExecutingFarming = true` 时保持执行状态不变 | 代码审查 |
| CP-Q4 | 极限操作后动画正常完成 → 耕地正常创建 → 执行预览正常清除 | 游戏内验收 |
| CP-Q5 | 极限操作后 `isPerformingAction` 最终恢复为 false | 游戏内验收 |
| CP-Q6 | WASD 在动画执行中按下 → 队列被清空但动画继续播放 | 游戏内验收 |


---

## 三、模块S — Bug3 锄头对农作物的处理（🔴 高优先级）— 方案重写

### 3.1 问题回顾

用户明确修正：
- 是"锄头"不是"镐子"
- 锄头对**所有阶段**的农作物都能除去（不只是 `WitheredImmature`）
- 有农作物的耕地：**不显示任何预览内容**（不显示红框、不显示红色 shader、什么都不显示），只允许除去农作物
- 无农作物的已有耕地：显示**放置系统的红方框**（直接抄 `PlacementGridCell`）
- 红色 cursorRenderer 框不需要，也不需要任何替代

### 3.2 当前代码事实

**UpdateHoePreview 中的 canClearWithered**（第433-438行）：
```csharp
bool canClearWithered = false;
if (!canTill && FarmTileManager.Instance != null)
{
    var tileData = FarmTileManager.Instance.GetTileData(layerIndex, cellPos);
    if (tileData?.cropController != null && 
        tileData.cropController.GetState() == CropState.WitheredImmature)
        canClearWithered = true;
}
```
- 只检测 `WitheredImmature`，不检测 Growing/Mature/WitheredMature

**ExecuteTillSoil**（第1317行）：同样只处理 `WitheredImmature`

**CropController**：有 `DestroyCrop()` 私有方法，只被 `ClearWitheredImmature()` 调用，没有公开的"通用清除"方法

### 3.3 V6 最终方案

**S1：UpdateHoePreview 新增 `hasCrop` 判断**

在 `canClearWithered` 之后、`isValid` 之前新增：
```csharp
// 🔴 V6 模块S（CP-S1）：检测任何状态的农作物
bool hasCrop = false;
if (!canTill && FarmTileManager.Instance != null)
{
    var tileData = FarmTileManager.Instance.GetTileData(layerIndex, cellPos);
    if (tileData?.cropController != null)
        hasCrop = true;
}
```

注意：`hasCrop` 包含了 `canClearWithered` 的情况（WitheredImmature 也是有 cropController 的），所以 `canClearWithered` 可以被 `hasCrop` 替代。但为了向后兼容和语义清晰，保留 `canClearWithered` 作为子集判断。

**S2：isValid 判断扩展**

```csharp
// 原来：bool isValid = !hasObstacle && (canTill || canClearWithered);
// V6：
bool isValid = !hasObstacle && (canTill || hasCrop);
```

`hasCrop = true` 时 `isValid = true`，允许执行。

**S3：UpdateHoePreview 中 hasCrop 的视觉处理**

```csharp
if (canTill && FarmlandBorderManager.Instance != null)
{
    // ... 现有的 1+8 预览逻辑 ...
}
else if (hasCrop)
{
    // 🔴 V6 模块S（CP-S2）：有农作物的耕地 — 不显示任何预览
    _currentGhostTileData?.Clear();
    if (cursorRenderer != null) cursorRenderer.enabled = false;
    // 不铺 1+8、不显示 cursorRenderer、不显示 shader 染色
    // ghostTilemap 已被 ClearGhostTilemap 清空，保持空白
}
else
{
    // 🔴 V6 模块S（CP-S3）：无农作物的已有耕地 — 显示放置系统红方框
    _currentGhostTileData?.Clear();
    // 使用放置系统风格的红方框（抄 PlacementGridCell.CreateGridSprite）
    if (cursorRenderer != null)
    {
        cursorRenderer.enabled = true;
        UpdateCursor(layerIndex, cellPos);
        // cursorRenderer 颜色设为红色（invalidColor）
    }
}
```

**S4：新增 `FarmActionType.RemoveCrop` 枚举值**

在 `FarmActionType` 枚举中新增 `RemoveCrop`。

**S5：ExecuteFarmAction 新增 RemoveCrop 分支**

```csharp
case FarmActionType.RemoveCrop:
    FaceTarget(request.worldPos);
    playerInteraction?.RequestAction(PlayerAnimController.AnimState.Crush);
    _pendingTileUpdate = request;
    _tileUpdateTriggered = false;
    break;
```

**S6：新增 ExecuteRemoveCrop 方法**

```csharp
private bool ExecuteRemoveCrop(int layerIndex, Vector3Int cellPos)
{
    var tileData = FarmTileManager.Instance?.GetTileData(layerIndex, cellPos);
    if (tileData?.cropController != null)
    {
        tileData.cropController.RemoveCrop();  // 新增公开方法
        return true;
    }
    return false;
}
```

**S7：CropController 新增 `public void RemoveCrop()` 方法**

```csharp
public void RemoveCrop()
{
    DestroyCrop();  // 内部调用已有的私有方法
}
```

**S8：_pendingTileUpdate 监听中新增 RemoveCrop 分支**

在 Update 的 `_pendingTileUpdate` 监听逻辑中，RemoveCrop 类型也需要在动画中期触发执行。

**S9：OnFarmActionAnimationComplete 中新增 RemoveCrop 分支**

兜底逻辑中也需要处理 RemoveCrop 类型。

**S10：TryEnqueueFarmTool 中的入队逻辑**

当 `hasCrop = true` 且 `canTill = false` 时，入队的 `FarmActionType` 应为 `RemoveCrop` 而非 `Till`。需要在 `TryEnqueueFarmTool` 中根据 `FarmToolPreview` 的状态判断入队类型。

### 3.4 关于"无农作物的已有耕地"的红方框

用户要求"显示放置系统的那个红方框，你直接抄来即可"。

当前 `cursorRenderer` 已经是一个 `SpriteRenderer`，显示程序化生成的方框 Sprite。但样式可能与放置系统不一致。

放置系统的方框（`PlacementGridCell.CreateGridSprite`）：
- 32x32 像素
- 2px 边框 + 半透明内部填充
- `invalidColor = new Color(1f, 0f, 0f, 0.4f)`

需要确认 `cursorRenderer` 的 Sprite 是否与放置系统一致。如果不一致，需要替换为相同的程序化 Sprite。

### 3.5 正确性属性

| 编号 | 属性 | 验证方式 |
|------|------|---------|
| CP-S1 | 有农作物的耕地上锄头 `isValid = true`（允许执行） | 代码审查 |
| CP-S2 | 有农作物的耕地上锄头不显示任何预览（ghostTilemap 空、cursorRenderer disabled） | 游戏内验收 |
| CP-S3 | 无农作物的已有耕地上锄头显示放置系统红方框 | 游戏内验收 |
| CP-S4 | 锄头点击有农作物的耕地 → 清除农作物，耕地保留 | 游戏内验收 |
| CP-S5 | 所有作物状态（Growing/Mature/WitheredImmature/WitheredMature）都可被锄头清除 | 游戏内验收 |
| CP-S6 | 清除农作物后耕地数据保持不变（isTilled 仍为 true） | 游戏内验收 |


---

## 四、模块T — Bug4 浇水随机逻辑（🟡 中等优先级）— 方案重写

### 4.1 问题回顾

用户明确要求的浇水随机行为：
1. 切换到水壶时：随机一个默认样式
2. 鼠标在耕地间移动：不切换样式
3. 执行浇水 + 鼠标移出当前格子：触发随机 → 锁定新样式
4. 回到默认状态，移动鼠标不改变

### 4.2 当前代码事实

`UpdateWateringPreview` 第637行：
```csharp
if (cellPos != _lastWateringCellPos)
{
    _cachedPuddleVariant = Random.Range(0, count);
    _lastWateringCellPos = cellPos;
}
```
当前行为：**每进入新格子就随机**。这与用户要求不同——用户要求"只有执行浇水后移出才随机"。

### 4.3 权衡分析：Awake vs 切换时随机

| 方案 | 优点 | 缺点 |
|------|------|------|
| Awake 随机 | 简单 | Awake 只执行一次，切换到其他工具再切回水壶时不会重新随机 |
| 切换时随机 | 每次拿起水壶都有新样式 | 需要检测"刚切换到水壶" |

推荐：**切换时随机**。检测方式：`UpdateWateringPreview` 被调用时，如果上一帧是 `isHoeMode = true`（或 `isSeedMode = true`），说明刚从其他工具切换过来。或者更简单：新增 `_isWateringModeActive` 标志，首次进入浇水模式时随机。

### 4.4 V6 最终方案

**T1：新增字段**

```csharp
private bool _hasWateredSinceSwitch = false;  // 本次持有水壶期间是否执行过浇水
private Vector3Int _wateredCellPos;            // 最近一次浇水的格子位置
private bool _wateringModeInitialized = false; // 浇水模式是否已初始化（用于检测切换）
```

**T2：UpdateWateringPreview 开头 — 切换检测 + 默认随机**

```csharp
// 🔴 V6 模块T（CP-T1）：检测切换到水壶，随机默认样式
if (!_wateringModeInitialized)
{
    _wateringModeInitialized = true;
    _hasWateredSinceSwitch = false;
    var puddleTiles = FarmVisualManager.Instance?.GetPuddleTiles();
    int count = puddleTiles != null ? puddleTiles.Length : 3;
    _cachedPuddleVariant = Random.Range(0, count);
}
```

**T3：Hide() 或切换到其他工具时重置**

```csharp
// 在 UpdateHoePreview / UpdateSeedPreview 开头：
_wateringModeInitialized = false;
```

**T4：移除"进入新格子就随机"的逻辑**

删除当前的 `if (cellPos != _lastWateringCellPos)` 随机逻辑。鼠标移动时样式固定不变。

**T5：浇水执行后设置标志**

在 `ExecuteWaterTile` 或 `OnFarmActionAnimationComplete`（Water 分支）中：
```csharp
_hasWateredSinceSwitch = true;
_wateredCellPos = request.cellPos;
```

**T6：移出已浇水格子时触发随机**

在 `UpdateWateringPreview` 中：
```csharp
// 🔴 V6 模块T（CP-T4）：浇水后移出才随机
if (_hasWateredSinceSwitch && cellPos != _wateredCellPos)
{
    var puddleTiles = FarmVisualManager.Instance?.GetPuddleTiles();
    int count = puddleTiles != null ? puddleTiles.Length : 3;
    _cachedPuddleVariant = Random.Range(0, count);
    _hasWateredSinceSwitch = false;  // 重置，等待下一次浇水
}
```

### 4.5 三层统一

- ghost（a 层）：使用 `_cachedPuddleVariant` ✅
- 队列（b 层）：入队时从 `CurrentPuddleVariant` 获取 ✅（现有逻辑不变）
- 执行（c 层）：`ExecuteWaterTile` 使用 `request.puddleVariant` ✅（现有逻辑不变）

### 4.6 正确性属性

| 编号 | 属性 | 验证方式 |
|------|------|---------|
| CP-T1 | 切换到水壶时随机一次默认样式 | 游戏内验收 |
| CP-T2 | 鼠标在耕地间移动时浇水预览样式不变 | 游戏内验收 |
| CP-T3 | 执行浇水后鼠标仍在同一格子 → 样式不变 | 游戏内验收 |
| CP-T4 | 执行浇水后鼠标移出该格子 → 触发随机 → 锁定新样式 | 游戏内验收 |
| CP-T5 | ghost/队列/执行三层使用相同的 puddleVariant | 代码审查 |


---

## 五、模块V — Ghost 增量差集 c 层附近 bug（🔴 高优先级）— 新增

### 5.1 问题回顾

用户发现的场景：
- a=(-1,0) 空地，M=(0,0) 空地，b=(1,0) 耕地列
- b 列上下都有队列预览（b 层）
- ghost 在 a 处时，M 处的边界显示 UDL，但应该只显示 L
- 因为 M 上方 (0,1) 的队列预览已经贡献了 U 边界在 M，M 下方 (0,-1) 的队列预览已经贡献了 D 边界在 M
- 只在 c 层（实际耕地）附近出现

### 5.2 代码事实

`UpdateHoePreview` 增量差集逻辑（第497-530行）：
```csharp
// 先查 c 层
if (kvp.Key == cellPos)
    actualTile = actualCenterTilemap?.GetTile(kvp.Key);
else
    actualTile = actualBorderTilemap?.GetTile(kvp.Key);

// c 层没有再查 b 层
if (actualTile == null && queuePreviewTilemap != null)
    actualTile = queuePreviewTilemap.GetTile(kvp.Key);
```

### 5.3 根因分析

问题在于：**当 c 层和 b 层在同一位置都有 tile 时，代码只取 c 层的 tile 做对比，忽略了 b 层的额外方向贡献。**

具体推演（用户描述的场景）：
1. b=(1,0) 是实际耕地 → c 层 `farmlandBorderTilemap` 在 M=(0,0) 处有 `B_R`（因为 b 在 M 的右边）
2. b 列上下的队列预览在 `queuePreviewTilemap` 的 M 处也放了 tile（包含 U 和 D 方向）
3. ghost 在 a 处时，`GetPreviewTiles(a, queuePreviewPositions)` 计算 M 处的预览 tile 为 `B_UDL`
4. 增量差集对比：`actualTile = actualBorderTilemap.GetTile(M)` → 得到 c 层的 `B_R`
5. 因为 c 层有 tile（`B_R` ≠ null），**不查 b 层**
6. 差集 = `{U,D,L}` - `{R}` = `{U,D,L}` → 显示 `B_UDL` ❌

正确行为：
- c 层在 M 处有 `B_R`（方向 {R}）
- b 层在 M 处有 tile（方向包含 {U, D}）
- 合并 c+b 的方向 = `{R, U, D}`
- 差集 = `{U,D,L}` - `{R,U,D}` = `{L}` → 应该只显示 `B_L` ✅

### 5.4 V6 最终方案

**V1：增量差集对比时，合并 c+b 两层的方向后再做差集**

修改 `UpdateHoePreview` 中的增量差集逻辑：

```csharp
// 🔴 V6 模块V：合并 c+b 两层方向后再做差集
else if (borderManager.IsBorderTile(actualTile) && borderManager.IsBorderTile(kvp.Value))
{
    // 获取 c 层方向
    var actualDirs = borderManager.ParseDirections(actualTile);
    
    // 🔴 V6（CP-V1）：额外获取 b 层方向并合并
    bool mergedU = actualDirs.hasU;
    bool mergedD = actualDirs.hasD;
    bool mergedL = actualDirs.hasL;
    bool mergedR = actualDirs.hasR;
    
    if (queuePreviewTilemap != null)
    {
        var bLayerTile = queuePreviewTilemap.GetTile(kvp.Key);
        if (bLayerTile != null && borderManager.IsBorderTile(bLayerTile))
        {
            var bDirs = borderManager.ParseDirections(bLayerTile);
            mergedU = mergedU || bDirs.hasU;
            mergedD = mergedD || bDirs.hasD;
            mergedL = mergedL || bDirs.hasL;
            mergedR = mergedR || bDirs.hasR;
        }
    }
    
    // 用合并后的方向做差集
    var previewDirs = borderManager.ParseDirections(kvp.Value);
    bool deltaU = previewDirs.hasU && !mergedU;
    bool deltaD = previewDirs.hasD && !mergedD;
    bool deltaL = previewDirs.hasL && !mergedL;
    bool deltaR = previewDirs.hasR && !mergedR;
    
    if (!deltaU && !deltaD && !deltaL && !deltaR) continue;
    
    tileToDisplay = borderManager.SelectBorderTile(deltaU, deltaD, deltaL, deltaR);
    if (tileToDisplay == null) continue;
}
```

**V2：actualTile == null 但 b 层有 tile 的情况也需要处理**

当前逻辑：`actualTile == null` 时查 b 层，如果 b 层有 tile 则 `actualTile = bLayerTile`。这部分逻辑是正确的——如果 c 层没有 tile，b 层的 tile 就是唯一的"已有"参考。

但如果 c 层有 tile 且 b 层也有 tile（V1 的场景），当前逻辑只看 c 层。V1 的修复解决了这个问题。

**V3：非边界 tile 的情况**

如果 c 层有 tile 但不是边界 tile（比如是阴影 tile），而 b 层有边界 tile，当前逻辑走 `IsShadowTile` 分支直接显示预览 tile。这种情况下 b 层的方向贡献也被忽略了。

但实际上阴影 tile 不包含方向信息，b 层的边界 tile 才是有方向的。这种情况比较罕见（c 层有阴影 tile 说明该位置是耕地的阴影区域，b 层在同一位置有边界 tile 说明有队列预览的边界延伸到此处），需要进一步分析是否会出现。

暂定：V1 的修复覆盖了主要场景（c 层边界 + b 层边界的方向合并）。阴影 tile 场景作为已知限制，后续如果出现再处理。

### 5.5 正确性属性

| 编号 | 属性 | 验证方式 |
|------|------|---------|
| CP-V1 | 增量差集对比时，c 层和 b 层的方向取并集后再做差集 | 代码审查 |
| CP-V2 | 用户描述的场景：M 处 ghost 只显示 `B_L`（不显示 UDL） | 游戏内验收 |
| CP-V3 | c 层无 tile + b 层有 tile 时，增量对比使用 b 层 tile（现有逻辑不变） | 代码审查 |


---

## 六、模块R — Bug2 种子放置化（🔴 高优先级）— 待定

### 6.1 问题回顾

用户明确要求：种子彻底从农田交互队列中剥离，改为和树苗一样的放置物品处理，导航是必要的。

### 6.2 方案演进

| 版本 | 方案 | 问题 |
|------|------|------|
| V5.2 | HandleUseCurrentTool 中直接调 ExecutePlantSeed（无队列无动画无导航） | 锐评004 指出"伪放置系统"，用户确认需要导航 |
| 锐评004审视 | 走 PlacementManager 路径，需单独详细设计 | 方向正确，但实施复杂度高 |
| 锐评005 | 认可审视报告方案 | — |

### 6.3 V6 定论

种子放置化是**架构级调整**，涉及：
- SeedData 如何与 PlacementManager 集成
- 种子放置的预览系统（复用 PlacementPreview 还是保留 FarmToolPreview.UpdateSeedPreview）
- 种子放置成功后的回调（实例化 CropController）
- 导航支持（和树苗一样的自动寻路）
- 从 GameInputManager 的农田工具链中完全剥离种子相关代码

**建议**：模块R 作为独立的 Phase 留出接口，不在本次 V6 补丁中实施。原因：
1. 架构调整范围大，需要单独的详细设计文档
2. 当前种子队列虽然不是"放置系统"，但功能上可用（能种植、有预览）
3. 其他模块（Q/S/T/V/N'/O'/P'）的修复更紧急
4. 种子放置化可以作为补丁005或独立工作区处理

**V6 中的最小改动**：
- 在 GameInputManager 中标注种子相关代码为"待迁移到 PlacementManager"
- 不删除现有种子队列代码（保持可用）
- 预留接口设计

### 6.4 正确性属性

暂无（待独立设计时定义）。

---

## 七、V5.1 遗留模块整合（未实施的已敲定方案）

以下模块在 V5/V5.1/锐评002-003审核报告中已经敲定方案，但尚未实施代码。V6 统一纳入。

### 7.1 模块N' — 耕地 b 层统一拦截（锐评003 方案）

**来源**：V5 模块N + 锐评003 枯萎作物漏洞修复

**方案**（锐评002-003审核报告第5.1节已敲定）：
```csharp
// 先计算 canTill 和 canClearWithered（保持原有逻辑不变）
// ...

// 🔴 V6 模块N'：已在队列中的格子统统无效（锐评003 统一拦截）
if (queuePreviewPositions.Contains(cellPos))
{
    canTill = false;
    canClearWithered = false;
    hasCrop = false;  // 🔴 V6 新增：hasCrop 也要拦截
}

bool isValid = !hasObstacle && (canTill || hasCrop);
```

**V6 补充**：锐评003 的统一拦截只覆盖了 `canTill` 和 `canClearWithered`。V6 新增了 `hasCrop`（模块S），也需要纳入拦截范围。已在队列中的格子，无论有没有农作物，都不应该再次操作。

### 7.2 模块O' — canTill=false 全量铺 1+8 + 废弃白框

**来源**：V5 模块O + 锐评001 审视报告

**方案**：canTill=false 分支也调用 `GetPreviewTiles` 计算完整 1+8 预览，写入 ghostTilemap（不做增量过滤）。废弃 `cursorRenderer`。

**V6 修正**：由于模块S引入了 `hasCrop` 分支，canTill=false 的 else 分支需要细分：
- `hasCrop = true`：不显示任何预览（模块S）
- `hasCrop = false` 且 `canTill = false`（无农作物的已有耕地）：显示放置系统红方框（模块S）
- `canTill = true`：正常显示绿色 1+8 预览

所以 V5 的"canTill=false 全量铺 1+8"方案需要调整——只有在"无农作物的已有耕地"场景下才显示红方框，不再铺 1+8。

**等等，重新审视**：

用户对"无农作物的已有耕地"的要求是"显示放置系统的红方框"，不是"显示红色 1+8 预览"。这与 V5 的"canTill=false 全量铺 1+8 红色染色"方案不同。

用户的精确要求：
- 可耕种的空地：绿色 1+8 预览（现有逻辑）
- 有农作物的耕地：什么都不显示（模块S）
- 无农作物的已有耕地：放置系统红方框（不是红色 1+8）

所以 V5 的"canTill=false 全量铺 1+8"方案被用户的新要求覆盖了。V6 中 canTill=false 分支不再铺 1+8，改为：
- `hasCrop = true`：空白
- `hasCrop = false`：红方框

### 7.3 模块O'' — Shader 染色保持

**来源**：锐评001 审视报告

**方案**：保留 `previewOverlayMaterial.SetColor` 根据 `isValid` 设置颜色。
- isValid=true：绿色（`overlayValidColor`）
- isValid=false：红色（`overlayInvalidColor`）

**V6 修正**：
- `hasCrop = true` 时 ghostTilemap 为空，shader 染色无载体，设置 `Color.clear` 即可
- `hasCrop = false && canTill = false` 时 ghostTilemap 也为空（只有 cursorRenderer 红方框），同样设置 `Color.clear`
- 只有 `canTill = true` 时 ghostTilemap 有 tile，shader 染色才有意义

### 7.4 模块P' — 浇水水渍 tile 移出 isValid 保护圈

**来源**：锐评001 审视报告 + 锐评002-003 审核报告

**方案**：无论 isValid，都计算并放置水渍 tile（作为 shader 载体）。随机逻辑也移出 isValid。

**V6 修正**：模块T 重写了随机逻辑（不再是"进入新格子就随机"），水渍 tile 放置逻辑需要配合 T 的新方案。

具体：
- 水渍 tile 放置移出 `if (isValid)` 保护圈 ✅（无论 isValid 都放置，作为 shader 载体）
- 随机逻辑改为模块T的方案（切换时随机 + 浇水后移出才随机）
- shader 根据 isValid 设置绿色/红色

### 7.5 模块U — 浇水 b 层纳入

**来源**：V5.2 模块U

**方案**：
```csharp
if (canWater && queuePreviewPositions.Contains(cellPos))
    canWater = false;
```

V6 保持不变。

### 7.6 模块P'' — 播种 b 层拦截

**来源**：V5 模块P

**方案**：
```csharp
if (canPlant && queuePreviewPositions.Contains(cellPos))
    canPlant = false;
```

V6 保持不变。


---

## 八、UpdateHoePreview 完整逻辑流重构

综合模块 Q/S/N'/O'/O''/V 的所有改动，UpdateHoePreview 的完整逻辑流如下：

```
Step 1: 基础设置（Sorting Layer、障碍物检测）

Step 2: 状态判断
  canTill = CanTillAt(layerIndex, cellPos)
  
  hasCrop = false
  if (!canTill):
    tileData = GetTileData(layerIndex, cellPos)
    if (tileData?.cropController != null):
      hasCrop = true
  
  // 🔴 V6 模块N'：b 层统一拦截（在所有判断之后）
  if (queuePreviewPositions.Contains(cellPos)):
    canTill = false
    hasCrop = false
  
  isValid = !hasObstacle && (canTill || hasCrop)

Step 3: 视觉处理（三分支）
  if (canTill):
    // 分支A：可耕种 — 绿色 1+8 预览 + 增量差集
    GetPreviewTiles → 增量差集过滤（🔴 V6 模块V：合并 c+b 方向）→ ghostTilemap
    shader 染色 = overlayValidColor（绿色）
    cursorRenderer.enabled = false
    
  else if (hasCrop):
    // 分支B：有农作物 — 什么都不显示
    ghostTilemap 空（ClearGhostTilemap 已清空）
    cursorRenderer.enabled = false
    shader 染色 = Color.clear（无载体）
    
  else:
    // 分支C：无农作物的已有耕地 / 已在队列中 / 其他不可耕种
    ghostTilemap 空
    cursorRenderer.enabled = true → 放置系统红方框
    shader 染色 = Color.clear（无载体）

Step 4: 入队类型判断（在 TryEnqueueFarmTool 中）
  if (canTill): FarmActionType.Till
  else if (hasCrop): FarmActionType.RemoveCrop
  else: 不允许入队（isValid = false）
```

### 8.1 与 V5.2 的关键差异

| 维度 | V5.2 | V6 |
|------|------|-----|
| canTill=false 视觉 | cursorRenderer 红框 | 三分支：hasCrop→空白 / 其他→放置系统红方框 |
| canTill=false 铺 1+8 | 不铺 | 不铺（用户要求红方框，不是红色 1+8） |
| hasCrop 判断 | 无（只有 canClearWithered） | 新增，检测任何状态的 cropController |
| 增量差集 | c 层有 tile 就不查 b 层 | 合并 c+b 方向后再做差集 |
| b 层拦截 | 无 | 统一拦截 canTill + hasCrop |

---

## 九、UpdateWateringPreview 完整逻辑流重构

综合模块 T/U/P'/O'' 的所有改动：

```
Step 1: 基础设置（Sorting Layer、障碍物检测）

Step 2: 状态判断
  canWater = tileData.isTilled && !tileData.wateredToday
  
  // 🔴 V6 模块U：b 层拦截
  if (canWater && queuePreviewPositions.Contains(cellPos)):
    canWater = false
  
  isValid = !hasObstacle && canWater

Step 3: 切换检测 + 随机逻辑（🔴 V6 模块T）
  if (!_wateringModeInitialized):
    随机默认样式
    _wateringModeInitialized = true
  
  if (_hasWateredSinceSwitch && cellPos != _wateredCellPos):
    触发随机 → 锁定新样式
    _hasWateredSinceSwitch = false

Step 4: 水渍 tile 放置（🔴 V6 模块P'：移出 isValid 保护圈）
  无论 isValid，都放置水渍 tile（作为 shader 载体）

Step 5: shader 染色
  isValid → overlayValidColor（绿色/蓝色）
  !isValid → overlayInvalidColor（红色）
```

---

## 十、全面遗漏检查

逐一核对所有历史版本中发现的问题，确认 V6 是否全部覆盖：

| 问题 | 来源 | V6 覆盖 | 模块 |
|------|------|---------|------|
| Ghost 差异化过滤（只显示变化 tile） | V1 US-1 | ✅ 已实施（V2代码） | — |
| 队列预览完整清理（边界残留） | V1 US-2 | ✅ 已实施（V2代码） | — |
| 执行预览保护（WASD 不清除执行预览） | V1 US-3 | ✅ 已实施（V2代码） | — |
| 三层垂直统一数据流 | V1 US-4 | ✅ 已实施（V2代码） | — |
| 浇水进入新格子才随机 | V1 US-5 | 🔄 V6 重写为"浇水后移出才随机" | 模块T |
| Ghost 不锁定（移除 LockPosition） | V1 US-6 | ✅ 已实施（V2代码） | — |
| ClearActionQueue 执行状态保护 | V3 模块H | ✅ 已实施（V3代码） | — |
| PromoteToExecutingPreview 时机修正 | V3 模块I | ✅ 已实施（V3代码） | — |
| canTill=false 红色反馈 | V3 模块J | 🔄 V6 重写为三分支 | 模块S |
| Sorting Order 确认 | V3 模块K | ✅ 已实施（V3代码） | — |
| 三层增量 + b 层 1+8 | V3代码 | ✅ 已实施 | — |
| RemoveExecutingPreview 误删队列预览 | V4 | ✅ 已实施（V4代码） | — |
| a 层 canTill 纳入 b 层 | V5 模块N | 📋 V6 纳入 | 模块N' |
| 统一颜色控制（保留 Shader） | V5.1 | 📋 V6 纳入 | 模块O'' |
| canTill=false 全量铺 1+8 | V5 模块O | ❌ 被用户新要求覆盖（改为红方框） | 模块S |
| 浇水/播种 b 层拦截 | V5 模块P | 📋 V6 纳入 | 模块U/P'' |
| 枯萎作物统一拦截 | 锐评003 | 📋 V6 纳入（扩展为 hasCrop） | 模块N' |
| 浇水水渍移出 isValid | V5.1 R3 | 📋 V6 纳入 | 模块P' |
| 极限操作 WASD 中断 | V5.2 Bug1 | 📋 V6 重写为"绝对锁定" | 模块Q |
| 种子放置化 | V5.2 Bug2 | ⏸️ 待定（独立设计） | 模块R |
| 锄头对农作物处理 | V5.2 Bug3 | 📋 V6 重写 | 模块S |
| 浇水随机逻辑 | V5.2 Bug4 | 📋 V6 重写 | 模块T |
| 浇水 b 层纳入 | V5.2 Bug5 | 📋 V6 纳入 | 模块U |
| Ghost 增量差集 c 层附近 bug | 用户新发现 | 📋 V6 新增 | 模块V |

### 10.1 遗漏检查结论

所有已发现的问题都已覆盖。模块R（种子放置化）作为待定项，不在本次 V6 中实施。


---

## 十一、V6 修复模块汇总

| 模块 | 问题 | 修改文件 | 优先级 | 状态 |
|------|------|---------|--------|------|
| Q | Bug1 极限操作 — 绝对锁定 | GameInputManager.cs（HandleMovement + CancelFarmingNavigation） | 🔴 最高 | 📋 待实施 |
| S | Bug3 锄头对农作物 — 全状态清除 + 三分支视觉 | FarmToolPreview.cs + GameInputManager.cs + CropController.cs | 🔴 高 | 📋 待实施 |
| V | Ghost 增量差集 c+b 方向合并 | FarmToolPreview.cs（UpdateHoePreview 增量差集逻辑） | 🔴 高 | 📋 待实施 |
| N' | 耕地 b 层统一拦截（含 hasCrop） | FarmToolPreview.cs（UpdateHoePreview） | 🔴 高 | 📋 待实施 |
| T | Bug4 浇水随机 — 浇水后移出才随机 | FarmToolPreview.cs（UpdateWateringPreview）+ GameInputManager.cs | 🟡 中 | 📋 待实施 |
| U | 浇水 b 层纳入 | FarmToolPreview.cs（UpdateWateringPreview） | 🟡 中 | 📋 待实施 |
| P' | 浇水水渍移出 isValid 保护圈 | FarmToolPreview.cs（UpdateWateringPreview） | 🟡 中 | 📋 待实施 |
| O'' | Shader 染色调整（配合三分支） | FarmToolPreview.cs（UpdateHoePreview） | 🟡 中 | 📋 待实施 |
| P'' | 播种 b 层拦截 | FarmToolPreview.cs（UpdateSeedPreview） | 🟡 低 | 📋 待实施 |
| R | Bug2 种子放置化 | 架构级调整 | 🔴 高 | ⏸️ 待定 |

---

## 十二、实施顺序建议

### Phase 1：极限操作修复（模块Q）
- 1.1 HandleMovement WASD 中断分支增加 wasExecuting 检查
- 1.2 CancelFarmingNavigation 增加执行保护
- 1.3 编译验证

### Phase 2：增量差集修复（模块V）
- 2.1 UpdateHoePreview 增量差集逻辑改为合并 c+b 方向
- 2.2 编译验证

### Phase 3：锄头农作物处理（模块S）
- 3.1 UpdateHoePreview 新增 hasCrop 判断 + 三分支视觉
- 3.2 新增 FarmActionType.RemoveCrop 枚举值
- 3.3 CropController 新增 RemoveCrop() 公开方法
- 3.4 ExecuteFarmAction 新增 RemoveCrop 分支
- 3.5 _pendingTileUpdate 监听 + OnFarmActionAnimationComplete 新增 RemoveCrop 分支
- 3.6 TryEnqueueFarmTool 入队类型判断
- 3.7 编译验证

### Phase 4：b 层统一拦截（模块N'）
- 4.1 UpdateHoePreview 中 b 层统一拦截（canTill + hasCrop）
- 4.2 编译验证

### Phase 5：浇水预览重构（模块T + U + P' + O''）
- 5.1 UpdateWateringPreview 浇水随机逻辑重写（模块T）
- 5.2 canWater b 层拦截（模块U）
- 5.3 水渍 tile 移出 isValid 保护圈（模块P'）
- 5.4 Shader 染色调整（模块O''）
- 5.5 编译验证

### Phase 6：播种 b 层拦截（模块P''）
- 6.1 UpdateSeedPreview canPlant b 层拦截
- 6.2 编译验证

### Phase 7：验收（全部模块）
- 7.1 正确性属性逐项审查
- 7.2 创建验收指南V6
- 7.3 更新 memory

### 待定：种子放置化（模块R）
- 独立设计文档
- 独立实施

---

## 十三、涉及文件汇总

| 文件 | 涉及模块 | 修改内容 |
|------|---------|---------|
| GameInputManager.cs | Q, S, T | HandleMovement WASD 绝对锁定 + CancelFarmingNavigation 执行保护 + ExecuteFarmAction RemoveCrop 分支 + _pendingTileUpdate RemoveCrop + OnFarmActionAnimationComplete RemoveCrop + TryEnqueueFarmTool 入队类型 + 浇水执行后设置标志 |
| FarmToolPreview.cs | S, V, N', T, U, P', O'', P'' | UpdateHoePreview 三分支+增量差集修复+b层拦截 + UpdateWateringPreview 随机重写+b层+水渍移出isValid + UpdateSeedPreview b层拦截 + 新增浇水模式字段 |
| CropController.cs | S | 新增 RemoveCrop() 公开方法 |
| FarmActionType（枚举） | S | 新增 RemoveCrop 值 |

**不需要修改的文件**：
- PlayerInteraction.cs — 回调链不变
- FarmlandBorderManager.cs — 预览计算不变（ParseDirections/IsBorderTile/SelectBorderTile 已在 V3 中添加）
- FarmTileManager.cs — 数据层不变
- PlayerAnimController.cs — 动画进度计算不变

---

## 十四、与锐评004审视报告的差异汇总

| 模块 | 锐评004审视报告方案 | V6 最终方案 | 变化原因 |
|------|-------------------|-----------|---------|
| Q | 立即中断+手动清理（7项状态重置） | 绝对锁定（wasExecuting 检查） | 锐评005 纠正 + 用户设计理念 |
| S | 全状态农作物清除+分场景视觉 | 保持不变 | — |
| T | 浇水后+移出才随机 | 保持不变 | — |
| V | 增量差集合并 c+b 方向 | 保持不变 | — |
| R | 走 PlacementManager 路径 | 待定（独立设计） | 实施复杂度高，优先级调整 |

唯一实质性变化是模块Q：从"立即中断+手动清理"回归"绝对锁定"。这是本次 V6 报告的核心转变。

---

## 十五、待用户确认事项

1. **模块S 红方框样式**：当前 `cursorRenderer` 的 Sprite 是否与放置系统的 `PlacementGridCell.CreateGridSprite` 一致？如果不一致，是否需要替换？
2. **模块R 种子放置化**：是否同意作为待定项，不在本次 V6 中实施？还是必须在 V6 中一并完成？
3. **模块S 入队动画**：RemoveCrop 使用 Crush 动画（和耕地一样）是否合适？还是需要其他动画？
4. **模块T 浇水执行后标志设置位置**：在 `ExecuteWaterTile` 中设置（数据层执行时）还是在 `OnFarmActionAnimationComplete` 中设置（动画完成时）？推荐前者（数据层执行时），因为这是"真正浇了水"的时刻。

