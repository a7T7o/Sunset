好家伙，Kiro 主刀医生，这几刀下去，虽然缝合了真空期，但依然被你敏锐的 QA 之眼抓到了新的出血点！

看来 003 号手术的线缝得还是不够密实，尤其是在“动画临界点”、“浇水随机状态机”以及“种子层级对齐”这几个骨灰级细节上，确实出现了滑铁卢。作为你的架构锐评者和监工，我必须向你致歉：我在审查时只盯着逻辑的闭环，却低估了 Unity 生命周期帧和你的“无情连点器”手速所带来的竞态灾难。

来，我们立刻开启 **004锐评001** 模式。我会像手术刀一样剖析你这 4 个致命反馈，然后给你重铸一套绝对防弹的执行指令！

---

# 🔎 004锐评001：临界帧崩溃与状态机重构

## 🩸 病灶剖析与锐评

### 1. 致命的“薛定谔的帧”：临界移动导致的预览残留

* **症状还原：** 你在触发动画的“前一极小瞬间”或“动画开始的第一帧”按下方向键，导致动作被中断，但预览（b层或c层的中心块）残留在原地成了“幽灵”。
* **架构锐评：** 这是一个极其典型的 **Time-of-Check to Time-of-Use (TOCTOU) 竞态漏洞**。
在 `GameInputManager` 中，我们设定的保护伞是 `_isExecutingFarming`。理论上，只要它为 `true`，WASD 就无法用 `CancelFarmingNavigation` 杀掉操作。
**但是！** 如果你按 WASD 的时机刚好卡在：
1. 导航刚好到达（距离够了），`StartFarmingNavigation` 的协程准备执行 `onArrived` 回调。
2. 或者 `ExecuteFarmAction` 刚调用了 `playerInteraction.RequestAction`，但 `_isExecutingFarming` 还没来得及设为 `true`（或者设了 true 但动画系统还没接管移动控制权）。
此时，WASD 的 `ClearActionQueue()` 抢先介入，把队列和状态全清了，但渲染层（GhostTilemap 或 QueueTilemap）没收到清理指令，或者正在执行的动画被腰斩，导致 `RemoveExecutingPreview` 永远不会被调用。


* **结论：** 我们对“动画执行期间”的保护太晚了，且没有涵盖“即将执行”的临界区。

### 2. 浇水随机状态机的“失忆症”

* **症状还原：** 你之前明确定义过：**浇完水（或左键排队后） + 鼠标移出当前格子 = 触发新随机**。但我却把它简单粗暴地改成了“入队瞬间立刻随机”。
* **架构锐评：** 这完全是我的阅读理解和架构设计失误！我为了追求“解耦”，直接把随机塞进了 `TryEnqueueFarmTool` 里，导致你鼠标还没移开，光标下的预览就变了。这违反了你“不移出当前耕地就不改变样式”的用户体验规则。
* **结论：** 我们必须找回那个被我们废弃的标志位机制（类似 `_needsNewPuddleVariant`），但要把它做得更干净：在“入队”时打标记，在“UpdatePreview检测到跨格子”时才真正执行随机。

### 3. 种子与作物的“底盘错位”（图二图三图四）

* **症状还原：** 连点播种出错，且种子的放置预览和实际种下的作物，没有在格子的物理中心对齐（底部中心对齐网格中心）。
* **架构锐评：**
* **连点出错：** 这大概率还是种子无动画执行导致的时序问题。
* **对齐错位：** 我们在 `UpdateSeedPreview` 和 `ExecutePlantSeed` 里计算位置时，肯定少算或者多算了偏移量。放置系统（如树苗）通常是基于 Sprite 的 pivot 底部居中，而我们直接用的 `GetCellCenterWorld`，这可能导致 32x32 的作物 Sprite 在 16x16 的格子里向上飘了半格。


* **结论：** 需要核对 `UpdateSeedPreview` 中 `seedPreviewRenderer.transform.position` 的计算方式，以及 `CropController` 实例化时的世界坐标偏移。这部分**可能需要你提供 `CropController` 中处理位置对齐（类似 `AlignSpriteBottom`）的相关代码片段**。

### 4. 锄草操作的“提前结算”漏洞

* **症状还原：** 锄头挖作物，动画还没放完，格子就被判定为“不可耕种”了。你希望用“先隐藏，后删除”来缓冲。
* **架构锐评：** 这是一个非常聪明的体验优化！目前的 `ExecuteRemoveCrop`（在动画中期触发）直接把 Crop GameObject 销毁了，导致底层 tileData 的引用瞬间清空。
* **结论：** 你的思路完全正确。我们可以给 `CropController` 加一个 `HideCrop()` 方法。在动画中期只隐藏它，等 `OnFarmActionAnimationComplete` 彻底结束时，再去真正的 `RemoveCrop`。

---

## 🚀 Kiro 的完美执行指令（Prompt 重铸版）

由于第 3 点（种子对齐）需要你的补充代码，我先为你生成解决 **1、2、4 三个致命问题**的高精尖执行 Prompt。你把它丢给你的 IDE，然后把 `CropController` 的对齐代码发给我，我们再补上最后一刀。

**准备好发给自己的指令了吗？**

```markdown
# 004手术执行令：封印临界帧与重塑状态机

致主刀医生 Kiro：
这是一场精细的微创手术。不要大改，不要重构，只要在核心节点打上最坚固的补丁！

### 🎯 任务一：封印“临界帧崩溃”（最高优）
**病因**：WASD 的 `ClearActionQueue` 与动画系统争夺控制权，导致预览残留。
**动作**：
去 `GameInputManager.cs` 的 `HandleMovement()` 方法里，找到 `bool hasWASD = input.sqrMagnitude > 0.01f;` 那一块逻辑。
我们必须强化绝对锁定原则：只要队列里有东西，或者处于 `Locked` / `Navigating` / `Executing` 的任意一个状态，WASD 的清理行为必须被极其严格地约束。
**修改方案（伪代码逻辑，请在 C# 中精确实现）：**
在 `if (hasWASD && hasActiveQueue)` 的判断前，增加一个临界状态检测。如果当前正在尝试调用动画（从 `StartFarmingNavigation` 的回调到 `_isExecutingFarming = true` 这一微小时差内），**绝对禁止 WASD 中断**。

### 🎯 任务二：重塑浇水“延迟随机”状态机
**病因**：入队瞬间立刻随机，导致鼠标还没移开，原地预览就变了。
**动作**：
1. **找回记忆**：在 `FarmToolPreview.cs` 顶部找回标志位 `private bool _pendingPuddleRandomization = false;` 和 `private Vector3Int _lastPuddleEnqueuePos;`
2. **入队打标**：去 `GameInputManager.cs` 的 `TryEnqueueFarmTool` 里，**删掉**那句让你深恶痛绝的“入队成功后立刻 Random.Range”。改为调用：`FarmToolPreview.Instance.MarkForNextPuddleRandomization(cellPos);`
3. **跨格触发**：去 `FarmToolPreview.cs` 的 `UpdateWateringPreview` 方法。在开头加一段逻辑：
   如果 `_pendingPuddleRandomization` 为 true，**且** 当前传入的 `cellPos` **不等于** `_lastPuddleEnqueuePos`，才去触发真正的 `Random.Range`，并把标志位设回 false。

### 🎯 任务三：锄草操作的“视觉隐藏缓冲”
**病因**：动画还没完，作物就真没了。
**动作**：
1. 去 `CropController.cs` 加一个小方法：
   ```csharp
   public void HideCropVisuals() { 
       // 获取你所有的 SpriteRenderer 并 enabled = false; 
   }

```

2. 去 `GameInputManager.cs` 的 `ExecuteRemoveCrop`（这是在动画 50% 触发的）。**不要**调用 `RemoveCrop()`，改为调用 `HideCropVisuals()`。
3. 去 `OnFarmActionAnimationComplete()` 回调里。判断刚才如果是 `FarmActionType.RemoveCrop`，在这里才真正去调用底层的 `RemoveCrop()` 把数据删掉。

---

请先执行以上三个任务！
**执行完毕后，请务必把 `CropController` 中处理对齐或 Sprite 渲染层级的代码发给我**，我们需要彻底解决你图 2、3、4 里种子位置下沉的严重 Bug！

```

快去执行，我等你发代码补全第三刀！

```