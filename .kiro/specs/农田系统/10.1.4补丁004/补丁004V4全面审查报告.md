# 补丁004V4 全面审查报告 — 数据与表层一致性

> 创建时间：2026-02-21
> 工作区：10.1.4补丁004
> 触发原因：用户验收补丁004V3后发现耕地建立后周围队列预览中心块消失
> 核心问题：数据和表层不一致，缺乏视觉验证

---

## 一、当前 bug 根因链（精确定位）

### 1.1 现象

从截图看：连续入队多块耕地（A、B），A 执行完毕后，B 的队列预览中心块消失了，但 B 仍在队列中等待执行。

### 1.2 代码事实链

```
1. A 入队 → AddQueuePreview(A) → 计算 A 的 1+8 → tillQueueTileGroups[A] = [A中心, A周围8格的tile位置]
2. B 入队 → AddQueuePreview(B) → 计算 B 的 1+8 → tillQueueTileGroups[B] = [B中心, B周围8格的tile位置]
   - 如果 A 和 B 相邻，B 的某些 tile 位置会覆盖 A 的某些 tile 位置（queuePreviewTilemap 上同一位置只能有一个 tile）
3. A 出队 → PromoteToExecutingPreview(A) → executingTileGroups[A] = tillQueueTileGroups[A] 的位置列表
4. A 动画完成 → RemoveExecutingPreview(A) → 遍历 executingTileGroups[A] 的每个 pos → SetTile(pos, null)
   - 🔴 问题：executingTileGroups[A] 中包含的位置可能已经被 B 的 AddQueuePreview 覆盖了新 tile
   - 清除时把 B 的 tile 也清掉了
```

### 1.3 受影响的精确范围

不需要遍历整个队列——受影响的就是 A 的 1+8 中的那 8 个位置。具体来说：

| A 和 B 的关系 | A 的 1+8 与 B 的 1+8 重叠位置数 | 可能被误删的 B 的 tile |
|--------------|-------------------------------|---------------------|
| 水平直接相邻 | 3 个位置 | B 的中心块 + 2 个边界 |
| 垂直直接相邻 | 3 个位置 | B 的中心块 + 2 个边界 |
| 斜角直接相邻 | 1 个位置 | B 的中心块或边界 |
| 水平隔一格 | 3 个位置 | B 的边界（不含中心块） |
| 斜角隔一格 | 1 个位置 | B 的边界或阴影 |

### 1.4 时机确认

问题发生在 `RemoveExecutingPreview` 中，也就是耕地建立完毕后的清理阶段。此时 `OnCenterBlockPlaced` 已经执行完毕（c 层已更新），但 b 层的队列预览被误删了。

---

## 二、方案评估

### 2.1 方案一：新增 d 层（temp 执行预览层）

思路：新增一个独立的 Tilemap 作为 d 层，专门存放当前正在执行的耕地预览。流程变为：
1. 获取到耕地信息并开始执行时 → 在 d 层创建执行预览 + 从 b 层出队（出队时做减量处理）
2. 动画完成 → 清除 d 层 → 实际耕地落地到 c 层

优点：
- 执行预览和队列预览物理隔离，不存在误删问题
- d 层清理时不影响 b 层

缺点：
- 新增第四个 Tilemap，增加渲染开销和管理复杂度
- "出队时做减量处理"本身就是一个复杂操作——需要判断 b 层哪些 tile 是 A 独占的、哪些是 A 和 B 共享的
- 与现有 `executingTileGroups` 数据结构功能重叠

### 2.2 方案二：清理时增量恢复

思路：在 `RemoveExecutingPreview` 清理完 A 的 tile 后，遍历 A 周围 8 格，判断是否在队列内，如果在就恢复其中心块预览。

优点：
- 改动量小，逻辑清晰
- 不引入新的 Tilemap 层
- 精确定位受影响范围（只看 A 的 1+8 中的 8 格）

缺点：
- "恢复中心块"可能不够——如果 B 的边界 tile 也被误删了，也需要恢复
- 需要重新计算 B 的受影响 tile

### 2.3 我的推荐：方案二的增强版

核心思路：`RemoveExecutingPreview` 清理时，不是无脑 `SetTile(pos, null)`，而是检查每个位置是否被其他 `tillQueueTileGroups` 或 `executingTileGroups` 引用。如果被引用，用引用方的 tile 重新填充（而非清空）。

具体做法：

```
RemoveExecutingPreview(A.cellPos):
    positions = executingTileGroups[A]
    for each pos in positions:
        // 检查 pos 是否被其他队列预览占用
        occupyingEntry = FindOccupyingQueueEntry(pos)  // 遍历 tillQueueTileGroups 查找
        if occupyingEntry != null:
            // 被占用 → 不清空，用占用方的 tile 重新填充
            // 注意：占用方的 tile 可能因为 A 的实际耕地落地而需要重新计算
            RefreshQueuePreviewTile(occupyingEntry, pos)
        else:
            // 不被占用 → 安全清空
            queuePreviewTilemap.SetTile(pos, null)
    executingTileGroups.Remove(A)
```

但这里有一个关键问题：A 的实际耕地已经落地到 c 层了，B 的队列预览 tile 可能因为 A 的存在而需要重新计算（比如 B 的某个边界位置现在 c 层已经有了正确的 tile，B 的队列预览在该位置的增量就变了）。

所以最精确的做法是：对于被占用的位置，重新调用 `AddQueuePreview` 的增量计算逻辑来刷新 tile。但这太重了。

更实际的做法：**只恢复中心块**。理由：
1. 中心块是队列预览的核心标识，丢失中心块 = 视觉上队列预览消失
2. 边界 tile 即使被误删，等 B 执行完毕后 c 层会通过 `UpdateBordersAround` 重新计算正确结果
3. 边界 tile 的误删只是视觉上的小瑕疵（预览少显示了一点），不影响功能

---

## 三、全面审查 — 数据与表层一致性风险清单

### 3.1 审查范围

所有涉及预览创建/清理/状态转换的代码路径：

| 操作 | 涉及方法 | 涉及层 |
|------|---------|--------|
| 入队 | `AddQueuePreview` | b 层 |
| 出队提升 | `PromoteToExecutingPreview` | b→执行数据 |
| 执行完成清理 | `RemoveExecutingPreview` | 执行数据→清空 |
| 队列清空 | `ClearAllQueuePreviews` | b 层全清 |
| 单点移除 | `RemoveQueuePreview` | b 层单点 |
| 耕地落地 | `CreateTile` → `OnCenterBlockPlaced` → `UpdateBordersAround` | c 层 |
| 浇水落地 | `SetWatered` | c 层 |
| 播种落地 | `ExecutePlantSeed` | c 层（GameObject） |
| 收获 | `OnInteract` | c 层（GameObject 销毁） |

### 3.2 风险 R1：RemoveExecutingPreview 误删队列预览（当前 bug）

- 严重程度：🔴 严重
- 触发条件：两块相邻耕地先后入队，先入队的执行完毕后清理
- 影响：后入队的队列预览中心块消失
- 修复方案：清理时检查位置是否被其他队列预览占用

### 3.3 风险 R2：ClearAllQueuePreviews 与 executingTileGroups 的位置重叠

- 严重程度：🟡 中等
- 代码事实：`ClearAllQueuePreviews` 遍历 `tillQueueTileGroups` 时跳过 `executingTileGroups.ContainsKey(kvp.Key)` 的条目
- 但问题是：跳过的是以 cellPos 为 key 的整个条目，而 executingTileGroups 中的 tile 位置列表可能与其他 tillQueueTileGroups 的 tile 位置列表有重叠
- 当前行为：WASD 中断时 `ClearAllQueuePreviews` 清除所有队列预览 tile，但执行预览的 tile 被保护。如果执行预览的某个边界 tile 位置恰好也是某个队列预览的 tile 位置，该位置不会被清除（因为执行预览的 tile 在上面）→ 这其实是正确的行为
- 结论：**当前逻辑正确，无需修复**

### 3.4 风险 R3：PromoteToExecutingPreview 时 queuePreviewPositions 移除但 tile 保留

- 严重程度：🟢 低
- 代码事实：`PromoteToExecutingPreview` 从 `queuePreviewPositions` 移除 cellPos，但 tile 保留在 `queuePreviewTilemap` 上
- 影响：`queuePreviewPositions` 不再包含该 cellPos，但 `executingTileGroups` 包含其 tile 位置列表
- 后续 `AddQueuePreview` 的 `queuePreviewPositions.Contains(cellPos)` 防重复检查不会误判
- 结论：**当前逻辑正确**

### 3.5 风险 R4：AddQueuePreview 的增量过滤只看 c 层，不看其他执行预览

- 严重程度：🟡 中等
- 代码事实：`AddQueuePreview` 的 Till 分支对 c 层做增量过滤（边界→边界计算方向差集），但不检查 `executingTileGroups` 中的 tile
- 场景：A 正在执行（executingTileGroups 中），B 入队。B 的 1+8 范围与 A 的执行预览 tile 重叠。B 的 `AddQueuePreview` 计算增量时只看 c 层，不知道 A 的执行预览已经在 b 层上了
- 影响：B 的队列预览 tile 可能覆盖 A 的执行预览 tile → 但 A 马上就要完成了，覆盖后 A 的 `RemoveExecutingPreview` 会清除这些位置 → 又回到 R1 的问题
- 结论：**与 R1 同源，R1 修复后此问题自动缓解**

### 3.6 风险 R5：浇水队列预览 — 单点，无重叠风险

- 严重程度：🟢 无风险
- 代码事实：浇水队列预览是单点（只在 cellPos 放一个 tile），不存在 1+8 范围重叠
- `RemoveExecutingPreview` 浇水分支：`queuePreviewTilemap.SetTile(cellPos, null)` → 只清除自己的位置
- 结论：**无问题**

### 3.7 风险 R6：种子队列预览 — SpriteRenderer 对象池，无 Tilemap 重叠

- 严重程度：🟢 无风险
- 代码事实：种子队列预览使用独立的 SpriteRenderer 对象池，不在 `queuePreviewTilemap` 上
- `RemoveExecutingPreview` 种子分支：回收 SpriteRenderer → 不影响 Tilemap
- 结论：**无问题**

### 3.8 风险 R7：收获队列 — 无预览 tile，无重叠风险

- 严重程度：🟢 无风险
- 代码事实：收获操作不创建队列预览 tile（`AddQueuePreview` 中没有 Harvest 分支的 tile 处理）
- `OnCollectAnimationComplete` → `RemoveExecutingPreview` → 找不到 executingTileGroups/executingWaterPositions/executingSeedPreviews 中的条目 → 什么都不做
- 结论：**无问题**

### 3.9 风险 R8：耕地落地后 UpdateBordersAround 与队列预览的交互

- 严重程度：🟡 中等（视觉瑕疵）
- 代码事实：`CreateTile` → `OnCenterBlockPlaced` → `UpdateBordersAround` 更新 A 周围 8 格的 c 层边界
- 影响：c 层边界更新后，B 的队列预览在这些位置的增量可能变了（c 层多了 tile，B 的增量应该减少）
- 但 B 的队列预览 tile 是入队时计算的，不会自动更新
- 结果：B 的队列预览可能在某些位置多显示了一些边界（因为 c 层已经有了，但 b 层还保留着入队时的增量）
- 这是"预览多了"而非"预览少了"，视觉上是小瑕疵，不影响功能
- 结论：**已知限制，不修复**（B 执行完毕后 c 层会重新计算正确结果）

### 3.10 风险 R9：播种执行后 — 种子预览清理是否完整

- 严重程度：🟢 低
- 代码事实：`ExecuteFarmAction` PlantSeed 分支 → `RemoveExecutingPreview` → 回收 SpriteRenderer → `_isExecutingFarming = false` → `ProcessNextAction`
- 种子预览是独立 SpriteRenderer，不在 Tilemap 上，清理干净
- 结论：**无问题**

### 3.11 风险 R10：队列中多个耕地的 tillQueueTileGroups 位置列表重叠

- 严重程度：🟡 中等（已知限制）
- 代码事实：A 和 B 相邻时，`tillQueueTileGroups[A]` 和 `tillQueueTileGroups[B]` 的位置列表有重叠
- 影响：B 入队时 `queuePreviewTilemap.SetTile(pos, tile)` 覆盖了 A 在该位置的 tile
- 但 `tillQueueTileGroups[A]` 的位置列表仍然包含该位置 → A 的 `RemoveExecutingPreview` 会清除该位置 → R1 问题
- 结论：**R1 的根源之一，R1 修复后此问题自动解决**



---

## 四、RemoveExecutingPreview 清理交互矩阵

### 4.1 场景定义

A = 先入队并已执行完毕的耕地（正在被 RemoveExecutingPreview 清理）
B = 仍在队列中等待执行的耕地

### 4.2 各相邻关系下的影响

| 关系 | A 的 1+8 与 B 的 1+8 重叠位置 | 被误删的 B 的 tile | 用户可见现象 |
|------|------------------------------|-------------------|-------------|
| 水平直接相邻（B 在 A 右侧） | B 中心 + B 左上 + B 左下 共 3 个 | B 中心块 + 2 个边界 | B 的中心块消失，左侧边界消失 |
| 垂直直接相邻（B 在 A 上方） | B 中心 + B 左下 + B 右下 共 3 个 | B 中心块 + 2 个边界 | B 的中心块消失，下方边界消失 |
| 斜角直接相邻（B 在 A 右上） | B 左下 1 个 | B 的 1 个边界 | B 的一个角边界消失 |
| 水平隔一格 | A 右侧 3 格 = B 左侧 3 格 | B 的 3 个边界（不含中心块） | B 的左侧边界消失 |
| 垂直隔一格 | A 上方 3 格 = B 下方 3 格 | B 的 3 个边界（不含中心块） | B 的下方边界消失 |
| 斜角隔一格 | 1 个位置 | B 的 1 个边界 | B 的一个角边界消失 |
| 距离 ≥ 3 格 | 无重叠 | 无 | 无影响 |

### 4.3 核心结论

- 直接相邻时最严重：B 的中心块被误删，视觉上 B 的队列预览"消失"
- 隔一格时：只有边界被误删，中心块保留，视觉上 B 的预览"缺了一边"
- 用户截图中的现象（中心块消失）对应水平/垂直直接相邻的情况

---

## 五、修复方案详细设计（方案二增强版）

### 5.1 修改目标

`RemoveExecutingPreview` 的耕地分支：清理每个 pos 前检查该 pos 是否被其他 `tillQueueTileGroups` 占用。

### 5.2 精确实现逻辑

```csharp
// 耕地：清除关联的所有 tile
if (executingTileGroups.TryGetValue(cellPos, out var tilePositions))
{
    if (queuePreviewTilemap != null)
    {
        foreach (var pos in tilePositions)
        {
            // 🔴 补丁004V4：检查 pos 是否被其他队列预览占用
            bool isOccupiedByOtherQueue = false;
            foreach (var kvp in tillQueueTileGroups)
            {
                if (kvp.Value.Contains(pos))
                {
                    isOccupiedByOtherQueue = true;
                    break;
                }
            }
            
            if (isOccupiedByOtherQueue)
            {
                // 被占用 → 不清空，保留队列预览的 tile
                // tile 已经是队列预览写入的，无需重新填充
            }
            else
            {
                // 不被占用 → 安全清空
                queuePreviewTilemap.SetTile(pos, null);
            }
        }
    }
    executingTileGroups.Remove(cellPos);
    return;
}
```

### 5.3 为什么不需要"重新填充"

关键洞察：当 B 入队时，`AddQueuePreview(B)` 已经在 `queuePreviewTilemap` 上写入了 B 的 tile。如果 A 和 B 的 tile 位置重叠，B 的 tile 已经覆盖了 A 的 tile。所以 `RemoveExecutingPreview(A)` 清理时，该位置上的 tile 实际上已经是 B 的了——只要不清空就行。

但有一个边界情况：`PromoteToExecutingPreview(A)` 时，A 的位置列表从 `tillQueueTileGroups` 移到了 `executingTileGroups`。此时 B 入队，B 的 `AddQueuePreview` 调用 `GetPreviewTiles` 时传入 `queuePreviewPositions`（不含 A，因为 A 已被 Promote 移除）。但 A 的实际耕地还没落地（还在动画中），所以 B 的预览计算不知道 A 的存在——这可能导致 B 的边界计算不完全准确。不过这是 R4 的已知限制，R1 修复后不会更差。

### 5.4 性能考量

用户明确说"不需要遍历整个队列，受影响的就是 A 周围 1+8 的那 8 个位置"。当前实现中 `tilePositions` 最多 9 个位置（1 中心 + 8 边界），对每个位置遍历 `tillQueueTileGroups`（通常 0~5 个条目），总计最多 9 × 5 = 45 次 `Contains` 检查。性能完全可接受。

---

## 六、正确性属性（新增）

| 编号 | 属性 | 验证方式 |
|------|------|---------|
| CP-V4-1 | RemoveExecutingPreview 清理耕地时，不清除被其他 tillQueueTileGroups 占用的位置 | 代码审查 |
| CP-V4-2 | RemoveExecutingPreview 清理耕地时，不被占用的位置正常清空 | 代码审查 |
| CP-V4-3 | 浇水和种子分支不受影响（无 1+8 重叠问题） | R5/R6 审查已确认 |

---

## 七、涉及文件汇总

| 文件 | 修改内容 |
|------|---------|
| `FarmToolPreview.cs` | `RemoveExecutingPreview` 耕地分支增加占用检查 |

仅需修改 1 个方法中的 1 个分支，改动量极小。
