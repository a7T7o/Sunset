# 补丁004V2 预览情况矩阵分析

> 基于用户四点纠正 + 代码事实验证
> 创建时间：2026-02-21

---

## 一、用户四点纠正总结（代码事实验证）

### 纠正1：WASD 不中断动画，问题是执行状态被清空

代码事实链：
1. WASD → `ClearActionQueue()` → `_pendingTileUpdate = null` + `_currentProcessingRequest = default` + `_isExecutingFarming = false`
2. `ToolActionLockManager.ForceUnlock()` 只解锁输入锁，不停止动画
3. 动画继续播放 → Update 中 `_pendingTileUpdate != null` 条件不满足 → tile 创建不触发
4. 动画完成 → `OnFarmActionAnimationComplete` → `_pendingTileUpdate` 已是 null → 兜底不执行
5. `RemoveExecutingPreview(default.cellPos)` 即 `RemoveExecutingPreview((0,0,0))` → 找不到实际位置 → 执行预览永远残留

结论：✅ 完全确认。`ClearActionQueue` 必须区分"正在执行的动画操作"和"队列中等待的操作"。

### 纠正2：需结合纠正1重新全面分析

结论：✅ 本文档即为重新分析产物。

### 纠正3：三层结构独立处理 + 完整情况矩阵

核心要点：
- ghost 预览层：所有情况都显示（包括已有耕地位置显示红色）
- 队列预览层与实际耕地层互斥且不可逆（只能队列→实际，不能反过来）
- "预览加实际等于最终内容"原则
- tile 不可分割（`borderLR` 是一张完整图片）

结论：✅ 需要创建完整情况矩阵（见下文）。

### 纠正4：执行 = 动画开始的瞬间，导航途中 = 前置行为

代码事实：
- 当前 `PromoteToExecutingPreview` 在 `ProcessNextAction` 出队时调用
- 远距离操作此时还在导航中，动画还没开始
- 导航途中被 WASD 打断 → 操作应随队列一起清空，不应被保护

结论：✅ `PromoteToExecutingPreview` 应从 `ProcessNextAction` 移到 `ExecuteFarmAction`。

---

## 二、三层预览架构定义

| 层级 | 名称 | Tilemap | 行为 | 清除时机 |
|------|------|---------|------|---------|
| 第一层 | Ghost 预览 | `ghostTilemap` | 每帧跟随鼠标，显示"如果在此锄地会怎样" | 每帧清除重绘 |
| 第二层 | 队列预览 | `queuePreviewTilemap` | 入队时创建，静态显示 | WASD/ESC 清空队列时清除 |
| 第三层 | 执行预览 | `queuePreviewTilemap`（复用） | 动画开始时从队列预览提升 | 动画完成后清除（tile 已落地） |

关键规则：
- Ghost 预览和队列预览是显示逻辑，不影响实际耕地数据
- 队列预览 → 执行预览是单向不可逆的
- 执行预览 → 实际耕地是通过数据层驱动的（`TillAt` → `UpdateBorderAt`）

---

## 三、技术限制：Tile 不可分割

`borderLR` 是一张完整的 Sprite 图片，包含左右两边的边界线条。不能只显示其中的 R 部分。

这意味着：当一个位置的 tile 需要从 `borderL` 变成 `borderLR` 时，ghost 预览层必须显示完整的 `borderLR`，而实际层上已有 `borderL`。两层叠加会产生视觉冲突。


### 解决方案：Ghost 层显示"最终结果"，差异位置临时遮盖实际层

原则："预览 + 实际 = 最终内容"

具体做法：
1. Ghost 预览在差异位置显示的是"最终 tile"（如 `borderLR`），不是"差异部分"
2. 差异位置的实际层 tile（如 `borderL`）需要被 ghost 层视觉遮盖
3. Ghost 层的 Sorting Order 高于实际层，自然遮盖
4. Ghost 层使用 shader 叠加色（绿色/红色）表示状态

这样玩家看到的就是：ghost 层的 `borderLR`（带绿色叠加）覆盖了实际层的 `borderL`，视觉上就是"如果锄地后这里会变成 LR"。

前提条件：ghostTilemap 的 Sorting Order 必须高于 farmlandBorderTilemap。

---

## 四、Ghost 预览情况矩阵（耕地 1+8）

### 符号定义

- `C` = 中心块（`centerTileUnfertilized`）
- `B_X` = 边界 tile（X = 方向组合，如 `B_L`、`B_R`、`B_LR`、`B_U`、`B_D` 等）
- `S_XY` = 阴影 tile（XY = 斜角方向）
- `∅` = 无 tile（null）
- `P` = 预览位置（鼠标所在格子）
- `A` = 已有耕地位置

### 场景1：空地上耕地（周围无耕地）

```
布局：P=(0,0)，周围8格全空

GetPreviewTiles 返回：
  P(0,0)  = C
  (-1,1)  = S_RD    (0,1)  = B_D    (1,1)  = S_LD
  (-1,0)  = B_R                      (1,0)  = B_L
  (-1,-1) = S_RU    (0,-1) = B_U    (1,-1) = S_LU

实际 tilemap：全部 ∅
差异化结果：全部 ≠ ∅ → ghost 显示完整 1+8
视觉效果：完整的耕地预览（带绿色叠加）✅
```

### 场景2：水平相邻（A 在左，P 在右，直接相邻）

```
布局：A=(-1,0) 已有耕地，P=(0,0) 预览位置

A 存在时实际 tilemap 状态：
  A(-1,0) = C（中心块）
  (-2,1)  = S_RD    (-1,1) = B_D    (0,1)  = S_LD
  (-2,0)  = B_R                      (0,0)  = B_L  ← P 位置当前是 B_L
  (-2,-1) = S_RU    (-1,-1)= B_U    (0,-1) = S_LU

GetPreviewTiles(P=(0,0)) 返回：
  P(0,0)  = C（中心块，覆盖原来的 B_L）
  (-1,1)  = CalculateBorderTileAt → 检查邻居：D=A=true, 其他... → B_D（不变）
  (0,1)   = B_D
  (1,1)   = S_LD
  (-1,0)  = A 是中心块 → CalculateBorderTileAt 返回 null（中心块不需要边界）
  (1,0)   = B_L
  (-1,-1) = CalculateBorderTileAt → 检查邻居：U=A=true, 其他... → B_U（不变）
  (0,-1)  = B_U
  (1,-1)  = S_LU

差异化对比：
  P(0,0)：预览=C，实际=B_L → ≠ → ghost 显示 C ✅
  (-1,1)：预览=B_D，实际=B_D → = → 跳过 ✅
  (0,1)：预览=B_D，实际=S_LD → ≠ → ghost 显示 B_D（覆盖旧阴影）✅
  (1,1)：预览=S_LD，实际=∅ → ≠ → ghost 显示 S_LD ✅
  (-1,0)：预览=null，实际=C → 中心块返回 null，跳过（kvp.Value == null continue）✅
  (1,0)：预览=B_L，实际=∅ → ≠ → ghost 显示 B_L ✅
  (-1,-1)：预览=B_U，实际=B_U → = → 跳过 ✅
  (0,-1)：预览=B_U，实际=S_LU → ≠ → ghost 显示 B_U（覆盖旧阴影）✅
  (1,-1)：预览=S_LU，实际=∅ → ≠ → ghost 显示 S_LU ✅

视觉效果：ghost 正确显示变化部分，A 的中心块和未变化的边界不被覆盖 ✅
```

### 场景3：水平隔一格（A 在左，P 在右，中间隔一格 M）

```
布局：A=(-1,0) 已有耕地，P=(1,0) 预览位置，M=(0,0) 中间空地

A 存在时 M=(0,0) 在实际 tilemap 上：farmlandBorderTilemap 有 B_L

GetPreviewTiles(P=(1,0)) 计算 M=(0,0)：
  CalculateBorderTileAt(M, predicate)
  M 不是中心块（predicate(M) = IsCenterBlock(M) = false）
  检查 M 的邻居中心块：
    L=(-1,0)=A → IsCenterBlock=true → hasL=true
    R=(1,0)=P → predicate=true → hasR=true
    U=(0,1) false, D=(0,-1) false
  count=2, hasL && hasR → borderLR

差异化对比：
  M(0,0)：预览=B_LR，实际=B_L → ≠ → ghost 显示 B_LR

视觉效果：ghost 层显示 B_LR（带绿色叠加），覆盖实际层的 B_L
玩家看到的是"最终结果"：这里会变成 LR 边界 ✅

⚠️ 关键：ghost 层 Sorting Order 必须高于 farmlandBorderTilemap，否则两层叠加会视觉冲突
```

### 场景4：斜角相邻（A 在左下，P 在右上，直接斜角）

```
布局：A=(-1,-1) 已有耕地，P=(0,0) 预览位置

A 存在时实际 tilemap 状态（A 的 1+8）：
  A(-1,-1) = C
  (-2,0)  = S_RD    (-1,0) = B_D    (0,0)  = S_LD  ← P 位置当前是 S_LD
  (-2,-1) = B_R                      (0,-1) = B_L
  (-2,-2) = S_RU    (-1,-2)= B_U    (0,-2) = S_LU

GetPreviewTiles(P=(0,0)) 计算：
  P(0,0) = C（覆盖原来的 S_LD）
  
  (-1,1)：邻居中心块检查 → 无 → 斜角检查：LD=A? 不是（A=(-1,-1)，LD of (-1,1) = (-2,0)）
           → 实际上 (-1,1) 的 RD = (0,0) = P = true → S_RD? 需要看完整逻辑
  (-1,0)：邻居中心块：D=(-1,-1)=A=true, R=(0,0)=P=true → hasD=true, hasR? 
           不对，(-1,0) 的邻居：U=(-1,1) false, D=(-1,-1)=A=true, L=(-2,0) false, R=(0,0)=P=true
           count=2, hasD && hasR → 没有这个组合... 
           实际上 SelectBorderTile 的逻辑是：hasU/D/L/R 的组合
           hasD=true, hasR=true → borderDR? 需要确认 SelectBorderTile 的具体映射

  (0,-1)：邻居中心块：U=(0,0)=P=true, L=(-1,-1)=A=true
           hasU=true, hasL=true → borderUL

差异化对比：
  P(0,0)：预览=C，实际=S_LD → ≠ → ghost 显示 C ✅
  (-1,0)：预览=B_DR（假设），实际=B_D → ≠ → ghost 显示 B_DR ✅
  (0,-1)：预览=B_UL，实际=B_L → ≠ → ghost 显示 B_UL ✅

视觉效果：ghost 正确显示最终结果，覆盖实际层的旧 tile ✅
```

### 场景5：鼠标在已有耕地上（canTill = false）

```
布局：A=(0,0) 已有耕地，鼠标在 A 上

当前代码行为：
  canTill = false（CanTillAt 返回 false，已耕作）
  → if (canTill && ...) 不进入
  → ghostTilemap 上不放任何 tile
  → cursorRenderer.enabled = false（耕地模式不显示光标）
  → previewOverlayMaterial 设置红色叠加色，但 ghostTilemap 上没有 tile → 无处叠加
  → 结果：什么都不显示 ❌

用户期望：应该显示红色反馈（表示"这里不能再锄地"）

修复方向：canTill = false 时，仍然在 ghostTilemap 上放置当前位置的实际 tile（或一个标记 tile），
让 shader 叠加色有载体可以显示红色。或者启用 cursorRenderer 显示红色方框。
```

### 场景6：批量操作 — 两个相邻位置入队

```
布局：先入队 A=(0,0)，再入队 B=(1,0)

A 入队时 AddQueuePreview：
  ghostTileData 包含 A 的 1+8 差异 tile
  其中 (1,0) 位置放了 B_L（A 的右边界）

B 入队时 AddQueuePreview：
  ghostTileData 包含 B 的 1+8 差异 tile
  其中 (0,0) 位置放了 C（B 的中心块覆盖了 A 的中心块？不对，A 已经是 C）
  (1,0) 位置放了 C（B 的中心块）
  (0,0) 位置：B 的 GetPreviewTiles 计算时 A 还没有实际耕作
    → predicate 只假装 B=(1,0) 已耕作，不知道 A=(0,0) 也要耕作
    → (0,0) 的邻居中心块：只有 R=(1,0)=B=true
    → 但 A=(0,0) 实际上也会被耕作！

问题：GetPreviewTiles 的 predicate 只假装一个位置已耕作，不考虑队列中其他位置。
这导致 B 的预览计算不知道 A 也会被耕作，边界计算不准确。

影响范围：
  - B 的 ghost 预览在计算时，A 还没入队（ghost 是实时的，只看当前鼠标位置）
  - 但 B 入队时复制的 ghostTileData 是基于"只有 B 耕作"的假设
  - 实际上 A 和 B 都会耕作，最终边界应该不同

这是一个已知限制：ghost 预览是单点计算，不考虑队列中其他位置。
队列预览之间可能存在 tile 覆盖（后入队的覆盖先入队的边界 tile）。
实际落地时通过 UpdateBorderAt 重新计算，结果是正确的。
预览阶段的不准确是可接受的（视觉近似）。
```

---

## 五、V1 版本遗留问题汇总

基于代码事实和用户四点纠正，V1 版本（当前代码）存在以下问题：

| 编号 | 问题 | 严重程度 | 根因 |
|------|------|---------|------|
| P1 | WASD 中断后动画播完不创建耕地 + 执行预览残留 | 严重 | `ClearActionQueue` 清空了 `_pendingTileUpdate` 和 `_currentProcessingRequest` |
| P2 | `PromoteToExecutingPreview` 时机过早 | 严重 | 在 `ProcessNextAction` 出队时调用，导航途中就被保护 |
| P3 | 鼠标在已有耕地上无任何视觉反馈 | 中等 | `canTill=false` 时 ghostTilemap 不放 tile，shader 叠加色无载体 |
| P4 | Ghost 层与实际层 tile 叠加可能视觉冲突 | 低 | 需确认 ghostTilemap Sorting Order 是否高于 farmlandBorderTilemap |
| P5 | 批量操作时队列预览边界不考虑其他队列位置 | 低（已知限制） | GetPreviewTiles predicate 只假装单点耕作 |

---

## 六、V2 修复方案概要

### 修复 P1：ClearActionQueue 保护正在执行的操作

`ClearActionQueue` 在有动画正在执行时（`_isExecutingFarming = true`），不清空 `_pendingTileUpdate`、`_currentProcessingRequest`、`_isExecutingFarming`。只清空队列和队列预览。

### 修复 P2：PromoteToExecutingPreview 移到 ExecuteFarmAction

从 `ProcessNextAction` 移到 `ExecuteFarmAction` 的开头。这样导航途中的操作仍在队列预览中，WASD 打断时会被正常清空。

### 修复 P3：canTill=false 时显示红色反馈

两个方案：
- 方案 A：在 ghostTilemap 上放置当前位置的实际 tile 作为载体，让 shader 显示红色
- 方案 B：启用 cursorRenderer 显示红色方框（更简单）

推荐方案 B：简单直接，不需要修改 ghost tile 逻辑。

### 修复 P4：确认 Sorting Order

检查 ghostTilemap 和 farmlandBorderTilemap 的 Sorting Order，确保 ghost 在上层。

### P5：暂不处理（已知限制）

批量预览的边界不准确是可接受的视觉近似。实际落地时 UpdateBorderAt 会重新计算正确结果。
