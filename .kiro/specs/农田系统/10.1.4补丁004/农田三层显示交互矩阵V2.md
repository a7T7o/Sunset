# 农田三层显示详细交互矩阵 V2

> 创建时间：2026-02-21
> 工作区：10.1.4补丁004
> 版本：V2（修正 V1 的"tile 不可分割"错误前提）
> 核心原则：**预览只显示增量**（预览 + 实际 = 最终效果）

---

## 🔴 V1 → V2 核心修正

V1 文档基于一个错误前提："tile 是不可分割的整体图片（`B_LR` 是一张完整 Sprite），不能只显示其中的 R 部分"。

**事实**：tile 资源是按方向组合独立存在的。项目中有完整的 16 种边界 tile + 4 种阴影 tile：

| 方向数 | 可用 tile |
|--------|----------|
| 单方向 | `B_U`, `B_D`, `B_L`, `B_R` |
| 双方向（对边） | `B_UD`, `B_LR` |
| 双方向（相邻） | `B_UL`, `B_UR`, `B_DL`, `B_DR` |
| 三方向 | `B_UDL`, `B_UDR`, `B_ULR`, `B_DLR` |
| 四方向 | `B_UDLR` |
| 阴影 | `S_LU`, `S_RU`, `S_LD`, `S_RD` |

**`B_LR` 就是 `B_L` + `B_R` 的合成**，可以拆开。预览层完全可以只显示增量方向的 tile。

---

## 一、三层定义与职责（与 V1 一致）

| 层级 | Tilemap | 内容 | 生命周期 |
|------|---------|------|---------|
| 实际耕地层 | `farmlandCenterTilemap` + `farmlandBorderTilemap` | 真实耕地数据 | 永久 |
| 队列预览层 | `queuePreviewTilemap` | 已入队等待执行的操作预览 | 入队→动画完成 |
| Ghost 预览层 | `ghostTilemap` | 鼠标跟随预览 | 每帧清除重绘 |

---

## 二、边界计算引擎原理（代码事实）

### 2.1 `GetPreviewTiles(layerIndex, centerPos)` 做了什么

1. 构造 predicate：`pos == centerPos ? true : IsCenterBlock(layerIndex, pos)`
2. 中心块：直接放 `centerTileUnfertilized`
3. 周围8格：每格调用 `CalculateBorderTileAt(pos, predicate)`

### 2.2 `CalculateBorderTileAt` 做了什么

1. 该位置是中心块 → 返回 `null`
2. 检查8邻居是否是中心块
3. 四正方向有中心块 → `SelectBorderTile(hasU, hasD, hasL, hasR)` → 返回组合 tile
4. 四正方向都没有但斜角有 → `SelectShadowTile` → 返回阴影 tile
5. 都没有 → 返回 `null`

### 2.3 `SelectBorderTile` 的方向组合映射

根据 `(hasU, hasD, hasL, hasR)` 四个 bool 值，直接映射到对应的组合 tile。
例如 `hasL=true, hasR=true` → `borderLR`。

### 2.4 关键理解：predicate 只假装一个位置

`GetPreviewTiles` 返回的是"如果 P 也耕作后的最终状态"。

---

## 三、核心问题：当前代码的差异化过滤不够

### 3.1 当前代码做了什么（UpdateHoePreview）

```csharp
foreach (var kvp in previewTiles)
{
    if (kvp.Value == null) continue;
    TileBase actualTile;
    if (kvp.Key == cellPos)
        actualTile = actualCenterTilemap?.GetTile(kvp.Key);
    else
        actualTile = actualBorderTilemap?.GetTile(kvp.Key);
    if (kvp.Value == actualTile) continue;  // 相同则跳过
    ghostTilemap.SetTile(kvp.Key, kvp.Value);
}
```

逻辑：预览 tile ≠ 实际 tile → ghost 显示预览 tile（最终状态）。

### 3.2 问题所在

以场景3（水平隔一格）的 M 位置为例：
- 实际层：`B_L`（M 左边有 A）
- 预览最终状态：`B_LR`（M 左边有 A，右边有 P）
- 当前代码：`B_LR ≠ B_L` → ghost 显示 `B_LR`

但 `B_LR` 包含了 L 方向（已存在）和 R 方向（新增）。ghost 层显示 `B_LR` 意味着 L 部分也被染绿了，而 L 部分并不是新增的。

### 3.3 正确的做法：增量计算

既然 tile 可拆分，正确的做法是：
1. 解析实际 tile 的方向集合：`B_L` → `{L}`
2. 解析预览 tile 的方向集合：`B_LR` → `{L, R}`
3. 计算增量方向：`{L, R} - {L}` = `{R}`
4. ghost 层显示增量 tile：`B_R`

玩家看到的效果：实际层 `B_L` + ghost 层 `B_R`（绿色）= 视觉上等于 `B_LR`，且只有 R 部分是绿色的。

### 3.4 阴影 tile 的特殊处理

阴影 tile 不存在方向组合（每个阴影只有一个方向），所以：
- 实际层有 `S_LD`，预览是 `S_RU` → 这是完全替换，不是增量
- ghost 显示 `S_RU` 覆盖实际层的 `S_LD` → 需要 Sorting Order 覆盖（这里仍然需要覆盖机制）

### 3.5 中心块的处理

中心块位置（P 本身）：
- 实际层可能有边界 tile（如 `B_L`）或阴影 tile（如 `S_LD`）
- 预览是 `C`（中心块）
- 这是完全替换（从边界/阴影变成中心块），ghost 显示 `C` 覆盖实际层 → 需要 Sorting Order 覆盖

---

## 四、场景逐一分析（基于正确的"可拆分"理解）

### 符号约定

- `C` = 中心块 tile
- `B_X` = 边界 tile（X = 方向组合）
- `S_XY` = 阴影 tile
- `∅` = 无 tile
- `A` = 已有耕地，`P` = 预览位置，`M` = 中间位置
- 🟢 = 增量 tile（ghost 应该显示的）
- 🔴 = 当前代码错误显示的（最终 tile 而非增量）
- ⭕ = 覆盖替换（非增量，需要 Sorting Order 覆盖）

### 场景1：空地上耕地（周围无耕地）

```
布局：P=(0,0)，周围8格全空
```

| 位置 | 预览 tile | 实际 tile | 增量分析 | ghost 应显示 |
|------|-----------|----------|---------|-------------|
| P(0,0) | `C` | `∅` | 全新 | 🟢 `C` |
| (-1,1) | `S_RD` | `∅` | 全新 | 🟢 `S_RD` |
| (0,1) | `B_D` | `∅` | 全新 | 🟢 `B_D` |
| (1,1) | `S_LD` | `∅` | 全新 | 🟢 `S_LD` |
| (-1,0) | `B_R` | `∅` | 全新 | 🟢 `B_R` |
| (1,0) | `B_L` | `∅` | 全新 | 🟢 `B_L` |
| (-1,-1) | `S_RU` | `∅` | 全新 | 🟢 `S_RU` |
| (0,-1) | `B_U` | `∅` | 全新 | 🟢 `B_U` |
| (1,-1) | `S_LU` | `∅` | 全新 | 🟢 `S_LU` |

**结论：空地场景，实际层全空，所有 tile 都是全新增量。当前代码行为正确。** ✅

---

### 场景2：水平直接相邻（A 在左，P 在右，间距0格）

```
布局：A=(-1,0) 已有耕地，P=(0,0) 预览位置
```

**A 的实际层 1+8：**

| 位置 | 实际 tile | 说明 |
|------|----------|------|
| A(-1,0) | `C` (center层) | A 的中心块 |
| (-2,1) | `S_RD` | A 的右下阴影 |
| (-1,1) | `B_D` | A 的下边界 |
| (0,1) | `S_LD` | A 的左下阴影 |
| (-2,0) | `B_R` | A 的右边界 |
| (0,0)=P | `B_L` (border层) | A 的左边界（P 位置） |
| (-2,-1) | `S_RU` | A 的右上阴影 |
| (-1,-1) | `B_U` | A 的上边界 |
| (0,-1) | `S_LU` | A 的左上阴影 |

**GetPreviewTiles(P=(0,0)) 计算结果 + 增量分析：**

| 位置 | 预览 tile | 实际 tile | 方向差集 | ghost 应显示 | 当前代码显示 | 正确？ |
|------|-----------|----------|---------|-------------|-------------|--------|
| P(0,0) | `C` | `B_L` (border层) | 完全替换 | ⭕ `C`（覆盖） | `C` | ✅ |
| (-1,1) | `B_D` | `B_D` | 无差异 | 跳过 | 跳过 | ✅ |
| (0,1) | `B_D` | `S_LD` | 完全替换（阴影→边界） | ⭕ `B_D`（覆盖） | `B_D` | ✅ |
| (1,1) | `S_LD` | `∅` | 全新 | 🟢 `S_LD` | `S_LD` | ✅ |
| (-1,0)=A | `null` | `C` (center层) | 跳过（null） | 跳过 | 跳过 | ✅ |
| (1,0) | `B_L` | `∅` | 全新 | 🟢 `B_L` | `B_L` | ✅ |
| (-1,-1) | `B_UR` | `B_U` | `{U,R}-{U}`=`{R}` | 🟢 `B_R` | 🔴 `B_UR` | ❌ |
| (0,-1) | `B_U` | `S_LU` | 完全替换（阴影→边界） | ⭕ `B_U`（覆盖） | `B_U` | ✅ |
| (1,-1) | `S_LU` | `∅` | 全新 | 🟢 `S_LU` | `S_LU` | ✅ |

**🔴 关键错误位置：(-1,-1)**

- 实际层已有 `B_U`（A 的上边界）
- 预览最终状态是 `B_UR`（A 在下方 + P 在右方）
- 增量 = `{U,R} - {U}` = `{R}`
- ghost 应该只显示 `B_R`，但当前代码显示 `B_UR`
- 结果：U 部分被多余地染绿了

**结论：场景2 有1处增量计算错误。** ❌

---

### 场景3：水平隔一格（A 在左，P 在右，中间隔一格 M）

```
布局：A=(-1,0) 已有耕地，P=(1,0) 预览位置，M=(0,0) 中间空地
```

**A 的实际层（与本场景相关部分）：**

| 位置 | 实际 tile |
|------|----------|
| A(-1,0) | `C` (center层) |
| (0,0)=M | `B_L` (border层) |
| (-1,1) | `B_D` |
| (0,1) | `S_LD` |
| (-1,-1) | `B_U` |
| (0,-1) | `S_LU` |

**GetPreviewTiles(P=(1,0)) 计算结果 + 增量分析：**

| 位置 | 预览 tile | 实际 tile | 方向差集 | ghost 应显示 | 当前代码显示 | 正确？ |
|------|-----------|----------|---------|-------------|-------------|--------|
| P(1,0) | `C` | `∅` | 全新 | 🟢 `C` | `C` | ✅ |
| (0,1) | `S_LD` | `S_LD` | 无差异 | 跳过 | 跳过 | ✅ |
| (1,1) | `B_D` | `∅` | 全新 | 🟢 `B_D` | `B_D` | ✅ |
| (2,1) | `S_LD` | `∅` | 全新 | 🟢 `S_LD` | `S_LD` | ✅ |
| (0,0)=M | `B_LR` | `B_L` | `{L,R}-{L}`=`{R}` | 🟢 `B_R` | 🔴 `B_LR` | ❌ |
| (2,0) | `B_L` | `∅` | 全新 | 🟢 `B_L` | `B_L` | ✅ |
| (0,-1) | `S_LU` | `S_LU` | 无差异 | 跳过 | 跳过 | ✅ |
| (1,-1) | `B_U` | `∅` | 全新 | 🟢 `B_U` | `B_U` | ✅ |
| (2,-1) | `S_LU` | `∅` | 全新 | 🟢 `S_LU` | `S_LU` | ✅ |

**🔴 关键错误位置：M=(0,0)**

- 实际层已有 `B_L`（A 的左边界）
- 预览最终状态是 `B_LR`
- 增量 = `{L,R} - {L}` = `{R}`
- ghost 应该只显示 `B_R`，但当前代码显示 `B_LR`

**结论：场景3 有1处增量计算错误。** ❌

---

### 场景4：斜角直接相邻（A 在左下，P 在右上）

```
布局：A=(-1,-1) 已有耕地，P=(0,0) 预览位置
```

**A 的实际层（与 P 的 1+8 有交集的部分）：**

| 位置 | 实际 tile | 说明 |
|------|----------|------|
| A(-1,-1) | `C` (center层) | A 的中心块 |
| (-1,0) | `B_D` (border层) | A 的下边界（A 在 (-1,-1)，(-1,0) 在 A 上方） |
| (0,-1) | `B_L` (border层) | A 的左边界（(0,-1) 在 A 右方） |
| (0,0)=P | `S_LD` (border层) | A 的左下阴影 |

**GetPreviewTiles(P=(0,0)) 计算结果 + 增量分析：**

| 位置 | 预览 tile | 实际 tile | 方向差集 | ghost 应显示 | 当前代码显示 | 正确？ |
|------|-----------|----------|---------|-------------|-------------|--------|
| P(0,0) | `C` | `S_LD` (border层) | 完全替换 | ⭕ `C`（覆盖） | `C` | ✅ |
| (-1,1) | `S_RD` | `∅` | 全新 | 🟢 `S_RD` | `S_RD` | ✅ |
| (0,1) | `B_D` | `∅` | 全新 | 🟢 `B_D` | `B_D` | ✅ |
| (1,1) | `S_LD` | `∅` | 全新 | 🟢 `S_LD` | `S_LD` | ✅ |
| (-1,0) | `B_DR` | `B_D` | `{D,R}-{D}`=`{R}` | 🟢 `B_R` | 🔴 `B_DR` | ❌ |
| (1,0) | `B_L` | `∅` | 全新 | 🟢 `B_L` | `B_L` | ✅ |
| (-1,-1)=A | `null` | `C` (center层) | 跳过 | 跳过 | 跳过 | ✅ |
| (0,-1) | `B_UL` | `B_L` | `{U,L}-{L}`=`{U}` | 🟢 `B_U` | 🔴 `B_UL` | ❌ |
| (1,-1) | `S_LU` | `∅` | 全新 | 🟢 `S_LU` | `S_LU` | ✅ |

**🔴 关键错误位置：(-1,0) 和 (0,-1)**

**(-1,0) 位置：**
- 实际层 `B_D`（A 在下方）
- 预览最终 `B_DR`（A 在下方 + P 在右方）
- 增量 = `{D,R} - {D}` = `{R}`
- ghost 应显示 `B_R`，当前显示 `B_DR`

**(0,-1) 位置：**
- 实际层 `B_L`（A 在左方）
- 预览最终 `B_UL`（P 在上方 + A 在左方）
- 增量 = `{U,L} - {L}` = `{U}`
- ghost 应显示 `B_U`，当前显示 `B_UL`

**结论：场景4 有2处增量计算错误。** ❌

---

### 场景5：斜角隔一格（A 在左下，P 在右上，中间隔一格）

```
布局：A=(-1,-1) 已有耕地，P=(1,1) 预览位置
      A 的 1+8 范围：(-2,-2) 到 (0,0)
      P 的 1+8 范围：(0,0) 到 (2,2)
      交集：只有 (0,0)
```

**(0,0) 分析：**
- 实际层：`S_LD`（A 在 (0,0) 的左下斜角）
- 预览计算：(0,0) 的四正方向邻居都不是中心块，斜角有 A(LD) 和 P(RU)
- `SelectShadowTile` 优先级：LU > RU > LD > RD → hasRU=true → 返回 `S_RU`
- 预览 tile = `S_RU`，实际 tile = `S_LD`
- 阴影 tile 不存在方向组合拆分，这是完全替换
- ghost 显示 `S_RU` 覆盖 `S_LD` → 需要 Sorting Order 覆盖

**其他位置（P 的 1+8 中不与 A 交集的部分）：** 全部是全新 tile，无增量问题。

**结论：场景5 无增量计算错误。** ✅（阴影替换需要 Sorting Order 覆盖，但这不是增量问题）

---

### 场景6：鼠标在已有耕地上（canTill = false）

与 V1 分析一致：
- `canTill = false` → 不进入预览逻辑 → 什么都不显示
- 需要 designV3 模块 J 修复（红色反馈）

**结论：与增量计算无关，是功能缺失问题。** ❌（待修复）

---

### 场景7：批量操作 — 两个相邻位置先后入队

与 V1 分析一致：
- predicate 只假装单点，不考虑队列中其他位置
- 队列预览之间会互相覆盖
- 实际落地时 `UpdateBorderAt` 用真实数据重新计算，结果正确

**结论：已知限制，与增量计算无关。**

---

## 五、错误汇总

### 5.1 增量计算错误一览

| 场景 | 错误位置 | 实际 tile | 预览最终 tile | 当前 ghost | 正确 ghost | 增量差集 |
|------|---------|----------|-------------|-----------|-----------|---------|
| 场景2 | (-1,-1) | `B_U` | `B_UR` | `B_UR` | `B_R` | `{U,R}-{U}={R}` |
| 场景3 | M=(0,0) | `B_L` | `B_LR` | `B_LR` | `B_R` | `{L,R}-{L}={R}` |
| 场景4 | (-1,0) | `B_D` | `B_DR` | `B_DR` | `B_R` | `{D,R}-{D}={R}` |
| 场景4 | (0,-1) | `B_L` | `B_UL` | `B_UL` | `B_U` | `{U,L}-{L}={U}` |

### 5.2 错误模式总结

所有错误都是同一个模式：
1. 实际层已有边界 tile `B_X`（方向集合 `{X}`）
2. 预览最终状态是 `B_XY`（方向集合 `{X, Y}`）
3. 当前代码直接显示 `B_XY`（最终 tile），导致 X 方向被多余染绿
4. 正确做法：计算增量 `{X, Y} - {X} = {Y}`，ghost 只显示 `B_Y`

### 5.3 不受影响的情况

以下情况当前代码行为正确，不需要修改：

| 情况 | 原因 |
|------|------|
| 实际层为空（`∅`） | 全新 tile，无需增量计算 |
| 预览 tile = 实际 tile | 已被 `== actualTile` 跳过 |
| 阴影 tile 替换 | 阴影不存在方向组合，是完全替换，需要 Sorting Order 覆盖 |
| 中心块替换 | P 位置从边界/阴影变成中心块，是完全替换 |
| 预览 tile 为 null | 已被 `== null continue` 跳过 |

---

## 六、修复方案：增量差集计算

### 6.1 核心思路

在差异化过滤中，当预览 tile ≠ 实际 tile 且两者都是边界 tile 时，不直接显示预览 tile，而是计算方向差集，显示增量 tile。

### 6.2 方向解析

需要一个方法将 tile 引用解析为方向集合：

```
ParseDirections(TileBase tile) → (hasU, hasD, hasL, hasR)

例：
  borderL    → (false, false, true, false)
  borderLR   → (false, false, true, true)
  borderUR   → (true, false, false, true)
  borderUDLR → (true, true, true, true)
```

### 6.3 增量计算

```
实际方向 = ParseDirections(actualTile)
预览方向 = ParseDirections(previewTile)
增量方向 = 预览方向 AND NOT 实际方向（逐方向布尔运算）
增量 tile = SelectBorderTile(增量方向)
```

### 6.4 特殊情况处理

| 情况 | 处理 |
|------|------|
| 实际 tile 是阴影 | 不做增量计算，直接用预览 tile 覆盖（阴影→边界是完全替换） |
| 实际 tile 为空 | 不做增量计算，直接用预览 tile（全新） |
| 增量方向为空集 | 说明实际 tile 已包含所有预览方向，跳过（不应该发生，因为前面已经 == 判断过） |
| 实际 tile 是中心块 | 不做增量计算（中心块位置预览返回 null，已被跳过） |

### 6.5 伪代码

```
foreach (kvp in previewTiles):
    if kvp.Value == null: continue
    
    actualTile = GetActualTile(kvp.Key)
    if kvp.Value == actualTile: continue  // 无差异
    
    if actualTile == null:
        // 全新位置，直接显示预览 tile
        ghost.SetTile(kvp.Key, kvp.Value)
    elif IsShadowTile(actualTile):
        // 阴影→边界，完全替换（需要 Sorting Order 覆盖）
        ghost.SetTile(kvp.Key, kvp.Value)
    elif IsBorderTile(actualTile) && IsBorderTile(kvp.Value):
        // 边界→边界，计算增量
        actualDirs = ParseDirections(actualTile)
        previewDirs = ParseDirections(kvp.Value)
        deltaDirs = previewDirs AND NOT actualDirs
        deltaTile = SelectBorderTile(deltaDirs)
        if deltaTile != null:
            ghost.SetTile(kvp.Key, deltaTile)
    else:
        // 其他情况（如阴影→阴影替换），直接覆盖
        ghost.SetTile(kvp.Key, kvp.Value)
```

---

## 七、Sorting Order 覆盖机制（仍然需要）

即使实现了增量计算，以下情况仍然需要 Sorting Order 覆盖：

| 情况 | 原因 |
|------|------|
| P 位置：边界/阴影 → 中心块 | ghost 的 `C` 需要覆盖实际层的边界/阴影 |
| 阴影替换：`S_LD` → `S_RU` | ghost 的新阴影需要覆盖实际层的旧阴影 |
| 阴影→边界：`S_LD` → `B_D` | ghost 的边界需要覆盖实际层的阴影 |

层级关系要求不变：
```
ghostTilemap Sorting Order > farmlandBorderTilemap Sorting Order
```

---

## 八、总结

### 8.1 V1 → V2 核心变化

| 维度 | V1（错误） | V2（正确） |
|------|-----------|-----------|
| tile 可拆分性 | 不可分割 | 可拆分（每个方向组合都有独立资源） |
| 差异位置处理 | 显示最终 tile + Sorting Order 覆盖 | 计算增量 tile + 仅覆盖替换场景 |
| 已存在部分染绿 | "可接受的小瑕疵" | 不可接受，必须修复 |
| 修复复杂度 | 无需修复 | 需要增量差集计算逻辑 |

### 8.2 场景正确性判定

| 场景 | V1 判定 | V2 判定 | 错误数 |
|------|---------|---------|--------|
| 场景1：空地 | ✅ | ✅ | 0 |
| 场景2：水平直接相邻 | ✅ | ❌ | 1 |
| 场景3：水平隔一格 | ✅ | ❌ | 1 |
| 场景4：斜角直接相邻 | ✅ | ❌ | 2 |
| 场景5：斜角隔一格 | ✅ | ✅ | 0（阴影替换用覆盖） |
| 场景6：已有耕地上 | ❌ | ❌ | 功能缺失 |
| 场景7：批量操作 | 已知限制 | 已知限制 | — |

### 8.3 前提条件

| 条件 | 说明 | 用途 |
|------|------|------|
| ghostTilemap Sorting Order > farmlandBorderTilemap | 覆盖替换场景（中心块替换、阴影替换） | 仍然需要 |
| `ParseDirections` 方法 | 将 tile 引用解析为方向集合 | 增量计算的基础 |
| `SelectBorderTile` 公开访问 | 从增量方向集合生成增量 tile | 需要改为 public 或提供公开接口 |
