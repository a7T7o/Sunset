# 002执行002 审视报告 — 对 Gemini 锐评的事实核查

> 来源：`002执行002.md`（Gemini 对 V6 代码修复的锐评）
> 核查方式：逐条对照实际代码（本会话中 readCode 读取）
> 路径判断：🔴 路径 C（存在严重事实错误 + 代码方案有害）

---

## 一、锐评核心观点摘要

锐评声称 V6 代码修复"一模一样，什么都没有解决"，提出三大指控：

1. Bug Q（WASD 极限操作卡死）：HandleMovement 没有在最顶层拦截 `SetMovementInput`，玩家位移导致动画被腰斩
2. Bug V（Ghost 增量差集错误）：阴影 tile 导致 `IsBorderTile` 返回 false，跳过增量合并逻辑
3. Bug S（老旧红框）：`CreateGridSprite()` 只赋给了种子预览，没赋给锄头的 `cursorRenderer`

---

## 二、事实核查结果表

| 指控 | 锐评声明 | 代码事实 | 结论 |
|------|---------|---------|------|
| 指控1：HandleMovement 没拦截移动 | "它让玩家发生位移了" | HandleMovement 第454行：`wasExecuting` 检查存在。执行中不调用 ForceUnlock → lockManager.IsLocked 保持 true → 第476行进入锁定分支 → `SetMovementInput(Vector2.zero, false)` → 玩家不会移动 | ❌ 事实错误 |
| 指控2：阴影 tile 导致跳过增量 | "IsBorderTile 对阴影返回 false → 跳过增量" | UpdateHoePreview 第517行：阴影 tile 有独立分支 `else if (borderManager.IsShadowTile(actualTile))`，直接显示预览 tile（Sorting Order 覆盖）。不会"跳过"，而是走不同路径 | ❌ 事实错误 |
| 指控3：红方框没赋给锄头 cursorRenderer | "只赋给了种子预览" | UpdateHoePreview else 分支（第575行）：`cursorRenderer.enabled = true; UpdateCursor(layerIndex, cellPos);`。cursorRenderer 在 EnsureComponents 中初始化时使用 `CreateProceduralCursorSprite()`（16x16 白框），而非 `CreateGridSprite()`（32x32 方框） | ⚠️ 部分正确 |

---

## 三、逐条详细分析

### 指控1：WASD 极限操作 — ❌ 锐评完全错误

锐评的核心论点是"HandleMovement 让玩家发生位移了"。

实际代码执行链路（基于 readCode 确认）：

1. `ExecuteFarmAction` 第2475行：`_isExecutingFarming = true;`
2. `ExecuteFarmAction` 第2480行：`playerInteraction?.RequestAction(Crush);`
3. `RequestAction` → `PerformAction` → `StartAction` 第121行：`lockManager?.BeginAction();` → `IsLocked = true`
4. 下一帧用户按 WASD → `HandleMovement` 第454行：
   - `hasWASD = true`, `hasActiveQueue = true`（如果队列有内容）或 `_isProcessingQueue = true`
   - `wasExecuting = _isExecutingFarming` = `true`
   - `ClearActionQueue()` — 模块H保护：`_isExecutingFarming` 为 true 时保留执行状态
   - `if (!wasExecuting)` = false → 不调用 `CancelFarmingNavigation`，不调用 `ForceUnlock`
5. 继续往下到第474行：`lockManager.IsLocked` = `true`（因为没有 ForceUnlock）
6. 进入锁定分支：`SetMovementInput(Vector2.zero, false)` → 玩家不移动 → return

**结论：玩家在执行动画期间按 WASD，不会产生任何位移。动画不会被腰斩。锐评的分析完全错误。**

但有一个边界情况需要注意：如果队列为空且 `_isProcessingQueue = false`（即只有一个动作在执行，没有排队），那么 `hasActiveQueue = false`，WASD 中断分支不会进入。代码会直接走到 lockManager 检查，由于 `IsLocked = true`，仍然会被拦截。所以即使这种情况也是安全的。

### 指控2：阴影 tile 导致增量跳过 — ❌ 锐评完全错误

锐评声称：如果 c 层是阴影 tile，`IsBorderTile` 返回 false，导致"跳过所有增量差集合并逻辑"。

实际代码（UpdateHoePreview 第507-540行）有四个分支：

```
if (actualTile == null)           → 全新位置，直接显示
else if (IsShadowTile(actualTile)) → 阴影→边界，直接显示（Sorting Order 覆盖）
else if (IsBorderTile(actualTile) && IsBorderTile(kvp.Value)) → 边界→边界，增量差集
else                               → 其他情况，直接显示
```

阴影 tile 走的是第二个分支，不是"跳过"，而是"直接显示预览 tile"。这是正确的行为——阴影 tile 在视觉上会被 ghost 层的预览 tile 通过更高的 Sorting Order 覆盖，最终效果就是用户看到正确的预览。

**锐评把"走了不同分支"误解为"跳过了逻辑"。**

不过，这里确实存在一个真实问题（但不是锐评描述的那个）：当 c 层有边界 tile 时，增量差集只合并了 c 层和 b 层的方向。但如果 c 层没有 tile（`actualTile == null`），代码会去查 b 层（`queuePreviewTilemap`）。如果 b 层有 tile，`actualTile` 就变成了 b 层的 tile。然后代码走到 `kvp.Value == actualTile` 的相等检查——如果相等就跳过。

但如果 b 层的 tile 和预览 tile 不相等，代码走到四分支判断。此时 `actualTile` 是 b 层的 tile，如果它是边界 tile，就会进入增量差集分支。但这里只对比了这一个 tile 的方向，没有再去查 c 层（因为 c 层已经确认为 null）。这个逻辑是正确的——c 层为空意味着 c 层没有方向贡献。

**真正的 bug 在哪？** 用户在续21快照中描述的场景是：M=(0,0) 处 ghost 显示 UDL，但 U/D 已被队列预览覆盖，应只显示 L。这个 bug 的根因不是阴影 tile，而是增量差集在 c 层有边界 tile 时的合并逻辑。让我仔细推演：

场景：b=(1,0) 是耕地列，b 列上下都有队列预览。鼠标在 a=(-1,0)。
- GetPreviewTiles 计算 a 的 1+8 预览，M=(0,0) 是 a 的右邻居
- M 处的预览 tile 应该是 B_UDL（因为 M 的上下左都有"耕地"——上下来自队列预览，左来自 a 本身）
- 增量差集：c 层 M 处无 tile → 查 b 层 → b 层 M 处有 tile（来自 b 列队列预览的边界扩展）

等等，这里需要更仔细地推演。让我重新看代码逻辑：

UpdateHoePreview 中增量差集的完整路径：

```
// 第507行：先查 c 层
if (kvp.Key == cellPos)  // 中心块查 centerTilemap
    actualTile = actualCenterTilemap?.GetTile(kvp.Key);
else                      // 边界查 borderTilemap
    actualTile = actualBorderTilemap?.GetTile(kvp.Key);

// 第513行：c 层没有 → 查 b 层
if (actualTile == null && queuePreviewTilemap != null)
    actualTile = queuePreviewTilemap.GetTile(kvp.Key);

// 第516行：完全相同则跳过
if (kvp.Value == actualTile) continue;

// 四分支判断...
// 如果 actualTile 是边界 tile 且预览也是边界 tile → 增量差集
// 增量差集中：合并 c+b 方向
```

问题出在第513行：如果 c 层有 tile（比如 c 层 M 处有阴影 tile），代码不会查 b 层。然后走到阴影分支，直接显示预览 tile（B_UDL），不做增量。

但用户描述的场景是"c 层附近"才出现 bug。如果 M 处 c 层有阴影 tile（因为 M 紧邻 c 层耕地），那么：
- actualTile = 阴影 tile
- 走阴影分支 → 直接显示 B_UDL
- 但 b 层 M 处已经有队列预览的 B_UD（来自 b 列上下的队列预览）
- 所以 ghost 应该只显示 B_L（增量 = UDL - UD = L）
- 但代码走了阴影分支，没有做增量 → 显示了完整的 B_UDL

**这才是真正的 bug！阴影分支没有考虑 b 层已有的方向贡献！**

所以锐评的方向是对的（阴影 tile 确实导致了问题），但分析路径完全错误（不是"跳过增量"，而是"阴影分支没有对 b 层做增量"）。

### 指控3：红方框没赋给锄头 — ⚠️ 部分正确

锐评说 `CreateGridSprite()` 只赋给了种子预览，没赋给锄头的 `cursorRenderer`。

代码事实：
- `EnsureComponents` 第305行：`cursorRenderer` 初始化时用的是 `CreateProceduralCursorSprite()`（16x16 白色边框，内部透明）
- `EnsureComponents` 第358行：`gridSprite = CreateGridSprite()`（32x32 白色方框，内部半透明填充）
- `EnsureComponents` 第363行：`seedGridRenderer.sprite = gridSprite`（种子预览用 32x32）
- `UpdateHoePreview` else 分支第575行：`cursorRenderer.enabled = true; UpdateCursor(layerIndex, cellPos);`

所以锄头不可耕种时显示的确实是 16x16 的 `CreateProceduralCursorSprite`，而不是放置系统同款的 32x32 `CreateGridSprite`。

但锐评说"只赋给了种子预览"也不完全准确——`cursorRenderer` 从来就不是用 `CreateGridSprite` 的，它一直用的是 `CreateProceduralCursorSprite`。这不是"忘了赋值"，而是设计上就是两个不同的 sprite。

**真正的问题**：用户要求"放置系统同款红方框"，但当前 `cursorRenderer` 用的是旧的 16x16 白框。需要改为使用 `CreateGridSprite()`（32x32）并设置红色。

对比放置系统 `PlacementGridCell.CreateGridSprite()`：
- 32x32，borderWidth=2，白色边框+半透明填充
- 通过 `spriteRenderer.color` 设置颜色（validColor 绿色 / invalidColor 红色）

当前 FarmToolPreview 的 `CreateGridSprite()` 已经是 32x32 同款实现，但 `cursorRenderer` 没有使用它。

---

## 四、锐评提供的"强制替换代码"评估

### 第一段代码（HandleMovement 替换）— 🔴 有害

锐评的代码在 HandleMovement 最顶部加了：
```csharp
if (_isExecutingFarming)
{
    if (input.sqrMagnitude > 0.01f) ClearActionQueue();
    if (playerMovement != null) playerMovement.SetMovementInput(Vector2.zero, false);
    return;
}
```

问题：
1. 这段代码在 `_isExecutingFarming = true` 时直接 return，跳过了后面所有逻辑（包括 lockManager 缓存方向、autoNavigator 检查等）
2. 当前代码已经通过 lockManager 机制正确拦截了移动，不需要额外的顶层拦截
3. 锐评的代码会导致执行中按 WASD 时方向缓存丢失（lockManager.CacheDirection 不会被调用），动画完成后玩家不会朝缓存方向移动

### 第二段代码（UpdateHoePreview 替换）— ⚠️ 方向对但实现有问题

锐评的增量差集代码思路是对的（分别获取 c 层和 b 层 tile，合并方向后做差集），但：
1. 它把中心块和边界块混在一起处理（`kvp.Key == cellPos ? actualCenterTilemap : actualBorderTilemap`），忽略了中心块不需要增量差集
2. 它没有处理阴影 tile 的特殊情况
3. 它的 `cTile` 获取逻辑对中心块位置用了 `actualCenterTilemap`，对其他位置用了 `actualBorderTilemap`，但没有考虑 b 层的 tile 可能也需要参与相等性检查

### 第三段代码（else 分支红方框）— ✅ 方向正确

`cursorRenderer.sprite = gridSprite;` 这个改动方向是对的，但需要配合颜色设置。

---

## 五、真正需要修复的问题

基于代码事实核查，当前代码存在以下真实问题：

### 问题1：阴影分支未对 b 层做增量（用户续21报告的 bug）

UpdateHoePreview 第519行的阴影分支 `else if (borderManager.IsShadowTile(actualTile))` 直接显示预览 tile，没有检查 b 层（queuePreviewTilemap）是否已有方向贡献。

修复方案：阴影分支也需要查 b 层，如果 b 层有边界 tile，对 b 层方向做增量差集。

### 问题2：cursorRenderer 使用旧的 16x16 白框

UpdateHoePreview else 分支显示的是 `CreateProceduralCursorSprite()`（16x16 白框），不是放置系统同款的 `CreateGridSprite()`（32x32 方框）。

修复方案：else 分支中将 `cursorRenderer.sprite` 改为 `gridSprite`（已在 EnsureComponents 中创建），并设置红色。

### 问题3（非锐评指出）：designV6 中标注"已实施"的模块需要验证

designV6 标注模块 Q/V/N'/O'' 为"已实施"。基于代码核查：
- 模块 Q（绝对锁定）：✅ 确认已实施（wasExecuting 检查 + CancelFarmingNavigation 执行保护）
- 模块 V（增量差集合并 c+b）：⚠️ 部分实施（边界→边界分支已合并 c+b，但阴影分支遗漏）
- 模块 N'（b 层统一拦截）：✅ 确认已实施
- 模块 O''（Shader 染色三分支）：✅ 确认已实施

---

## 六、给 Gemini 的信息补充

1. `ToolActionLockManager` 的存在是关键——锐评完全忽略了这个组件。`BeginAction()` 在 `PlayerInteraction.StartAction` 中调用，`IsLocked = true` 后 HandleMovement 会进入锁定分支，`SetMovementInput(Vector2.zero, false)` 阻止玩家移动。这是已有的成熟机制，不需要在 HandleMovement 顶部额外加拦截。

2. 增量差集的四分支结构是有意设计的，不是"烂逻辑"。阴影分支的遗漏是一个真实 bug，但修复方式应该是在阴影分支内增加 b 层检查，而不是推翻整个结构。

3. `cursorRenderer` 和 `gridSprite` 是两个不同用途的组件。`cursorRenderer` 用于显示光标/方框，`gridSprite` 是种子预览的格子。修复方式是让 `cursorRenderer` 也使用 `gridSprite`，而不是锐评说的"忘了赋值"。

---

## 七、建议的执行方向

1. 修复阴影分支的 b 层增量遗漏（UpdateHoePreview 阴影分支增加 queuePreviewTilemap 检查）
2. 修复 cursorRenderer 使用 gridSprite + 红色（else 分支）
3. 不采纳锐评的 HandleMovement 替换代码（当前实现已正确）
4. 不采纳锐评的 UpdateHoePreview 整体替换（只需修复阴影分支）
