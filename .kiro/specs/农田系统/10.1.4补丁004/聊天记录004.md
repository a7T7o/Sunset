理解你的问题：建立耕地时，清理逻辑把预览队列中的内容（包括 B 层中心块）也一并删除了，导致显示异常。正确行为应该是：建立耕地后，对周围处于预览队列的内容做增量适配，B 层中心块应该保留。

我需要先读取相关文件来彻底厘清逻辑，然后给你交互矩阵和代码修改。

让我先读取 memory、现有交互矩阵、设计文档和相关代码。

memory 文件很长，我需要读取最新的会话记录和继承会话快照来了解当前进度。

好的，现在我需要读取当前的核心代码来理解清理逻辑和预览队列的增量处理。

现在我需要看 `RemoveExecutingPreview` 和 `RemoveQueuePreview` 来理解清理逻辑，以及 `GameInputManager` 中耕地建立后的清理流程。

现在我需要看 `GameInputManager` 中耕地建立后的回调流程，特别是 `OnFarmActionAnimationComplete` 和 `TillAt` 之后的处理。

好，我已经读完了所有相关代码。让我理清问题的本质。

从截图看，问题出在：建立耕地后，`RemoveExecutingPreview` 清除了该中心块关联的所有 tile（包括 `queuePreviewTilemap` 上属于其他队列预览的 tile），导致周围处于预览队列中的内容被错误删除。

让我确认一下 `tillQueueTileGroups` 的数据结构和清理逻辑的交互。

现在我完全理解了数据结构。让我看看 `ExecuteTillSoil` 来确认耕地建立后的完整流程。

现在让我看 `FarmTileManager.CreateTile` 和 `UpdateBorderAt` 来理解耕地建立后对周围 tile 的影响。

好，我已经完整读取了所有相关代码。现在彻底厘清问题。

---

## 问题根因分析

从截图看，问题发生在这个场景：

1. 玩家连续入队多块耕地（比如 A、B、C 从左到右）
2. A 执行完毕，`OnFarmActionAnimationComplete` → `RemoveExecutingPreview(A.cellPos)`
3. `RemoveExecutingPreview` 从 `executingTileGroups[A]` 取出 A 关联的所有 tile 位置，逐一 `queuePreviewTilemap.SetTile(pos, null)` 清除

问题在于：A 的 `executingTileGroups` 中记录的 tile 位置（比如 A 的右边界位置）可能和 B 的 `tillQueueTileGroups` 中的 tile 位置重叠。A 建立耕地后，`RemoveExecutingPreview` 把 `queuePreviewTilemap` 上那个位置的 tile 清空了，但那个位置上现在放的是 B 的队列预览 tile。

更具体地说：

- A 入队时，`AddQueuePreview` 计算 A 的 1+8，其中 A 右边 `(A.x+1, A.y)` 放了 `B_L`
- B 入队时，`AddQueuePreview` 计算 B 的 1+8，其中 B 的中心 `(B.x, B.y)` = `(A.x+1, A.y)` 放了中心块 `C`，覆盖了之前的 `B_L`
- A 提升为执行预览时，`executingTileGroups[A]` 包含了 `(A.x+1, A.y)` 这个位置
- A 执行完毕，`RemoveExecutingPreview(A)` 清除 `(A.x+1, A.y)` → 把 B 的中心块也清掉了

这就是你看到的现象：耕地建立后，旁边队列预览的中心块消失了。

---

## 解决方案

`RemoveExecutingPreview` 在清除 tile 时，不能无脑清空，必须检查该位置是否还被其他队列预览或执行预览占用。如果被占用，应该保留（不清除），或者用占用方的 tile 重新填充。

核心原则：**清除时做增量适配——只清除属于自己且不被他人占用的 tile**。

具体做法：

对于 `executingTileGroups[cellPos]` 中的每个 `pos`：
1. 检查 `pos` 是否出现在其他 `tillQueueTileGroups` 的值列表中
2. 检查 `pos` 是否出现在其他 `executingTileGroups` 的值列表中
3. 如果被占用 → 不清除（保留当前 tile）
4. 如果不被占用 → 但实际耕地层（c 层）现在有 tile 了（因为 A 刚建立了耕地，`OnCenterBlockPlaced` 已经更新了 `farmlandBorderTilemap`）→ 也应该清除（因为实际层已经有了，不需要预览层重复显示）

等等，这里还有一个更深层的问题：A 建立耕地后，`OnCenterBlockPlaced` 会调用 `UpdateBordersAround`，这会更新 A 周围的实际 `farmlandBorderTilemap`。这意味着 B 的队列预览中某些 tile 可能已经和实际层一致了（不再需要预览），但也可能变得不一致了（需要重新计算增量）。

所以正确的做法是：**耕地建立后，对周围仍在队列中的预览做增量重算**。

---

## 交互矩阵

| 场景 | A 执行完毕后 | B 在队列中 | 位置 P 的处理 |
|------|------------|-----------|-------------|
| P 只属于 A 的 1+8，不属于 B | 清除 P 上的 tile | 不影响 | 直接 `SetTile(P, null)` |
| P 同时属于 A 和 B 的 1+8 | A 要清除 P | B 还需要 P | 不能直接清除，需要用 B 的 tile 重新填充 |
| P 是 B 的中心块位置 | A 的边界覆盖了 B 的中心块 | B 的中心块被清掉 | 必须保留 B 的中心块 |
| P 在实际层已有正确 tile | A 建立后 `UpdateBordersAround` 已更新 | B 的预览可能过时 | 需要重算 B 的增量 |

简化方案（最稳妥）：

`RemoveExecutingPreview` 清除 A 的 tile 后，遍历所有仍在队列中的 `tillQueueTileGroups`，对每个受影响的队列预览重新计算并刷新 tile。

但这个方案改动量大。更精准的方案是：

**在 `RemoveExecutingPreview` 中，对每个要清除的位置 `pos`，检查是否被其他 `tillQueueTileGroups` 或 `executingTileGroups` 引用。如果被引用，跳过清除。**

这样 B 的中心块就不会被清掉。但 B 的边界 tile 可能因为 A 的实际耕地建立而变得过时（比如 B 的某个边界位置现在实际层已经有了正确的 tile，预览层的增量 tile 就多余了）。

不过这个"过时"问题是视觉上的小瑕疵（预览层多显示了一点），不是功能性 bug。等 B 执行完毕后，`RemoveExecutingPreview(B)` 会清掉 B 的所有 tile，然后实际层已经是正确的了。

所以最终方案：**`RemoveExecutingPreview` 清除时，跳过被其他队列/执行预览占用的位置**。

你觉得这个分析和方案对吗？如果对，我直接改代码。

执行步骤：
1. 修改 `RemoveExecutingPreview` — 清除前检查位置是否被其他 `tillQueueTileGroups` 或 `executingTileGroups` 占用
2. 编译验证
3. 更新 memory

【输出完毕】