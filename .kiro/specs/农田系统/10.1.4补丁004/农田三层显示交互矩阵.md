# 农田三层显示详细交互矩阵

> 创建时间：2026-02-21
> 工作区：10.1.4补丁004
> 目的：彻底厘清 ghost 预览、队列预览、实际耕地三层之间的显示逻辑
> 核心原则：**预览 + 实际 = 最终效果**（预览只显示增量，不与实际重叠）

---

## 一、三层定义与职责

| 层级 | Tilemap | 内容 | 生命周期 |
|------|---------|------|---------|
| 实际耕地层 | `farmlandCenterTilemap`（中心块）+ `farmlandBorderTilemap`（边界/阴影） | 真实耕地数据，由 `TillAt` → `UpdateBorderAt` 驱动 | 永久存在直到耕地被移除 |
| 队列预览层 | `queuePreviewTilemap` | 已入队等待执行的操作预览 | 入队时创建，动画完成后清除 |
| Ghost 预览层 | `ghostTilemap` | 鼠标跟随，显示"如果在此锄地会怎样" | 每帧清除重绘 |

**互斥规则：**
- 队列预览层与实际耕地层在同一位置不可能同时有内容（队列→实际是单向不可逆的）
- Ghost 预览层与其他两层可以在同一位置同时存在（ghost 是临时显示层）

---

## 二、边界计算引擎原理

### 2.1 `GetPreviewTiles(layerIndex, centerPos)` 做了什么

1. 构造 predicate：`pos == centerPos ? true : IsCenterBlock(layerIndex, pos)`
   - 意思是：假装 `centerPos` 已经耕作了，其他位置看真实数据
2. 中心块：直接放 `centerTileUnfertilized`
3. 周围8格：每格调用 `CalculateBorderTileAt(pos, predicate)`

### 2.2 `CalculateBorderTileAt` 做了什么

1. 如果该位置本身是中心块（predicate 返回 true）→ 返回 `null`（中心块不需要边界）
2. 检查该位置的8个邻居是否是中心块（通过 predicate）
3. 四正方向（U/D/L/R）有中心块 → 选择对应的边界 tile
4. 四正方向都没有但斜角有 → 选择阴影 tile
5. 都没有 → 返回 `null`

### 2.3 关键理解：predicate 只假装一个位置

`GetPreviewTiles` 的 predicate 只假装 `centerPos` 已耕作。这意味着：
- 如果 A 是已有耕地，predicate 会通过 `IsCenterBlock(A)` 返回 true（真实数据）
- 如果 B 是预览位置，predicate 对 B 返回 true（假装）
- 计算周围8格时，同时考虑了 A（真实）和 B（假装）的存在

**结果：`GetPreviewTiles` 返回的是"如果 B 也耕作后的最终状态"。**

---

## 三、核心问题：预览显示的是"最终结果"而不是"增量"

### 3.1 问题本质

`GetPreviewTiles` 计算出的是最终状态。当前差异化过滤对比实际 tilemap，发现不同就放到 ghost 层。

但 ghost 层放的是完整的最终 tile（如 `borderLR`），而实际层已有部分内容（如 `borderL`）。两层同时显示，视觉上重叠。

### 3.2 你要的效果

**预览 + 实际 = 最终效果。** 预览只显示"增量部分"。

但 tile 是不可分割的整体图片（`borderLR` 是一张完整 Sprite），不能只显示其中的 R 部分。

### 3.3 正确的解决思路

既然 tile 不可分割，那么在差异位置：
- ghost 层显示**最终 tile**（如 `borderLR`）
- 实际层的**旧 tile 需要被遮盖**（如 `borderL` 不应该透出来）

只要 ghost 层的 Sorting Order 高于实际层，ghost 的 `borderLR` 自然会完全遮盖实际层的 `borderL`。玩家看到的就是一个带绿色叠加的 `borderLR`，这就是"最终效果的预览"。

**这不是"增量显示"，而是"最终结果覆盖显示"。视觉效果等价于增量。**

前提条件：`ghostTilemap` 的 Sorting Order 必须 > `farmlandBorderTilemap` 的 Sorting Order。

---

## 四、场景逐一分析

### 符号约定

- `C` = 中心块 tile（`centerTileUnfertilized`）
- `B_X` = 边界 tile（X = 方向，如 `B_L` = 左边界，`B_LR` = 左右边界）
- `S_XY` = 阴影 tile（XY = 斜角方向，如 `S_LD` = 左下阴影）
- `∅` = 无 tile（null）
- `A` = 已有耕地（实际层有内容）
- `P` = 预览位置（鼠标所在，准备耕作）
- `M` = 中间位置（A 和 P 之间的格子）

### 场景1：空地上耕地（周围无耕地）

```
布局：P=(0,0)，周围8格全空，无任何已有耕地

实际层状态：全部 ∅

GetPreviewTiles(P) 返回（最终状态）：
  P(0,0)  = C
  (-1,1)  = S_RD    (0,1)  = B_D    (1,1)  = S_LD
  (-1,0)  = B_R                      (1,0)  = B_L
  (-1,-1) = S_RU    (0,-1) = B_U    (1,-1) = S_LU

差异化过滤：
  每个位置：预览 tile ≠ ∅（实际层） → 全部保留

Ghost 显示：完整 1+8（9个 tile 全部显示在 ghost 层）
实际层：∅
视觉效果：完整的耕地预览，带绿色叠加 ✅
```

**结论：最简单的场景，无任何问题。**

---

### 场景2：水平相邻（A 在左，P 在右，直接相邻，间距0格）

```
布局：A=(-1,0) 已有耕地，P=(0,0) 预览位置
      两者直接相邻，中间无空格

A 存在时实际层状态（A 的 1+8）：
  (-2,1)  = S_RD    (-1,1) = B_D    (0,1)  = S_LD
  (-2,0)  = B_R     A(-1,0)= C      (0,0)  = B_L  ← P 位置当前是 B_L
  (-2,-1) = S_RU    (-1,-1)= B_U    (0,-1) = S_LU
```

**GetPreviewTiles(P=(0,0)) 逐格计算：**

| 位置 | 计算过程 | 预览 tile | 实际层 tile | 差异？ |
|------|---------|-----------|------------|--------|
| P(0,0) | 中心块 | `C` | `B_L`（border层） | ≠ → ghost 显示 `C` |
| (-1,1) | 邻居中心块：D=A=true → `B_D` | `B_D` | `B_D`（A的边界） | = → 跳过 |
| (0,1) | 邻居中心块：D=P=true, L=A? 不是（A=(-1,0)，(0,1)的L=(-1,1)不是中心块） → 只有 D → `B_D` | `B_D` | `S_LD`（A的阴影） | ≠ → ghost 显示 `B_D` |
| (1,1) | 邻居中心块：L=P=true → 斜角？不，L是正方向 → `B_L`... 不对，(1,1)的邻居：D=(1,0)=∅, L=(0,1)=∅, U=(1,2)=∅, R=(2,1)=∅。但 predicate 只假装 P=(0,0)，(1,1)的 L=(0,1) 不是 P → 四正方向都没有中心块。斜角：LD=(0,0)=P=true → `S_LD` | `S_LD` | `∅` | ≠ → ghost 显示 `S_LD` |
| (-1,0) | A 是中心块 → `IsCenterBlock(A)=true` → predicate 返回 true → `CalculateBorderTileAt` 判断该位置是中心块 → 返回 `null` | `null` | `C`（center层） | 预览=null → 跳过（`kvp.Value == null continue`） |
| (1,0) | 邻居中心块：L=P=true → `B_L` | `B_L` | `∅` | ≠ → ghost 显示 `B_L` |
| (-1,-1) | 邻居中心块：U=A=true, R=P=true → count=2 → `B_UR` | `B_UR` | `B_U`（A的边界） | ≠ → ghost 显示 `B_UR` |
| (0,-1) | 邻居中心块：U=P=true → `B_U` | `B_U` | `S_LU`（A的阴影） | ≠ → ghost 显示 `B_U` |
| (1,-1) | 四正方向无中心块。斜角：LU=(0,0)=P=true → `S_LU` | `S_LU` | `∅` | ≠ → ghost 显示 `S_LU` |

**Ghost 显示的 tile（7个）：**
```
                 (0,1)=B_D     (1,1)=S_LD
  [A不显示]      P(0,0)=C      (1,0)=B_L
  (-1,-1)=B_UR   (0,-1)=B_U    (1,-1)=S_LU
```

**实际层保持不变的 tile：**
```
  (-2,1)=S_RD   (-1,1)=B_D    [被ghost B_D覆盖]
  (-2,0)=B_R    A(-1,0)=C     [被ghost C覆盖]
  (-2,-1)=S_RU  (-1,-1)=B_U   [被ghost B_UR覆盖]
                               [被ghost B_U覆盖]
                               [被ghost S_LU覆盖]  (0,-1)原来是S_LU
```

**视觉效果分析：**
- P(0,0)：ghost 显示 `C`（绿色叠加），覆盖实际层的 `B_L` → 玩家看到绿色中心块 ✅
- (-1,-1)：ghost 显示 `B_UR`，覆盖实际层的 `B_U` → 玩家看到 `B_UR`（最终结果）✅
- (0,1)：ghost 显示 `B_D`，覆盖实际层的 `S_LD` → 玩家看到 `B_D`（最终结果）✅
- (-1,1)：跳过（预览=实际=`B_D`）→ 实际层的 `B_D` 正常显示 ✅
- A(-1,0)：跳过（预览=null）→ 实际层的 `C` 正常显示 ✅

**结论：直接相邻场景，差异化过滤 + Sorting Order 覆盖 = 正确的最终效果预览。** ✅

---

### 场景3：水平隔一格（A 在左，P 在右，中间隔一格 M）

```
布局：A=(-1,0) 已有耕地，P=(1,0) 预览位置，M=(0,0) 中间空地
      A 和 P 之间隔了一个格子 M
```

**A 存在时实际层状态（A 的 1+8 中与本场景相关的部分）：**

| 位置 | 实际层 tile | 所属 tilemap | 说明 |
|------|------------|-------------|------|
| A(-1,0) | `C` | centerTilemap | A 的中心块 |
| (0,0)=M | `B_L` | borderTilemap | A 的左边界（M 在 A 的右边） |
| (-1,1) | `B_D` | borderTilemap | A 的下边界 |
| (0,1) | `S_LD` | borderTilemap | A 的左下阴影 |
| (-1,-1) | `B_U` | borderTilemap | A 的上边界 |
| (0,-1) | `S_LU` | borderTilemap | A 的左上阴影 |

**GetPreviewTiles(P=(1,0)) 逐格计算：**

predicate：`pos == (1,0) ? true : IsCenterBlock(pos)`

| 位置 | 邻居中心块检查 | 预览 tile | 实际层 tile | 差异？ |
|------|--------------|-----------|------------|--------|
| P(1,0) | 中心块 | `C` | `∅` | ≠ → ghost 显示 `C` |
| (0,1) | 邻居：D=M=(0,0) 不是中心块, L=(-1,1) 不是中心块, R=(1,1) 不是中心块, U=(0,2) 不是中心块 → 四正方向无。斜角：RD=(1,0)=P=true, LD=(0,0)=M 不是中心块... 但 A=(-1,0)，(0,1)的 LD=(-1,0)=A=true → 有 LD。RD=(1,0)=P=true → 有 RD。两个斜角，优先级 LD > RD → `S_LD` | `S_LD` | `S_LD`（A的阴影） | = → 跳过 |
| (1,1) | 四正方向无中心块。斜角：LD=(0,0)=M 不是中心块, RD=(2,0) 不是中心块... 但 (1,1) 的 LD=(0,0)=M，M 不是中心块。(1,1) 的 RD=(2,0)=∅。但 predicate 只假装 P=(1,0)。(1,1) 的邻居斜角中没有 P... 不对，让我重新算。(1,1) 的8邻居：U=(1,2), D=(1,0)=P=true（但 D 是正方向！）→ hasD=true → count=1 → `B_D` | `B_D` | `∅` | ≠ → ghost 显示 `B_D` |

等等，我算错了。让我重新仔细算 (0,1) 的邻居。

**(0,1) 的邻居中心块检查：**
- U = (0,2) → 不是中心块
- D = (0,0) = M → `IsCenterBlock(M)` = false（M 不是耕地）
- L = (-1,1) → 不是中心块
- R = (1,1) → 不是中心块
- 四正方向都没有 → 进入阴影检查
- LU = (-1,2) → false
- RU = (1,2) → false
- LD = (-1,0) = A → `IsCenterBlock(A)` = true → hasLD = true
- RD = (1,0) = P → predicate(P) = true → hasRD = true
- 优先级：LU > RU > LD > RD → 选 `S_LD`

**(1,1) 的邻居中心块检查：**
- U = (1,2) → false
- D = (1,0) = P → predicate(P) = true → hasD = true
- L = (0,1) → false
- R = (2,1) → false
- count = 1, hasD → `B_D`

继续其他位置：

| 位置 | 邻居中心块检查 | 预览 tile | 实际层 tile | 差异？ |
|------|--------------|-----------|------------|--------|
| (0,0)=M | L=(-1,0)=A=true, R=(1,0)=P=true → count=2 → `B_LR` | `B_LR` | `B_L` | ≠ → ghost 显示 `B_LR` |
| (2,0) | L=(1,0)=P=true → count=1 → `B_L` | `B_L` | `∅` | ≠ → ghost 显示 `B_L` |
| (0,-1) | U=(0,0)=M 不是中心块 → 四正方向无。斜角：LU=(-1,0)=A=true, RU=(1,0)=P=true → 优先 `S_LU` | `S_LU` | `S_LU`（A的阴影） | = → 跳过 |
| (1,-1) | U=(1,0)=P=true → count=1 → `B_U` | `B_U` | `∅` | ≠ → ghost 显示 `B_U` |
| (2,1) | 四正方向无。斜角：LD=(1,0)=P=true → `S_LD` | `S_LD` | `∅` | ≠ → ghost 显示 `S_LD` |
| (2,-1) | 四正方向无。斜角：LU=(1,0)=P=true → `S_LU` | `S_LU` | `∅` | ≠ → ghost 显示 `S_LU` |

**🔴 关键位置 M=(0,0)：**

- 预览 tile = `B_LR`（因为 M 的左边是 A=中心块，右边是 P=假装中心块）
- 实际层 tile = `B_L`（因为 M 的左边是 A=中心块，右边当前是空的）
- `B_LR ≠ B_L` → ghost 显示 `B_LR`

**视觉效果：**
- ghost 层的 `B_LR`（带绿色叠加）覆盖实际层的 `B_L`
- 玩家看到的是：M 位置显示绿色的 `B_LR`（最终结果预览）
- 这就是你说的"预览加实际等于最终内容 LR"

**但这里有一个视觉细节：** ghost 层有 shader 叠加色（绿色），所以 M 位置的 `B_LR` 整体都是绿色的，包括 L 部分。而 L 部分其实已经存在于实际层了。严格来说，L 部分不应该是绿色的（它不是新增的），只有 R 部分才是新增的。

**这是 tile 不可分割带来的固有限制。** `B_LR` 是一张完整图片，无法只给 R 部分上绿色。

**可接受的妥协：** M 位置整体显示绿色的 `B_LR`，虽然 L 部分也被染绿了，但视觉上玩家能理解"这里会变成 LR"。实际落地后 `UpdateBorderAt` 会重新计算，结果正确。

**结论：水平隔一格场景，当前差异化过滤逻辑是正确的。** ghost 显示 `B_LR` 覆盖实际的 `B_L`，视觉上是最终结果预览。✅（有 L 部分被染绿的小瑕疵，但 tile 不可分割，这是固有限制）

---

### 场景4：斜角相邻（A 在左下，P 在右上，直接斜角）

```
布局：A=(0,-1) 已有耕地，P=(0,0) 预览位置
      A 在 P 的正下方（注意：这里用正下方举例更清晰）
      
实际上你的描述是 A 在左下 P 在右上，我用 A=(-1,-1) P=(0,0) 来分析
```

**A=(-1,-1) 存在时实际层状态（A 的 1+8 中与 P 相关的部分）：**

| 位置 | 实际层 tile | 说明 |
|------|------------|------|
| A(-1,-1) | `C` | A 的中心块 |
| (-1,0) | `B_D` | A 的下边界（A 在 (-1,-1)，(-1,0) 在 A 的上方） |
| (0,-1) | `B_L` | A 的左边界（(0,-1) 在 A 的右方） |
| (0,0)=P | `S_LD` | A 的左下阴影（P 位置当前是 A 的阴影） |

**GetPreviewTiles(P=(0,0)) 逐格计算：**

predicate：`pos == (0,0) ? true : IsCenterBlock(pos)`

| 位置 | 邻居中心块检查 | 预览 tile | 实际层 tile | 差异？ |
|------|--------------|-----------|------------|--------|
| P(0,0) | 中心块 | `C` | `S_LD`（border层） | ≠ → ghost 显示 `C` |
| (-1,1) | 四正方向：D=(-1,0) 不是中心块（(-1,0) 有 `B_D` 但不是中心块）, R=(0,1) 不是中心块 → 无。斜角：RD=(0,0)=P=true → `S_RD` | `S_RD` | `∅` | ≠ → ghost 显示 `S_RD` |
| (0,1) | 四正方向：D=(0,0)=P=true → hasD=true → count=1 → `B_D` | `B_D` | `∅` | ≠ → ghost 显示 `B_D` |
| (1,1) | 四正方向无。斜角：LD=(0,0)=P=true → `S_LD` | `S_LD` | `∅` | ≠ → ghost 显示 `S_LD` |
| (-1,0) | 四正方向：D=(-1,-1)=A=true, R=(0,0)=P=true → count=2 → hasD+hasR → `B_DR` | `B_DR` | `B_D`（A的边界） | ≠ → ghost 显示 `B_DR` |
| (1,0) | 四正方向：L=(0,0)=P=true → count=1 → `B_L` | `B_L` | `∅` | ≠ → ghost 显示 `B_L` |
| (-1,-1)=A | predicate(A) = `IsCenterBlock(A)` = true → 该位置是中心块 → 返回 `null` | `null` | `C`（center层） | 预览=null → 跳过 |
| (0,-1) | 四正方向：U=(0,0)=P=true, L=(-1,-1)=A=true → count=2 → hasU+hasL → `B_UL` | `B_UL` | `B_L`（A的边界） | ≠ → ghost 显示 `B_UL` |
| (1,-1) | 四正方向：无（U=(1,0) 不是中心块）。斜角：LU=(0,0)=P=true → `S_LU` | `S_LU` | `∅` | ≠ → ghost 显示 `S_LU` |

**🔴 关键位置分析：**

**(-1,0) 位置：**
- 预览 = `B_DR`（因为下方有 A，右方有 P）
- 实际 = `B_D`（因为下方有 A，右方当前是空的）
- ghost 显示 `B_DR`，覆盖实际的 `B_D`
- 你说的"(-1,0) 实际耕地已经有一个 D 了，你就不要再多余了"——这里 ghost 显示的是 `B_DR`（最终结果），D 部分确实已经存在，但 tile 不可分割，`B_DR` 必须整体显示

**视觉效果：** ghost 的 `B_DR`（绿色叠加）覆盖实际的 `B_D`。玩家看到绿色的 `B_DR`。D 部分被染绿是 tile 不可分割的固有限制。

**(0,-1) 位置：**
- 预览 = `B_UL`（因为上方有 P，左方有 A）
- 实际 = `B_L`（因为左方有 A，上方当前是空的）
- ghost 显示 `B_UL`，覆盖实际的 `B_L`
- 同理，L 部分已存在但被整体染绿

**结论：斜角相邻场景，差异化过滤逻辑正确。** ghost 显示最终结果覆盖实际层。✅（同样有已存在部分被染绿的小瑕疵）

---

### 场景5：斜角隔一格（A 在左下，P 在右上，中间隔一格）

```
布局：A=(-1,-1) 已有耕地，P=(1,1) 预览位置
      对角线距离 = 2，中间有 (0,0) 等格子
```

**A 的 1+8 中与 P 的 1+8 有交集的位置：**
- A 的 1+8 范围：(-2,-2) 到 (0,0)
- P 的 1+8 范围：(0,0) 到 (2,2)
- 交集：只有 (0,0)

**(0,0) 在 A 的 1+8 中的实际 tile：** `S_LD`（A 在 (0,0) 的左下斜角）

**GetPreviewTiles(P=(1,1)) 计算 (0,0)：**
- (0,0) 的邻居中心块：四正方向都不是中心块（A=(-1,-1) 不在 (0,0) 的四正方向）
- 斜角：RU=(1,1)=P=true, LD=(-1,-1)=A=true
- 两个斜角，优先级 LD > RD... 不对，优先级是 LU > RU > LD > RD
- hasRU=true, hasLD=true → 优先 `S_RU`... 不对，让我重新看 `SelectShadowTile` 的逻辑

```csharp
if (hasLU) return shadowLU;
if (hasRU) return shadowRU;
if (hasLD) return shadowLD;
if (hasRD) return shadowRD;
```

hasRU=true → 返回 `S_RU`

但实际层 (0,0) 当前是 `S_LD`（A 的阴影）。

预览 = `S_RU`，实际 = `S_LD` → ≠ → ghost 显示 `S_RU`

**问题：** ghost 显示 `S_RU`（P 的阴影），覆盖了实际层的 `S_LD`（A 的阴影）。但实际落地后，(0,0) 应该同时受 A 和 P 影响。`UpdateBorderAt` 用真实数据计算时，(0,0) 的斜角邻居有 A(LD) 和 P(RU)，`SelectShadowTile` 优先级 RU > LD → 最终结果是 `S_RU`。

所以 ghost 显示 `S_RU` 是正确的最终结果。但 A 的 `S_LD` 被覆盖了——这在视觉上可能有一瞬间的跳变（ghost 出现时 `S_LD` 变成绿色的 `S_RU`，落地后变成正常的 `S_RU`）。

**结论：斜角隔一格场景，逻辑正确。** 阴影 tile 的优先级机制确保了最终结果一致。✅

---

### 场景6：鼠标在已有耕地上（canTill = false）

```
布局：A=(0,0) 已有耕地，鼠标在 A 上
```

**当前代码行为：**
1. `canTill = false`（`CanTillAt` 返回 false，已耕作）
2. `if (canTill && ...)` 不进入 → ghostTilemap 上不放任何 tile
3. `cursorRenderer.enabled = false`（耕地模式不显示光标）
4. `previewOverlayMaterial` 设置红色叠加色，但 ghostTilemap 上没有 tile → 无处叠加
5. 结果：什么都不显示 ❌

**用户期望：** 应该显示红色反馈（表示"这里不能再锄地"）

**修复方向：** designV3 模块 J 已设计——启用 `cursorRenderer` 显示红色方框

---

### 场景7：批量操作 — 两个相邻位置先后入队

```
布局：先入队 A=(0,0)，再入队 B=(1,0)
      A 和 B 直接相邻
```

**A 入队时：**
- ghost 计算 A 的 1+8（周围无耕地）→ 完整 9 个 tile
- 复制 ghostTileData 到队列预览层
- 队列预览层显示 A 的完整 1+8

**B 入队时：**
- ghost 计算 B 的 1+8
- predicate 只假装 B=(1,0) 已耕作，不知道 A=(0,0) 也在队列中
- `IsCenterBlock(A)` = false（A 还没有实际落地，只是在队列预览中）
- 所以 B 的预览计算不考虑 A 的存在

**结果：**
- B 的 ghost 在 (0,0) 位置计算出 `B_L`（B 的左边界）
- 但 A 的队列预览在 (0,0) 位置已经放了 `C`（A 的中心块）
- B 入队时复制 ghostTileData 到队列预览层，(0,0) 位置的 `B_L` 会覆盖 A 的 `C`

**这是一个已知限制：** `GetPreviewTiles` 的 predicate 只假装单点耕作，不考虑队列中其他位置。批量操作时队列预览之间会互相覆盖。

**实际落地时不受影响：** `TillAt` → `UpdateBorderAt` 用真实数据重新计算，结果正确。

**可接受的妥协：** 预览阶段的视觉近似。如果要完美解决，需要让 predicate 同时考虑队列中所有位置，这会大幅增加复杂度。

---

## 五、Sorting Order 覆盖机制（三层显示的前提条件）

### 5.1 为什么需要 Sorting Order

差异化过滤后，ghost 层在差异位置显示"最终 tile"。如果 ghost 层的 Sorting Order 低于实际层，两层 tile 会同时可见，产生视觉重叠。

### 5.2 必须满足的层级关系

```
ghostTilemap          Sorting Order 最高（显示在最上层）
  ↑
queuePreviewTilemap   Sorting Order 中间
  ↑
farmlandBorderTilemap Sorting Order 较低
farmlandCenterTilemap Sorting Order 较低
```

### 5.3 验证方式

需要在代码中确认 `EnsureComponents` 或场景配置中各 tilemap 的 Sorting Order 设置。如果不满足上述关系，差异化覆盖显示会失败。

---

## 六、总结：当前差异化过滤的正确性判定

### 6.1 逻辑正确的场景

| 场景 | 差异化过滤结果 | 视觉效果 | 判定 |
|------|--------------|---------|------|
| 场景1：空地 | ghost 显示完整 1+8 | 完整预览 | ✅ 正确 |
| 场景2：水平直接相邻 | ghost 显示差异 tile，覆盖实际层 | 最终结果预览 | ✅ 正确 |
| 场景3：水平隔一格 | M 位置 ghost 显示 `B_LR` 覆盖实际 `B_L` | 最终结果预览 | ✅ 正确 |
| 场景4：斜角直接相邻 | 共享边界位置 ghost 显示最终 tile | 最终结果预览 | ✅ 正确 |
| 场景5：斜角隔一格 | 阴影优先级正确处理 | 最终结果预览 | ✅ 正确 |

### 6.2 需要修复的场景

| 场景 | 问题 | 修复方向 |
|------|------|---------|
| 场景6：已有耕地上 | 无任何视觉反馈 | designV3 模块 J：启用 cursorRenderer 红色方框 |

### 6.3 已知限制（可接受的妥协）

| 场景 | 限制 | 原因 | 影响 |
|------|------|------|------|
| 场景7：批量操作 | 队列预览之间互相覆盖 | predicate 只假装单点 | 预览不完美，落地正确 |
| 所有差异场景 | 已存在部分被整体染绿 | tile 不可分割 | 视觉小瑕疵，不影响理解 |

### 6.4 前提条件

| 条件 | 说明 | 状态 |
|------|------|------|
| ghostTilemap Sorting Order > farmlandBorderTilemap | ghost 层必须在实际层上方才能正确覆盖 | 需验证（designV3 模块 K） |

---

## 七、三层交互规则总表

### 7.1 Ghost 预览层规则

| 条件 | Ghost 行为 |
|------|-----------|
| `canTill = true` | 显示差异化 1+8 tile（对比实际层，只显示不同的） |
| `canTill = false` 且非枯萎 | 显示红色方框（cursorRenderer）表示不可锄地 |
| `canTill = false` 且枯萎 | 显示绿色方框（cursorRenderer）表示可清除 |
| 差异位置有实际层 tile | ghost 显示最终 tile，通过 Sorting Order 覆盖实际层 |
| 差异位置无实际层 tile | ghost 正常显示新增 tile |

### 7.2 队列预览层规则

| 条件 | 队列预览行为 |
|------|------------|
| 入队时 | 复制 ghost 的 `CurrentGhostTileData`（差异化数据） |
| WASD 中断 | 清空所有队列预览（跳过执行预览） |
| 动画开始 | 从队列预览提升为执行预览（数据转移，tile 保留） |
| 动画完成 | 清除执行预览（tile 已落地到实际层） |

### 7.3 实际耕地层规则

| 条件 | 实际层行为 |
|------|-----------|
| `TillAt` 调用 | 放置中心块到 `farmlandCenterTilemap` |
| `UpdateBordersAround` | 重新计算周围8格边界，用真实数据（无 predicate） |
| 与队列预览互斥 | 同一位置不可能同时有队列预览和实际耕地 |
| 落地后 | 预览层对应 tile 被清除，实际层 tile 接管显示 |

### 7.4 三层互斥与转换关系

```
Ghost 预览（临时，每帧重绘）
    ↓ 入队（复制 ghost 数据）
队列预览（静态，等待执行）
    ↓ 动画开始（PromoteToExecutingPreview）
执行预览（受保护，动画期间不可清除）
    ↓ 动画完成 + TillAt 落地（RemoveExecutingPreview）
实际耕地（永久，数据层驱动）
```

- Ghost ↔ 队列预览：可以同时存在于同一位置（ghost 在上层覆盖显示）
- 队列预览 → 实际耕地：单向不可逆
- 实际耕地 → 队列预览：不可能（已耕作的位置 `canTill = false`，不会入队）
