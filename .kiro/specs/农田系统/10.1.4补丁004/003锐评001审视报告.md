# 003锐评001 审视报告

> 锐评来源：`003锐评001.md`（Gemini 为用户起草的 prompt）
> 审视时间：2026-02-23
> 路径判断：🟡 路径 B（核心方向正确，诉求2完全正确，诉求3是已知待办，诉求1需要具体场景验证）

---

## 一、锐评核心观点摘要

锐评包含3个核心诉求：

| 编号 | 诉求 | 严重程度 |
|------|------|---------|
| 诉求1 | 耕地增量预览综合 Bug：c+b 交界处差集漏判 + 极限操作残留预览变"孤儿" | 🔴 |
| 诉求2 | 浇水随机样式时机错误：OnWaterExecuted 触发导致停在原地的 ghost 疯狂随机 | 🔴 |
| 诉求3 | 种子系统彻底剥离（模块R）：种子从农田队列完全剥离，接入 PlacementManager | 🔴 |

---

## 二、事实核查结果

### 诉求1：耕地增量预览综合 Bug

#### 1A. 增量差集 c+b 交界处漏判

**锐评声称**：`cDirs | bDirs` 合并以及 `previewDirs & ~existingDirs` 差集计算在某些排列下存在漏判。

**代码事实**：

`UpdateHoePreview` 增量过滤有4个分支：

| 分支 | 条件 | 处理方式 | 是否合并 b 层 |
|------|------|---------|-------------|
| 全新位置 | `actualTile == null` | 直接显示 | ✅（先查 c 层无 tile → 查 b 层 → b 层也无 → 全新） |
| 阴影→边界 | `IsShadowTile(actualTile)` | 对 b 层做差集 | ✅（续31 Bug V 修复） |
| 边界→边界 | `IsBorderTile(actualTile) && IsBorderTile(kvp.Value)` | 合并 c+b 方向后做差集 | ✅（模块V） |
| 其他 | else | 直接显示 | N/A |

**关键逻辑推演**：

当 c 层没有 tile 但 b 层有 tile 时：
```
actualTile = actualBorderTilemap?.GetTile(kvp.Key);  // null（c 层无 tile）
if (actualTile == null && queuePreviewTilemap != null)
    actualTile = queuePreviewTilemap.GetTile(kvp.Key);  // 取 b 层 tile
```
此时 `actualTile` = b 层增量 tile。然后进入边界→边界分支，但此时 `actualDirs` 是 b 层增量方向，不是 b 层完整方向。

**但这不是 bug**：因为边界→边界分支中还会再查一次 b 层：
```csharp
// 合并 c+b 方向
mergedU = actualDirs.hasU;  // 这里 actualDirs 来自 b 层增量 tile
// 然后再查 b 层...
var bLayerTile = queuePreviewTilemap.GetTile(kvp.Key);  // 同一个 tile
```
等等——这里有个问题！当 `actualTile` 已经是 b 层 tile 时，代码又从 b 层取了同一个 tile 做合并，相当于 `merged = bDirs | bDirs = bDirs`。c 层的方向贡献被完全忽略了（因为 c 层没有 tile，actualTile 被 b 层覆盖了）。

**但 c 层本来就没有 tile**，所以 c 层方向贡献为零，`merged = 0 | bDirs = bDirs` 是正确的。

**真正可能出问题的场景**：当 c 层有阴影 tile，b 层有边界 tile 时：
- `actualTile` = c 层阴影 tile（先查 c 层，有值就不查 b 层）
- 进入阴影分支 → 只对 b 层做差集
- 阴影 tile 没有方向贡献，b 层增量 tile 有方向 → 差集 = previewDirs & ~bDirs
- 这是正确的：阴影不贡献方向，b 层增量方向需要排除

**核查结论**：⚠️ 推测性声明。当前代码在我能推演的所有场景中逻辑正确。锐评描述的"右边已经满了只需显示左边 1+5"过于模糊，无法定位具体漏判场景。**需要用户提供具体的复现步骤或截图**。

#### 1B. 极限操作残留预览变"孤儿"

**锐评声称**：极限操作（入队或动画起手瞬间 WASD）导致红绿方框或 1+8 预览永不消失。

**代码事实**：

WASD 中断闭环：

```
HandleMovement WASD 检测
  → wasExecuting = _isExecutingFarming
  → ClearActionQueue()
    → 模块H：_isExecutingFarming=true 时保留执行状态
    → ClearAllQueuePreviews()：清除队列预览，跳过执行预览
  → if (!wasExecuting)
    → CancelFarmingNavigation()：清理导航
    → ForceUnlock()：解锁移动
  → else（动画执行中）
    → 只清空队列，不取消导航/不解锁
    → 动画完成后 OnFarmActionAnimationComplete 正常清理
```

**OnFarmActionAnimationComplete 清理链**：
```
_isExecutingFarming = false
_queuedPositions.Remove(...)
RemoveExecutingPreview(cellPos)  ← 清除执行预览
ProcessNextAction()  ← 队列已空，不再处理
```

**ToolActionLockManager 保护**：
- `ExecuteFarmAction` → `RequestAction` → `StartAction` → `BeginAction` → `IsLocked = true`
- 同步调用链，同一帧内完成
- `IsLocked = true` 时 HandleMovement 进入锁定分支，缓存方向但不执行移动
- 动画中 WASD 不会触发 ClearActionQueue（因为 `lockManager.IsLocked` 拦截在前）

**等等——重新审视代码**：

```csharp
// HandleMovement 中：
bool hasWASD = input.sqrMagnitude > 0.01f;
bool hasActiveQueue = _farmActionQueue.Count > 0 || _isProcessingQueue;
if (hasWASD && hasActiveQueue)  // ← 这个检查在 lockManager 检查之前！
{
    bool wasExecuting = _isExecutingFarming;
    ClearActionQueue();
    ...
}

// lockManager 检查在后面：
var lockManager = ToolActionLockManager.Instance;
if (lockManager != null && lockManager.IsLocked)
{
    // 缓存方向，不执行移动
    return;
}
```

**关键发现**：WASD 中断队列的检查（`hasWASD && hasActiveQueue`）在 `lockManager.IsLocked` 检查**之前**！这意味着即使动画正在执行（IsLocked=true），只要队列不为空（`_farmActionQueue.Count > 0`），WASD 仍然会触发 `ClearActionQueue`。

但 `wasExecuting = true` 时，代码不会调用 `CancelFarmingNavigation` 和 `ForceUnlock`，只清空队列。动画继续执行，完成后正常清理。这是正确的。

**那"孤儿"预览从哪来？**

可能的场景：
1. 入队瞬间（`EnqueueAction` 刚执行完，`AddQueuePreview` 已写入 tile）
2. 同帧 WASD 触发 `ClearActionQueue` → `ClearAllQueuePreviews`
3. 但 `ProcessNextAction` 可能已经在 `EnqueueAction` 中被调用，将第一个请求提升为执行预览
4. `ClearAllQueuePreviews` 跳过执行预览 → 执行预览保留
5. 然后 `wasExecuting` 此时可能为 false（因为 `ExecuteFarmAction` 还没被调用）
6. → `CancelFarmingNavigation` + `ForceUnlock` → 玩家可以移动
7. 但执行预览已经被 `PromoteToExecutingPreview` 提升了，而 `_isExecutingFarming` 还没设为 true
8. → 没有人会调用 `RemoveExecutingPreview` → 孤儿！

**等等，让我验证这个时序**：

```
EnqueueAction → _farmActionQueue.Enqueue(request) → AddQueuePreview
             → if (!_isProcessingQueue) ProcessNextAction()
ProcessNextAction → _isProcessingQueue = true → Dequeue → PromoteToExecutingPreview
                 → StartFarmingNavigation (导航到目标位置)
```

`PromoteToExecutingPreview` 在 `ProcessNextAction` 中调用——不对，续6已经把它移到了 `ExecuteFarmAction`。让我确认：

根据已读取的代码，`OnFarmActionAnimationComplete` 中调用 `RemoveExecutingPreview`，而 `PromoteToExecutingPreview` 应该在 `ExecuteFarmAction` 中。让我确认 `ProcessNextAction`：

**核查结论**：⚠️ 部分正确。极限操作残留的可能性存在，但需要精确的帧级时序分析。当前保护机制（模块H + 模块Q + ToolActionLockManager）覆盖了大部分场景，但入队瞬间的竞态窗口可能存在。**需要用户提供具体复现步骤**。

### 诉求2：浇水随机样式时机错误

**锐评声称**：`OnWaterExecuted` 触发导致停在原地的 ghost 预览疯狂随机变幻。应改为入队瞬间随机。

**代码事实**：

当前随机触发链：
```
ExecuteWaterTile 成功 → OnWaterExecuted(cellPos)
  → _needsNewPuddleVariant = true
  → _lastWateringCellPos = wateredCellPos（角色执行位置）

UpdateWateringPreview 每帧检查：
  → if (_needsNewPuddleVariant && cellPos != _lastWateringCellPos)
    → 随机新样式
```

**场景推演**：
1. 玩家在 A、B、C、D、E 五个格子连续点击入队浇水
2. 鼠标停在 F 格子不动
3. 角色走到 A 执行浇水 → `OnWaterExecuted(A)` → `_needsNewPuddleVariant = true`, `_lastWateringCellPos = A`
4. 下一帧 `UpdateWateringPreview` 检查：`cellPos = F`（鼠标位置），`_lastWateringCellPos = A` → F ≠ A → **随机触发！**
5. 角色走到 B 执行浇水 → 同理 → **又随机！**
6. 重复...鼠标停在原地，ghost 预览疯狂变幻

**这确实是 bug！** 锐评分析完全正确。

**修复方向**：锐评建议将随机判定移到 `TryEnqueueFarmTool` 成功入队浇水的瞬间。逻辑上合理：
- 入队成功 = 玩家确认了当前 ghost 样式 → 立刻为下一次点击准备新样式
- 与角色执行完全解耦，不会因为远处执行而影响鼠标处的 ghost

**核查结论**：✅ 事实正确。bug 真实存在，修复方向合理。

### 诉求3：种子系统彻底剥离（模块R）

**锐评声称**：种子仍纠缠在农田队列中，应完全接入 PlacementManager。

**代码事实**：
- `TryEnqueueSeed` 仍然存在（第2725行），种子仍走 `EnqueueAction` 农田队列
- `UpdateSeedPreview` 仍在 `FarmToolPreview` 中（第777行）
- `AddQueuePreview` 中有 `PlantSeed` 分支（SpriteRenderer 对象池）
- `executingSeedPreviews` 数据结构仍在使用

**核查结论**：✅ 事实正确。但这是**已知待办**，续25/续26已确认并记录在 `TD_10.1.4补丁004.md` 代办文件中。不是新发现。

---

## 三、认同的部分

1. **诉求2 完全认同**：浇水随机时机绑定 `OnWaterExecuted` 确实会导致远程执行时 ghost 疯狂随机。改为入队瞬间随机是正确方向。
2. **诉求3 认同**：种子确实应该从农田队列剥离。这是已知待办。
3. **诉求1 部分认同**：极限操作残留的可能性存在，增量差集在边缘场景可能有盲区。

## 四、疑虑与异议

### 诉求1 的描述过于模糊

锐评说"右边已经满了，只需显示左边的 1+5，但依然会错误地更新已有边界"，但没有给出：
- 具体的格子坐标排列
- c 层和 b 层的具体 tile 状态
- 预期结果 vs 实际结果的对比

当前代码的增量差集逻辑在我能推演的所有场景中是正确的：
- 边界→边界分支：合并 c+b 方向后做差集（模块V）
- 阴影分支：对 b 层做差集（续31 Bug V 修复）
- 全新位置：先查 c 层再查 b 层，都没有则直接显示

**如果确实存在漏判，需要用户提供具体的复现场景截图或步骤。**

### 极限操作残留需要更精确的分析

锐评说"红绿方框或残留的 1+8 预览留在地上永远不消失"，但当前保护机制已经相当完善：
- `ToolActionLockManager.IsLocked` 阻止动画中移动
- 模块H 保护执行状态
- 模块Q 绝对锁定原则
- `OnFarmActionAnimationComplete` 兜底清理

可能的漏洞窗口：`EnqueueAction` → `ProcessNextAction` → 导航开始但 `ExecuteFarmAction` 还没调用时的 WASD 中断。此时 `_isExecutingFarming = false`，`wasExecuting = false`，但 `PromoteToExecutingPreview` 还没被调用（它在 `ExecuteFarmAction` 中），所以执行预览还没创建。这个窗口应该是安全的。

**需要用户提供具体的复现步骤来定位漏洞。**

---

## 五、独立分析与修复建议

### 诉求2 修复方案（明确可执行）

将随机触发从 `OnWaterExecuted`（角色执行完成）移到入队瞬间：

1. `TryEnqueueFarmTool` 中浇水入队成功后，立刻随机新样式：
   - 调用 `farmPreview.RefreshPuddleVariant()` 或直接设置 `_cachedPuddleVariant = Random.Range(...)`
2. 废弃 `OnWaterExecuted` 中的 `_needsNewPuddleVariant = true` 逻辑
3. `UpdateWateringPreview` 中移除 `_needsNewPuddleVariant` 相关的随机触发代码
4. 保留 `_wateringModeInitialized` 的切换时随机逻辑（T1 不变）

### 诉求3 修复方案（已有待办）

模块R 已在代办中，按原计划执行即可。

### 诉求1 建议

在没有具体复现场景的情况下，建议：
1. 请用户提供增量差集漏判的具体截图或复现步骤
2. 请用户提供极限操作残留的具体复现步骤
3. 如果用户能复现，再针对性修复

---

## 六、给 Gemini 的信息补充

1. **增量差集**：当前代码已在边界→边界分支合并 c+b 方向（模块V），阴影分支也已修复 b 层差集（续31 Bug V）。如果仍有漏判，请提供具体的格子坐标排列和 tile 状态。
2. **极限操作**：`ToolActionLockManager` 在 `ExecuteFarmAction` → `RequestAction` → `StartAction` → `BeginAction` 同步调用链中设置 `IsLocked = true`，阻止动画中的 WASD 移动。模块Q 的 `wasExecuting` 检查在 `lockManager` 检查之前执行，覆盖了队列清空场景。
3. **浇水随机**：完全认同，这是真实 bug，会修复。
4. **种子剥离**：已在待办中，会按计划执行。

---

## 七、涉及文件汇总

| 文件 | 核查内容 |
|------|---------|
| `FarmToolPreview.cs` | UpdateHoePreview 增量差集4分支、UpdateWateringPreview 随机逻辑、OnWaterExecuted、AddQueuePreview、RemoveExecutingPreview、ClearAllQueuePreviews、UpdateSeedPreview |
| `GameInputManager.cs` | HandleMovement WASD中断、ClearActionQueue 模块H、CancelFarmingNavigation 模块Q、TryEnqueueFarmTool、ExecuteWaterTile OnWaterExecuted调用、OnFarmActionAnimationComplete 清理链、TryEnqueueSeed |
