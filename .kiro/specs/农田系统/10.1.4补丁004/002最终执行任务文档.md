# 002 最终执行任务文档 — 锐评博弈总结与补救任务

> 来源：002执行001~004 全轮次回顾
> 创建时间：2026-02-22
> 当前编号：会话2续30

---

## 一、对 002执行004 的回应

Gemini 在 002执行004 中彻底认输了 Bug Q 的架构辩论，给出了极高评价。核心结论：

1. **Bug Q（WASD 极限操作）**：Gemini 完全接受我的反击——`lockManager.IsLocked = true` 是同步调用链，不存在"1帧竞态条件"。`lockManager.CacheDirection(input)` 方向缓存机制是保护游戏操作手感的关键，顶层绝对锁方案会破坏这个机制。**当前代码已正确，无需修改。**

2. **Bug V（阴影分支 b 层增量）**：Gemini 全盘接受审视报告的分析——阴影分支需要补上 b 层（队列层）的增量差集计算。**需要修复。**

3. **Bug S（红方框 sprite 赋值）**：Gemini 全盘接受——`cursorRenderer` 应使用 `gridSprite`（32x32 放置系统同款）而非旧的 `CreateProceduralCursorSprite`（16x16 白框）。**需要修复。**

Gemini 的"终极指令"要求立即修改代码。方向完全正确，我们执行。

---

## 二、002执行系列全轮次总结

### 2.1 时间线

| 轮次 | 文档 | 角色 | 核心内容 |
|------|------|------|---------|
| 第1轮 | 002执行001 | Gemini | 审核 V6 全面审查报告，全面通过，确认4个待确认事项 |
| 第2轮 | 002执行002 | Gemini | 声称 V6 代码"什么都没解决"，提出三大指控 + 强制替换代码包 |
| 第2轮回应 | 002执行002审视报告 | Kiro | 事实核查：指控1 ❌ 完全错误、指控2 ❌ 分析路径错误（但发现真实 bug）、指控3 ⚠️ 部分正确 |
| 第3轮 | 002执行003 | Gemini | 承认 Bug V/S 审视正确，但在 Bug Q 上提出"1帧竞态条件"新论点 |
| 第3轮回应 | 002执行003审视报告 | Kiro | 用完整同步调用链推演证明竞态条件不存在，拒绝顶层绝对锁 |
| 第4轮 | 002执行004 | Gemini | 彻底认输 Bug Q，称反击"无懈可击"，确认 Bug V/S 修复方案 |

### 2.2 锐评应该采纳的地方（Gemini 正确的贡献）

| 编号 | 内容 | 来源 | 说明 |
|------|------|------|------|
| ✅ G1 | 阴影分支未对 b 层做增量 | 002执行002 指控2 | Gemini 方向对（阴影 tile 确实导致问题），虽然分析路径错误（不是"跳过增量"而是"阴影分支没有对 b 层做增量"），但成功引导我们发现了这个真实 bug |
| ✅ G2 | cursorRenderer 应使用 gridSprite | 002执行002 指控3 | Gemini 指出 cursorRenderer 用的是旧的 16x16 白框而非 32x32 gridSprite，方向完全正确 |
| ✅ G3 | else 分支红方框代码方向 | 002执行002 代码包 | `cursorRenderer.sprite = gridSprite;` 这个改动方向正确 |

### 2.3 Kiro 回应中正确的地方（我方正确的坚守）

| 编号 | 内容 | 来源 | 说明 |
|------|------|------|------|
| ✅ K1 | ToolActionLockManager 拦截机制完整有效 | 002执行002审视报告 | Gemini 完全忽略了 `ToolActionLockManager` 组件的存在。`BeginAction()` → `IsLocked = true` 在同帧内完成，HandleMovement 锁定分支会 `SetMovementInput(Vector2.zero, false)` 阻止移动 |
| ✅ K2 | 不存在1帧竞态条件 | 002执行003审视报告 | `ExecuteFarmAction` → `RequestAction` → `PerformAction` → `StartAction` → `BeginAction` → `IsLocked = true` 是完全同步调用链，`IsLocked` 在 `PlayAnimation()` 之前就已为 true |
| ✅ K3 | 方向缓存机制不可破坏 | 002执行003审视报告 | `lockManager.CacheDirection(input)` 允许玩家在动画期间预输入方向，顶层绝对锁方案会跳过此调用，破坏"输入缓存"手感 |
| ✅ K4 | 四分支结构是有意设计 | 002执行002审视报告 | 增量差集的四分支（null/阴影/边界/其他）是有意设计，不是"烂逻辑"。修复方式是在阴影分支内增加 b 层检查，而非推翻整个结构 |
| ✅ K5 | 拒绝 HandleMovement 替换代码 | 002执行002审视报告 | Gemini 的替换代码在 `_isExecutingFarming = true` 时直接 return，跳过 lockManager 缓存方向、autoNavigator 检查等所有后续逻辑，属于有害代码 |
| ✅ K6 | 精准定位阴影分支真实 bug | 002执行002审视报告 | 在反驳 Gemini 错误分析的同时，独立发现了真正的 bug 位置——阴影分支 `else if (IsShadowTile)` 没有查 b 层方向贡献 |

### 2.4 Gemini 错误的地方（被事实核查否定）

| 编号 | 内容 | 来源 | 说明 |
|------|------|------|------|
| ❌ E1 | "HandleMovement 让玩家发生位移了" | 002执行002 指控1 | 完全忽略 ToolActionLockManager 组件，IsLocked=true 时玩家不会移动 |
| ❌ E2 | "IsBorderTile 对阴影返回 false → 跳过增量" | 002执行002 指控2 | 阴影 tile 有独立分支，不是"跳过"而是走不同路径 |
| ❌ E3 | "1帧竞态条件存在" | 002执行003 | 同步调用链，不依赖动画机状态切换，BeginAction 在 PlayAnimation 之前 |
| ❌ E4 | HandleMovement 替换代码 | 002执行002 代码包 | 跳过 lockManager 缓存机制，有害 |
| ❌ E5 | UpdateHoePreview 整体替换代码 | 002执行002 代码包 | 中心块和边界块混在一起处理，忽略阴影 tile 特殊情况 |

---

## 三、彻底补救任务列表

基于全轮次总结，当前代码还需要修复以下两个真实 bug：

### 任务 1：Bug V — 阴影分支补全 b 层增量差集计算（🔴 高优先级）

**问题描述**：
UpdateHoePreview 的阴影分支 `else if (borderManager.IsShadowTile(actualTile))` 直接显示预览 tile，没有检查 b 层（queuePreviewTilemap）是否已有方向贡献。

**用户报告的场景**：
- a=(-1,0) 空地，M=(0,0) 空地，b=(1,0) 耕地列，b 列上下有队列预览
- ghost 在 M 处显示 B_UDL，但 U/D 已被队列预览覆盖，应只显示 B_L
- 根因：M 处 c 层有阴影 tile（紧邻 c 层耕地），走阴影分支直接显示 B_UDL，未对 b 层做增量

**修复方案**：
在阴影分支内增加 b 层检查逻辑：
1. 查 `queuePreviewTilemap.GetTile(kvp.Key)` 获取 b 层 tile
2. 如果 b 层有边界 tile，解析 b 层方向
3. 计算增量差集：预览方向 - b 层方向
4. 差集为空则跳过，否则用差集方向生成增量 tile

**涉及文件**：`FarmToolPreview.cs` — `UpdateHoePreview` 方法阴影分支

### 任务 2：Bug S — cursorRenderer 使用 gridSprite + 红色（🟡 中优先级）

**问题描述**：
UpdateHoePreview 的 else 分支（不可耕种 + 无农作物）显示的 `cursorRenderer` 使用 `CreateProceduralCursorSprite()`（16x16 白色细线框），而非放置系统同款的 `CreateGridSprite()`（32x32 白色方框 + 半透明填充）。

**修复方案**：
在 else 分支中：
1. `cursorRenderer.sprite = gridSprite;`（使用已在 EnsureComponents 中创建的 32x32 方框）
2. `cursorRenderer.color = new Color(1f, 0.3f, 0.3f, 0.8f);`（红色，参考放置系统 invalidColor）

**涉及文件**：`FarmToolPreview.cs` — `UpdateHoePreview` 方法 else 分支

---

## 四、执行顺序

1. 先修复 Bug V（阴影分支 b 层增量）— 逻辑复杂度更高，优先处理
2. 再修复 Bug S（红方框 sprite）— 简单赋值修改
3. 编译验证（getDiagnostics）
4. 更新 memory
