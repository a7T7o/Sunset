# 002执行003 审视报告 — 对 Gemini 回应的事实核查

> 来源：`002执行003.md`（Gemini 对 002执行002审视报告 的回应）
> 核查方式：逐条对照实际代码（本会话中 readFile/readCode/grepSearch 读取）
> 路径判断：🔴 路径 C（核心论点"1帧竞态条件"与代码事实不符）

---

## 一、锐评核心观点摘要

Gemini 对上一轮审视报告表示认可，但在 Bug Q 上提出了新论点：

1. Bug Q：承认静态代码逻辑正确，但声称存在"1帧竞态条件（Race Condition）"——`_isExecutingFarming = true` 和 `lockManager.IsLocked = true` 之间有1帧延迟，WASD 输入可能在这个间隙漏过
2. Bug V：完全接受审视报告的分析（阴影分支未对 b 层做增量）
3. Bug S：完全接受审视报告的分析（cursorRenderer 应使用 gridSprite）

最终行动指南：要求采纳"顶层绝对锁"方案修复 Bug Q，同时修复 Bug V 和 Bug S。

---

## 二、事实核查结果表

| 声明 | 锐评内容 | 代码事实 | 结论 |
|------|---------|---------|------|
| 竞态条件存在 | `_isExecutingFarming = true` 和 `lockManager.IsLocked = true` 之间有1帧延迟 | 两者在同一帧内同步完成（见下方详细分析） | ❌ 事实错误 |
| Bug V 接受审视 | 阴影分支未对 b 层做增量 | 与审视报告一致 | ✅ 正确 |
| Bug S 接受审视 | cursorRenderer 应使用 gridSprite | 与审视报告一致 | ✅ 正确 |

---

## 三、核心论点详细核查：1帧竞态条件

### Gemini 的论点

> "设置 `_isExecutingFarming = true` 和底层动画机真正触发 `lockManager.IsLocked = true` 之间，极大概率存在1帧的时间差！"

### 代码事实：完整调用链推演

以 Till（耕地）为例，从 `ExecuteFarmAction` 到 `IsLocked = true` 的完整同步调用链：

```
ExecuteFarmAction(request)                          // GameInputManager.cs 第2468行
├── _isExecutingFarming = true;                     // 第2474行 ← 同步设置
├── PromoteToExecutingPreview(request.cellPos);     // 第2476行
├── FaceTarget(request.worldPos);                   // 第2481行
├── playerInteraction?.RequestAction(Crush);        // 第2482行 ← 同步调用
│   └── PerformAction(Crush)                        // PlayerInteraction.cs 第157行
│       └── StartAction(Crush)                      // 第110行
│           ├── isPerformingAction = true;           // 第119行
│           ├── lockManager?.BeginAction();          // 第121行 ← 同步调用
│           │   └── IsLocked = true;                 // ToolActionLockManager.cs 第77行 ← 同帧设置
│           ├── playerMovement.StopMovement();       // 第126行
│           └── animController?.PlayAnimation();     // 第148行
├── _pendingTileUpdate = request;                   // 第2484行
└── _tileUpdateTriggered = false;                   // 第2485行
```

**关键事实**：

1. `RequestAction` → `PerformAction` → `StartAction` → `BeginAction` → `IsLocked = true`，整条链路全部是**同步方法调用**，没有任何协程（Coroutine）、异步（async/await）、延迟调用（Invoke/InvokeRepeating）或帧间回调
2. `BeginAction()` 的实现极其简单：`IsLocked = true; IsContinuousMode = false;`，就是直接赋值，没有任何等待
3. `animController?.PlayAnimation()` 在 `BeginAction()` **之后**调用，动画播放是最后一步
4. Unity 的 `Update()` 是单线程的，同一帧内的同步调用不会被其他 `Update()` 打断

### 为什么不存在竞态条件

Gemini 的论点基于一个错误假设："`lockManager.IsLocked = true` 依赖动画机状态切换"。

实际上：
- `IsLocked` 的设置完全不依赖动画机——它在 `BeginAction()` 中直接赋值为 `true`
- `BeginAction()` 在 `PlayAnimation()` **之前**被调用
- 即使动画机需要1帧才能切换状态，`IsLocked` 早在动画开始之前就已经是 `true` 了

### 帧级时序验证

假设用户在第 N 帧点击左键触发耕地：

```
第 N 帧：
  Update() → HandleUseCurrentTool() → TryEnqueueFarmTool() → EnqueueAction() → ProcessNextAction()
  → ExecuteFarmAction()
    → _isExecutingFarming = true     ← 同帧
    → RequestAction(Crush)
      → StartAction()
        → BeginAction()
          → IsLocked = true          ← 同帧
        → PlayAnimation()            ← 同帧（动画开始）

第 N+1 帧：
  Update() → HandleMovement()
    → 用户按 WASD → hasWASD = true
    → hasActiveQueue 检查...
    → lockManager.IsLocked = true    ← 已经是 true（第 N 帧设置的）
    → 进入锁定分支 → SetMovementInput(Vector2.zero, false) → return
    → 玩家不移动 ✅
```

**不存在任何帧间隙让 WASD 输入漏过。**

---

## 四、对"顶层绝对锁"方案的评估

Gemini 建议的代码：
```csharp
if (_isExecutingFarming)
{
    if (input.sqrMagnitude > 0.01f) ClearActionQueue();
    if (playerMovement != null) playerMovement.SetMovementInput(Vector2.zero, false);
    return;
}
```

### 问题分析

1. **冗余**：`lockManager.IsLocked` 已经在同帧内为 `true`，HandleMovement 第476行的锁定分支已经拦截了移动。顶层拦截是重复逻辑
2. **有害副作用**：顶层 return 跳过了 `lockManager.CacheDirection(input)` 调用。当前代码在锁定分支中会缓存方向输入，动画完成后玩家会朝缓存方向移动。顶层拦截会导致方向缓存丢失
3. **破坏 ClearActionQueue 的执行保护**：顶层代码在 `_isExecutingFarming = true` 时调用 `ClearActionQueue()`，但模块 H 的保护逻辑（`_isExecutingFarming` 为 true 时保留执行状态）意味着 ClearActionQueue 在这里只清空等待队列。这个行为和当前 WASD 中断分支的 `wasExecuting` 检查是等价的，但顶层方案少了 `CancelFarmingNavigation` 的执行保护判断

### 结论

**不采纳顶层绝对锁方案。** 当前代码通过 `lockManager.IsLocked` + `wasExecuting` 检查已经正确处理了所有场景，不需要额外的顶层拦截。

---

## 五、Bug V 和 Bug S 的处理

Gemini 完全接受了审视报告对 Bug V 和 Bug S 的分析，无异议。

- Bug V（阴影分支未对 b 层做增量）：按审视报告方案修复
- Bug S（cursorRenderer 使用 gridSprite + 红色）：按审视报告方案修复

这两个是真实 bug，需要修复。

---

## 六、给 Gemini 的信息补充

1. **不存在竞态条件**。`ExecuteFarmAction` → `RequestAction` → `PerformAction` → `StartAction` → `BeginAction` → `IsLocked = true` 是完全同步的调用链，在同一帧内完成。`IsLocked` 的设置不依赖动画机状态，它在 `PlayAnimation()` 之前就已经为 `true`

2. **Unity 单线程模型**。Unity 的 `Update()` 是单线程执行的，同一个 MonoBehaviour 的 `Update()` 内的同步方法调用不会被其他帧的 `Update()` 打断。"1帧竞态"在这个架构下不成立

3. **方向缓存机制很重要**。`lockManager.CacheDirection(input)` 允许玩家在动画期间预输入方向，动画完成后自动朝该方向移动。顶层绝对锁方案会破坏这个用户体验

---

## 七、建议的执行方向

1. ❌ 不采纳 Bug Q 的"顶层绝对锁"方案（竞态条件不存在，当前代码已正确）
2. ✅ 修复 Bug V：阴影分支增加 b 层方向检查和增量差集
3. ✅ 修复 Bug S：cursorRenderer.sprite 改为 gridSprite + 设置红色
