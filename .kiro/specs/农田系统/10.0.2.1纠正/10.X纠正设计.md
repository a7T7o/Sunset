# 10.X 纠正设计 — 废弃 CropManager，全面对齐树木模式

**创建日期**: 2026-02-14
**工作区**: `.kiro/specs/农田系统/10.0.2.1纠正/`
**基础文档**: 全面调查报告.md、999迭代需求001.md、10.0.3 requirements.md
**目标**: 一次性完成 CropManager 废弃 + 播种链路重写 + 收获掉落模式 + SeedData 精简 + Collect 动画集成

---

## 一、纠正总览

### 1.1 核心问题

1. CropManager 使用全局 `cropPrefab`，忽略 `SeedData.cropPrefab` → 所有作物用同一个预制体
2. 场景中没有 CropManager 组件 → 播种静默失败
3. CropManager.TryHarvest 与 CropController.Harvest 双重路径 → 逻辑不一致
4. 收获"直接加背包"模式与树木"掉落到地面"模式不统一
5. SeedData 仍有被 CropStageConfig 替代的冗余字段

### 1.2 纠正方向

全面学习树木系统（TreeController）的 Prefab 驱动模式：
- 没有集中式 Manager，每个 CropController 完全自治
- 播种时直接 Instantiate `SeedData.cropPrefab`
- 收获通过 `dropItemData` + `WorldSpawnService.SpawnMultiple()` 掉落到地面
- 存档重建由 `DynamicObjectFactory.TryReconstructCrop()` 完成（已实现）

### 1.3 涉及的代码文件

| 文件 | 操作 | 说明 |
|------|------|------|
| `GameInputManager.cs` | 修改 | 播种链路绕过 CropManager，直接 Instantiate |
| `GameInputManager.cs` | 修改 | ExecuteTillSoil 中枯萎作物查找改用物理查询 |
| `GameInputManager.cs` | 删除方法 | TryHarvestCropAtMouse 整个方法废弃 |
| `CropController.cs` | 修改 | 新增 dropItemData/dropAmount 字段，重写收获逻辑 |
| `CropController.cs` | 修改 | 新增 DestroySelf 方法替代 CropManager.DestroyCrop |
| `CropManager.cs` | 标记废弃 | 整个类标记 `[Obsolete]`，不删除文件 |
| `SeedData.cs` | 修改 | growthDays/harvestCropID/harvestAmountRange 标记 `[Obsolete]` |
| `FarmToolPreview.cs` | 修改 | 枯萎作物查找改用物理查询替代 CropManager.GetCrop |
| `CropSystemTests.cs` | 修改 | 适配新的收获逻辑 |

---

## 二、播种链路重写

### 2.1 当前链路（有问题）

```
GameInputManager.ExecutePlantSeed()
  → CropManager.Instance.CreateCrop(layerIndex, cellPos, seedData, ...)
    → Instantiate(cropPrefab)  ← 全局 cropPrefab，错误！
    → CropController.Initialize()
```

### 2.2 新链路（直接 Instantiate）

```
GameInputManager.ExecutePlantSeed()
  → seedData.cropPrefab  ← 每种种子自己的预制体
  → Instantiate(seedData.cropPrefab, worldPos, Quaternion.identity, container)
  → CropController.Initialize(seedData, instanceData, layerIndex, cellPos)
```

### 2.3 设计要点

- 不再依赖 CropManager.Instance（场景中可以没有 CropManager）
- 使用 `seedData.cropPrefab`（与 DynamicObjectFactory.TryReconstructCrop 一致）
- 重复位置检查：通过 `FarmTileData.HasCrop()` 判断，不需要 activeCrops 字典
- 创建失败时的种子退还逻辑保持不变

### 2.4 seedData.cropPrefab 为空的防御

```csharp
if (seedData.cropPrefab == null)
{
    Debug.LogError($"[GameInputManager] 种子 {seedData.itemName} 的 cropPrefab 为空，无法播种");
    return false;
}
```

### 2.5 种子袋自动初始化

当前 bug：InventoryBootstrap 注入种子时不调用 `SeedBagHelper.InitializeSeedBag()`，导致 ConsumeSeed 时 `GetPropertyInt(KEY_REMAINING)` 返回 0，减 1 变 -1，静默失败。

修复方案：在 ExecutePlantSeed 的 ConsumeSeed 之前，检查种子袋是否已初始化，未初始化则自动初始化：

```csharp
// 自动初始化未初始化的种子袋
if (!FarmGame.Farm.SeedBagHelper.IsSeedBag(seedItem))
{
    FarmGame.Farm.SeedBagHelper.InitializeSeedBag(seedItem, seedData, currentTotalDays);
}
```

---

## 三、CropManager 废弃方案

### 3.1 废弃策略

整个 CropManager 类标记 `[Obsolete]`，不删除文件，保证编译通过。

### 3.2 CropManager 功能迁移表

| CropManager 功能 | 迁移目标 | 说明 |
|------------------|---------|------|
| `CreateCrop()` | GameInputManager.ExecutePlantSeed | 直接 Instantiate seedData.cropPrefab |
| `DestroyCrop()` | CropController.DestroySelf() | 作物自己销毁自己 |
| `GetCrop()` | 物理查询 或 FarmTileData | 通过 cellPosition 查找 |
| `TryHarvest()` | CropController.Harvest() | 收获只走 IInteractable 路径 |
| `activeCrops` 字典 | 不再需要 | CropController 自治，不需要集中注册 |
| `GetActiveCropCount()` | 不再需要 | 如需统计可用 FindObjectsByType |
| `GetAllActiveCrops()` | 不再需要 | 同上 |

### 3.3 枯萎作物查找替代方案

当前 `ExecuteTillSoil` 和 `FarmToolPreview.UpdateHoePreview` 通过 `CropManager.GetCrop()` 查找枯萎作物。

替代方案：通过 FarmTileData 获取 CropController 引用。

具体做法：
1. FarmTileData 新增 `CropController cropController` 运行时引用（不序列化）
2. 播种时设置：`tileData.cropController = controller`
3. 查找时使用：`tileData.cropController?.GetState()`
4. 作物销毁时清除：`tileData.cropController = null`

这比物理查询更高效，且与 FarmTileData 的数据模型一致。

---

## 四、收获逻辑重写

### 4.1 当前收获（直接加背包）

```
CropController.HarvestMature()
  → seedData.harvestCropID → database.GetItemByID()
  → inventory.AddItem(cropID, quality, amount)
  → 背包满 → DropItemToWorld()
```

### 4.2 新收获（掉落到地面，学习 TreeController）

```
CropController.HarvestMature()
  → dropItemData（Inspector 配置的 ItemData SO）
  → WorldSpawnService.SpawnMultiple(dropItemData, quality, dropAmount, position, spreadRadius)
```

### 4.3 CropController 新增字段

```csharp
[Header("=== 掉落配置 ===")]
[Tooltip("收获掉落的物品 SO")]
[SerializeField] private ItemData dropItemData;

[Tooltip("收获掉落数量")]
[SerializeField] private int dropAmount = 1;

[Tooltip("掉落散布半径")]
[SerializeField] private float dropSpreadRadius = 0.4f;

[Tooltip("掉落品质（0=Normal）")]
[SerializeField] private int dropQuality = 0;

[Tooltip("枯萎收获掉落的物品 SO（可为空=不掉落）")]
[SerializeField] private ItemData witheredDropItemData;
```

### 4.4 新 HarvestMature 逻辑

1. 检查 `dropItemData` 是否配置，未配置则只清除作物
2. 调用 `WorldSpawnService.SpawnMultiple(dropItemData, dropQuality, dropAmount, position, dropSpreadRadius)`
3. 可重复收获：重置到 reGrowStage，逻辑不变
4. 不可重复收获：调用 DestroySelf()

### 4.5 新 HarvestWitheredMature 逻辑

1. 检查 `witheredDropItemData` 是否配置
2. 已配置：`SpawnMultiple(witheredDropItemData, 0, 1, position, dropSpreadRadius)`
3. 未配置：不掉落，直接清除
4. 枯萎作物不可重复收获，直接 DestroySelf()

### 4.6 废弃 TryHarvestCropAtMouse

GameInputManager 中的 `TryHarvestCropAtMouse()` 方法使用 CropManager.TryHarvest，这是一条与 IInteractable 重复的收获路径。

废弃方案：标记 `[Obsolete]`，收获统一走 IInteractable → CropController.Harvest()。

需要确认：TryHarvestCropAtMouse 是否有调用者。如果有，需要将调用者改为走 IInteractable 路径。

确认结果：`TryHarvestCropAtMouse` 已在代码注释中标记为废弃（行717-719），没有实际调用者。可以安全标记 `[Obsolete]`。

---

## 五、SeedData 字段精简

### 5.1 标记 Obsolete 的字段

| 字段 | 替代方案 | 说明 |
|------|---------|------|
| `growthDays` | `CropStageConfig.daysToNextStage` | 10.0.2 已用累加模式替代 |
| `harvestCropID` | `CropController.dropItemData` | 收获物品改为 Inspector 配置 |
| `harvestAmountRange` | `CropController.dropAmount` | 收获数量改为 Inspector 配置 |

### 5.2 保留的字段

| 字段 | 原因 |
|------|------|
| `season` | 季节检查仍需要 |
| `isReHarvestable` | 重复收获逻辑不变 |
| `reHarvestDays` | 重复收获间隔不变 |
| `maxHarvestCount` | 最大收获次数不变 |
| `seedsPerBag` | 种子袋系统不变 |
| `shelfLifeClosed` / `shelfLifeOpened` | 保质期系统不变 |
| `iconOpened` | UI 显示不变 |
| `cropPrefab` | 核心字段，播种和存档重建都用 |
| `needsTrellis` / `needsWatering` | 种植需求不变 |
| `plantingExp` / `harvestingExp` | 经验值不变 |

### 5.3 Obsolete 标记方式

```csharp
[System.Obsolete("已被 CropStageConfig.daysToNextStage 替代，保留用于存档兼容")]
public int growthDays = 4;

[System.Obsolete("已被 CropController.dropItemData 替代，保留用于存档兼容")]
public int harvestCropID;

[System.Obsolete("已被 CropController.dropAmount 替代，保留用于存档兼容")]
public Vector2Int harvestAmountRange = new Vector2Int(1, 1);
```

### 5.4 OnValidate 更新

移除对 harvestCropID 范围的验证警告（已废弃的字段不需要验证）。
保留 cropPrefab 的验证（核心字段）。

### 5.5 GetTooltipText 更新

生长周期显示改为从 cropPrefab 的 CropController.stages 累加计算总天数，而非使用 growthDays。
但由于 Tooltip 是运行时 UI，且 cropPrefab 是预制体引用（不是实例），直接访问 stages 需要 GetComponent。
稳妥方案：暂时保留 growthDays 在 Tooltip 中的使用，后续 UI 迭代时再处理。

---

## 六、FarmTileData 扩展

### 6.1 新增运行时引用

```csharp
/// <summary>
/// 运行时作物控制器引用（不序列化，不存档）
/// 用于替代 CropManager.GetCrop() 的查找功能
/// </summary>
[System.NonSerialized]
public CropController cropController;
```

### 6.2 使用场景

- 播种时：`tileData.cropController = controller`
- 锄头清除枯萎：`tileData.cropController?.GetState() == CropState.WitheredImmature`
- 预览检查：`tileData.cropController?.GetState()`
- 作物销毁时：`tileData.cropController = null`（在 CropController.DestroySelf 中处理）

### 6.3 存档重建时的恢复

DynamicObjectFactory.TryReconstructCrop 重建作物后，需要通过 CropController.Load() 中恢复 FarmTileData.cropController 引用。

具体做法：CropController.Load() 中，在恢复 layerIndex 和 cellPosition 后，查找对应的 FarmTileData 并设置引用：
```csharp
var ftm = FarmTileManager.Instance;
if (ftm != null)
{
    var tileData = ftm.GetTileData(layerIndex, cellPosition);
    if (tileData != null)
        tileData.cropController = this;
}
```

---

## 七、CropController.DestroySelf 方法

### 7.1 职责

替代 CropManager.DestroyCrop()，由作物自己清理并销毁：

1. 清除 FarmTileData 的作物数据：`tileData.ClearCropData()`
2. 清除 FarmTileData 的控制器引用：`tileData.cropController = null`
3. 取消事件订阅（OnDisable 已处理）
4. 销毁 GameObject：`Destroy(gameObject)`

### 7.2 与现有 DestroyCrop 的区别

当前 CropController 已有 `DestroyCrop()` 私有方法（行513），但它只做了：
- 取消注册 PersistentObjectRegistry
- Destroy(gameObject)

需要扩展为：
- 清除 FarmTileData 引用
- 取消注册 PersistentObjectRegistry
- Destroy(gameObject)

---

## 八、Collect 动画集成（预留）

### 8.1 当前状态

- CropController 实现了 IInteractable，OnInteract 直接调用 Harvest()
- 没有播放 Collect 动画（AnimState.Collect = 4）
- TryInteract 直接调用 OnInteract，没有动画过渡

### 8.2 设计方案

Collect 动画集成涉及 GameInputManager 的交互流程改造，影响范围较大。
本次纠正聚焦于 CropManager 废弃和收获掉落模式，Collect 动画集成作为后续任务预留。

当前 IInteractable 路径已经能正确触发收获，只是缺少动画表现。
功能正确性优先，动画表现后续补充。

---

## 九、存档兼容性分析

### 9.1 无风险项

| 项目 | 原因 |
|------|------|
| CropSaveData 结构 | 不变，仍然存 seedId/currentStage/grownDays 等 |
| DynamicObjectFactory.TryReconstructCrop | 已使用 seedData.cropPrefab，不受影响 |
| CropController.Save/Load | 不变 |
| FarmTileData 序列化 | cropController 字段标记 NonSerialized，不影响存档 |

### 9.2 需要注意项

| 项目 | 处理方式 |
|------|---------|
| SeedData 旧字段 | 标记 Obsolete 但不删除，旧存档的 SO 引用仍有效 |
| CropManager 废弃 | 场景中如果有 CropManager 组件不会报错（只是不再被调用） |
| 旧存档中通过 CropManager 创建的作物 | 存档重建走 DynamicObjectFactory，不受影响 |

---

## 十、DetermineHarvestQuality 废弃

### 10.1 当前逻辑

随机骰子：80% Normal, 15% Rare, 4% Epic, 1% Legendary

### 10.2 新逻辑

品质由 CropController 的 `dropQuality` 字段决定（Inspector 配置，默认 0 = Normal）。
后续品质系统（土壤肥力等）可以在运行时修改 dropQuality。

### 10.3 处理方式

`DetermineHarvestQuality()` 标记 `[Obsolete]`，新收获逻辑使用 `dropQuality` 字段。

---

## 十一、全局搜索 CropManager 引用清单

通过代码搜索确认的所有 CropManager 引用：

| 文件 | 位置 | 引用方式 | 处理方案 |
|------|------|---------|---------|
| `GameInputManager.cs` | ExecutePlantSeed | `CropManager.Instance.CreateCrop()` | 改为直接 Instantiate seedData.cropPrefab |
| `GameInputManager.cs` | ExecuteTillSoil | `CropManager.Instance.GetCrop()` | 改为 `tileData.cropController` |
| `GameInputManager.cs` | TryHarvestCropAtMouse | `CropManager.Instance.TryHarvest()` | 整个方法标记 Obsolete |
| `FarmToolPreview.cs` | UpdateHoePreview | `CropManager.Instance.GetCrop()` | 改为 `tileData.cropController` |
| `CropManager.cs` | 自身 | 整个类 | 标记 Obsolete |

共 4 个外部引用点，全部有明确的替代方案。

---

## 十二、风险评估与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|---------|
| FarmTileData.cropController 在存档重建时未恢复 | 锄头无法检测枯萎作物 | CropController.Load() 中主动设置引用 |
| seedData.cropPrefab 未配置 | 播种失败 | ExecutePlantSeed 中加 null 检查 + 错误日志 |
| 旧代码仍调用 CropManager | 编译警告 | Obsolete 标记会产生编译警告，逐步清理 |
| FarmToolPreview 获取 tileData 的方式 | 需要确认 FarmToolPreview 能否访问 FarmTileManager | FarmToolPreview 已有 FarmTileManager 引用 |
| CropController.DestroySelf 需要知道 layerIndex 和 cellPosition | 需要确认这些字段已存储 | CropController 已有 layerIndex 和 cellPosition 字段（Initialize 时设置） |

---

## 十三、设计总结

本次纠正的核心是：让农田系统完全对齐树木系统的 Prefab 驱动模式。

改动范围：
1. 播种链路：绕过 CropManager，直接 Instantiate seedData.cropPrefab
2. 收获逻辑：从"加背包"改为"掉落到地面"（dropItemData + SpawnMultiple）
3. 作物查找：从 CropManager.activeCrops 字典改为 FarmTileData.cropController 引用
4. 作物销毁：从 CropManager.DestroyCrop 改为 CropController.DestroySelf
5. SeedData 精简：3 个冗余字段标记 Obsolete
6. CropManager 废弃：整个类标记 Obsolete

改动后的架构与树木系统完全一致：
- 没有集中式 Manager
- 每个 Controller 完全自治（生长、收获、存档、销毁）
- Prefab 上配置一切（阶段 Sprite、掉落物品、掉落数量）
- 创建由播种逻辑或 DynamicObjectFactory 完成
