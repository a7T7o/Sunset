# 10.0.2.1 农田系统全面调查报告

**创建日期**: 2026-02-14
**工作区**: `.kiro/specs/农田系统/10.0.2.1纠正/`
**目的**: 全面梳理农田系统现状，分析设计矛盾，为后续纠正提供决策依据

---

## 第一区：代码统计与联动分析

### 1.1 Farm 目录文件清单

| 文件 | 行数(约) | 核心职责 | 遵守的设计 | 联动脚本 |
|------|---------|---------|-----------|---------|
| `CropController.cs` | ~850 | 作物生命周期控制（状态机、生长、收获、枯萎、存档） | Prefab 驱动 + IInteractable + IPersistentObject | TimeManager, SeasonManager, FarmTileManager, InventoryService, ItemDatabase, WorldSpawnService |
| `CropManager.cs` | ~310 | 作物创建/销毁/查找的中央管理器（Singleton） | 集中式 Manager 模式 | FarmTileManager, CropController, SeedData, TimeManager |
| `CropInstance.cs` | ~120 | [已废弃] 旧版作物实例（运行时对象） | 旧版设计，已标记 Obsolete | SeedData（直接引用） |
| `FarmTileManager.cs` | ~760 | 耕地格子管理（创建/删除/浇水/存档） | Singleton + IPersistentObject | FarmlandBorderManager, FarmVisualManager, LayerTilemaps, TimeManager |
| `FarmTileData.cs` | ~190 | 单个耕地格子的数据结构 | 纯数据类 | CropInstanceData（持有引用） |
| `FarmlandBorderManager.cs` | ~540 | 耕地边界 Tile 计算与更新（1+8 模式） | Singleton + RuleTile 模式 | FarmTileManager, LayerTilemaps |
| `FarmVisualManager.cs` | ~340 | 耕地视觉效果（Tile 更新、音效、粒子） | Singleton + 对象池 | FarmTileManager, LayerTilemaps |
| `FarmToolPreview.cs` | ~900 | 农田工具预览（锄头/水壶/种子的光标和幻象） | Singleton + 联邦制（独立于 PlacementPreview） | FarmTileManager, FarmlandBorderManager, PlacementGridCalculator, PlacementLayerDetector, PlacementValidator |
| `SeedBagHelper.cs` | ~80 | 种子袋辅助（初始化/消耗种子） | 静态工具类 | InventoryItem, SeedData |
| `SoilMoistureState.cs` | ~10 | 土壤湿度状态枚举 | 枚举 | FarmTileData |

### 1.2 Data 子目录文件清单

| 文件 | 核心职责 | 联动 |
|------|---------|------|
| `CropInstanceData.cs` | 作物实例纯数据（可序列化） | CropController, FarmTileData |
| `CropStageConfig.cs` | 作物阶段配置（Sprite + daysToNextStage） | CropController（Inspector 配置） |
| `LayerTilemaps.cs` | 楼层 Tilemap 引用容器 | FarmTileManager, FarmlandBorderManager, FarmVisualManager |

### 1.3 关联的外部文件

| 文件 | 与农田系统的关系 |
|------|----------------|
| `GameInputManager.cs` | 播种入口（TryPlantSeed → ExecutePlantSeed → CropManager.CreateCrop） |
| `SeedData.cs` | 种子 SO（含 cropPrefab、growthDays、harvestCropID 等） |
| `CropData.cs` | 作物 SO（继承 FoodData，含 seedID、witheredCropID） |
| `TreeController.cs` | 参考对象（Prefab 驱动、6 阶段、StageConfig 模式） |
| `InventoryBootstrap.cs` | 种子注入（测试用，注入种子到背包） |
| `DynamicObjectFactory.cs` | 存档重建（TryReconstructCrop 方法） |


### 1.4 核心联动关系图（文字版）

```
播种链路：
  GameInputManager.HandleUseCurrentTool()
    → TryPlantSeed()
      → ExecutePlantSeed()
        → CropManager.Instance.CreateCrop()  ← ⚠️ 问题点1：使用全局 cropPrefab
          → Instantiate(cropPrefab)           ← ⚠️ 问题点2：忽略 seedData.cropPrefab
          → CropController.Initialize()

收获链路：
  IInteractable.OnInteract()
    → CropController.Harvest()
      → HarvestMature()                       ← 直接 AddItem 到背包
      → HarvestWitheredMature()               ← 直接 AddItem 到背包
  或
  CropManager.TryHarvest()                    ← ⚠️ 问题点3：与 CropController.Harvest 重复

生长链路：
  TimeManager.OnDayChanged 事件
    → CropController.OnDayChanged()
      → HandleGrowingDay()
        → Grow() → UpdateGrowthStage() → UpdateVisuals()
      → HandleMatureDay()
        → 检查枯萎条件

存档链路：
  CropController.Save() → WorldObjectSaveData（含 CropSaveData JSON）
  DynamicObjectFactory.TryReconstructCrop() → SeedData.cropPrefab → CropController.Load()
```

### 1.5 关键设计矛盾

#### 矛盾 1：CropManager 的全局 cropPrefab vs SeedData.cropPrefab

CropManager 持有一个全局 `cropPrefab` 字段，CreateCrop 时使用这个全局预制体：
```csharp
// CropManager.cs 第 30 行
[SerializeField] private GameObject cropPrefab;

// CropManager.CreateCrop() 第 113 行
GameObject cropObj = Instantiate(cropPrefab, worldPosition, ...);
```

但 SeedData 已经有了 `cropPrefab` 字段（10.0.2 新增），每种种子可以指向不同的作物预制体：
```csharp
// SeedData.cs
public GameObject cropPrefab;  // 作物预制体（包含 CropController + 阶段 Sprite 配置）
```

DynamicObjectFactory 的存档重建已经使用 `seedData.cropPrefab`，但 CropManager.CreateCrop 仍然使用全局 cropPrefab。

#### 矛盾 2：CropManager 的角色定位

树木系统没有 TreeManager。TreeController 是完全自治的：
- 自己订阅 TimeManager 事件处理生长
- 自己实现 IPersistentObject 处理存档
- 自己处理交互（IResourceNode）
- 创建由 DynamicObjectFactory 或场景预设完成

CropController 也已经实现了同样的自治能力：
- 订阅 TimeManager.OnDayChanged 处理生长
- 实现 IPersistentObject（Save/Load）
- 实现 IInteractable 处理收获交互

但 CropManager 仍然存在，承担了：
1. 创建作物（CreateCrop）— 可以移到播种逻辑中直接 Instantiate
2. 销毁作物（DestroyCrop）— 可以由 CropController 自己处理
3. 查找作物（GetCrop）— 通过 activeCrops 字典
4. 收获作物（TryHarvest）— 与 CropController.Harvest 功能重复

#### 矛盾 3：收获逻辑双重路径

存在两条收获路径：
1. `CropController.Harvest()` → `HarvestMature()` — 通过 IInteractable 触发
2. `CropManager.TryHarvest()` — 通过外部调用

两者的收获逻辑不完全一致（重复收获的 reGrowStage 计算方式不同），容易产生 bug。


---

## 第二区：工作区进程与设计方向对比

### 2.1 工作区演进时间线

| 工作区 | 时间 | 核心目标 | 设计方向 |
|--------|------|---------|---------|
| 9.0.1 重生之我在种田 | 2026-02-05 | 配置防御 + 存档集成 + 作物身份统一化 | 消除数据双重存储，CropController 实现 IPersistentObject |
| 9.0.2 放置农田 | 2026-02-06 | 统一坐标系 + 锄头/水壶预览 + 交互原子性 | 联邦制架构，FarmToolPreview 独立于 PlacementPreview |
| 9.0.3 预览农田 | 2026-02-07 | 动态空间感知 + 障碍物检测 + 种子预览 + 距离限制 | 完善预览系统，多楼层支持 |
| 9.0.4 智能交互升级 | 2026-02-08 | 远距离自动导航 + 近距离立即执行 | 从"短视模式"升级为"智能模式" |
| 9.0.5 智能交互bug修复 | 2026-02-09 | 预览锁定/解锁 + 导航中断恢复 + 浇水可靠性 | 对齐放置系统的 Locked 状态机制 |
| 10.0.1 农作物设计与完善 | 2026-02-10 | 种子袋保质期 + 7样式生长 + 枯萎机制 + 收割系统 | 三种 SO（SeedData/CropData/WitheredCropData），参考 TreeController |
| 10.0.2 农BUG农SO | 2026-02-12 | Prefab 驱动重构（Sprite 从 SO 移到 Prefab） | SO 做减法，Prefab 做加法，学习 TreeController |
| 10.0.2 迭代 | 2026-02-14 | CropStageConfig 新增 daysToNextStage + 固定 4 阶段 | 深度学习树木模式 |
| 10.0.3 收获DropTable与动画 | 2026-02-14 | 收获改掉落模式 + Collect 动画 + SeedData 精简 | 继续学习树木模式 |

### 2.2 各工作区的设计思路详解

#### 9.0.1 — 基础设施修复

核心问题：锄地不显示、存档不工作、数据双重存储。
设计方向：
- FarmTileManager 实现 IPersistentObject
- CropController 实现 IPersistentObject
- 作物数据只存在 CropController 中（消除 FarmTileSaveData 中的作物字段）
- 参考 TreeController 的存档模式

这个工作区奠定了"学习树木系统"的基调。

#### 9.0.2 ~ 9.0.5 — 交互系统完善

这四个工作区专注于耕地交互（锄头/水壶/种子的预览和操作），不涉及作物生长逻辑。
核心成果：
- FarmToolPreview 完整实现（1+8 预览、障碍物检测、距离限制）
- 智能导航（远距离自动走过去再操作）
- 预览锁定/解锁状态机
- FarmingSnapshot 快照校验机制

#### 10.0.1 — 作物业务逻辑完善

核心成果：
- CropController 状态机（Growing/Mature/WitheredImmature/WitheredMature）
- 种子袋保质期系统
- 枯萎机制（过熟枯萎 + 过季枯萎）
- 收获系统（正常收获 + 枯萎收获 + 重复收获）
- 16 个 PBT 测试

设计方向：SO 有三种（SeedData/CropData/WitheredCropData），生长阶段间隔由 Controller 控制。

#### 10.0.2 — Prefab 驱动重构

核心成果：
- CropStageConfig 结构（normalSprite + witheredSprite + daysToNextStage）
- Sprite 数据从 SeedData 移到 CropController 的 Prefab Inspector
- SeedData 新增 cropPrefab 字段
- DynamicObjectFactory 支持作物重建
- 固定 4 阶段 + 每阶段独立天数

设计方向：SO 做减法，Prefab 做加法。这是"学习树木模式"的关键一步。

#### 10.0.3 — 收获 DropTable（规划中）

规划内容：
- 收获从"直接加背包"改为"掉落到地面"
- SeedData 字段精简（harvestCropID/harvestAmountRange/growthDays 标记 Obsolete）
- Collect 动画集成
- 品质系统适配


### 2.3 共同方向

所有 10.x 工作区都在朝同一个方向推进：**学习树木系统的 Prefab 驱动模式**。

树木系统的核心特征：
1. 没有 TreeManager — 每棵树完全自治
2. Prefab 上配置一切（StageConfig、SpriteConfig、掉落表、音效）
3. 创建由场景预设或 DynamicObjectFactory 完成
4. 自己订阅事件、自己管理生命周期、自己处理存档

农田系统正在逐步靠拢，但 CropManager 的存在是最大的阻碍。

### 2.4 各工作区的区别

| 维度 | 9.0.x 系列 | 10.0.x 系列 |
|------|-----------|------------|
| 关注点 | 耕地交互（锄头/水壶/种子的预览和操作） | 作物生命周期（生长/收获/枯萎/存档） |
| 修改范围 | FarmToolPreview, GameInputManager, PlacementValidator | CropController, CropStageConfig, SeedData, CropManager |
| 设计模式 | 联邦制（FarmToolPreview 独立于 PlacementPreview） | Prefab 驱动（学习 TreeController） |
| 与 CropManager 的关系 | 不直接涉及 | 逐步削弱 CropManager 的职责 |

---

## 第三区：全面总结与独立思考

### 3.1 当前系统的健康度评估

#### 健康的部分 ✅

1. **CropController 的自治能力已经很强**
   - 状态机完整（Growing/Mature/WitheredImmature/WitheredMature）
   - 自己订阅 TimeManager 事件处理生长
   - 自己实现 IPersistentObject 处理存档
   - 自己实现 IInteractable 处理收获
   - Prefab 上配置 CropStageConfig（Sprite + daysToNextStage）

2. **耕地系统（FarmTileManager + FarmlandBorderManager + FarmVisualManager）稳定**
   - 三个 Manager 各司其职，职责清晰
   - 耕地数据（FarmTileData）结构合理
   - 存档集成完整

3. **交互系统（FarmToolPreview + 智能导航）完善**
   - 预览、导航、锁定/解锁、快照校验全部到位
   - 9.0.2 ~ 9.0.5 四个工作区打磨得很扎实

4. **测试覆盖**
   - 16 个 PBT 测试覆盖核心业务逻辑

#### 有问题的部分 ⚠️

1. **CropManager 的角色已经过时**
   - 10.0.2 之后，CropController 已经具备完全自治能力
   - CropManager 的 CreateCrop 使用全局 cropPrefab，与 SeedData.cropPrefab 矛盾
   - CropManager 的 TryHarvest 与 CropController.Harvest 功能重复
   - 树木系统没有 TreeManager，作物系统不应该有 CropManager

2. **播种链路断裂**
   - GameInputManager.ExecutePlantSeed → CropManager.CreateCrop
   - CropManager.CreateCrop 使用全局 cropPrefab（而非 seedData.cropPrefab）
   - 场景中没有 CropManager 组件 → CreateCrop 静默失败 → 播种无效
   - 即使有 CropManager，全局 cropPrefab 也意味着所有作物用同一个预制体

3. **收获逻辑双重路径**
   - CropController.Harvest()（通过 IInteractable）
   - CropManager.TryHarvest()（通过外部调用）
   - 两者的重复收获 reGrowStage 计算不一致

4. **SeedData 仍有冗余字段**
   - growthDays（已被 CropStageConfig.daysToNextStage 替代）
   - harvestCropID、harvestAmountRange（10.0.3 计划替代）
   - 这些字段目前仍在被 CropController.HarvestMature 使用


### 3.2 CropManager vs TreeController 模式对比

| 维度 | TreeController（目标模式） | 当前农田系统（CropManager 模式） |
|------|--------------------------|-------------------------------|
| 创建方式 | 场景预设 或 DynamicObjectFactory 直接 Instantiate Prefab | GameInputManager → CropManager.CreateCrop（全局 cropPrefab） |
| 预制体来源 | 每棵树有自己的 Prefab（Inspector 配置一切） | CropManager 持有全局 cropPrefab，忽略 SeedData.cropPrefab |
| 生命周期管理 | TreeController 完全自治 | CropController 已自治，但 CropManager 仍在插手 |
| 查找机制 | 无集中注册表（通过 Physics/Raycast 查找） | CropManager.activeCrops 字典 |
| 收获/交互 | IResourceNode 接口，TreeController 自己处理 | IInteractable 接口 + CropManager.TryHarvest 双重路径 |
| 存档 | IPersistentObject，DynamicObjectFactory 重建 | IPersistentObject 已实现，DynamicObjectFactory 已支持 |
| Manager 存在 | 不存在 TreeManager | 存在 CropManager（Singleton） |

### 3.3 CropManager 的实际使用情况

通过代码追踪，CropManager 当前被以下位置调用：

1. **GameInputManager.ExecutePlantSeed()** — 调用 `CropManager.Instance.CreateCrop()`
2. **CropManager.TryHarvest()** — 被谁调用？需要确认（可能已经没有外部调用者）
3. **CropManager.GetCrop()** — 被 TryHarvest 内部使用
4. **CropManager.DestroyCrop()** — 被 TryHarvest 内部使用

关键发现：CropController 的 Harvest() 方法（通过 IInteractable 触发）完全不经过 CropManager。也就是说，CropManager.TryHarvest 可能已经是一条死路径。

### 3.4 独立思考：纠正方向建议

#### 核心结论

CropManager 应该被废弃。农田系统应该完全学习树木系统的模式：

1. **播种时直接 Instantiate SeedData.cropPrefab**，不经过 CropManager
2. **CropController 完全自治**，自己管理生命周期
3. **收获只走 IInteractable 路径**，废弃 CropManager.TryHarvest
4. **作物查找通过 FarmTileManager 或物理查询**，不需要 activeCrops 字典

#### 建议的纠正步骤（分优先级）

**P0 — 修复播种链路（让播种能跑通）**

当前播种完全不工作，因为：
- 场景中没有 CropManager 组件
- 即使有，CropManager 使用全局 cropPrefab 而非 seedData.cropPrefab

修复方案：修改 GameInputManager.ExecutePlantSeed()，绕过 CropManager，直接：
1. 从 SeedData 获取 cropPrefab
2. Instantiate 预制体
3. 调用 CropController.Initialize()
4. 向 FarmTileManager 注册占用

这与 DynamicObjectFactory.TryReconstructCrop 的逻辑一致。

**P1 — 废弃 CropManager**

- CropManager 标记 `[Obsolete]`
- 将 activeCrops 字典的查找功能迁移到 FarmTileManager（通过 cellPosition 查找 CropController）
- 废弃 CropManager.TryHarvest（收获只走 CropController.Harvest）
- 废弃 CropManager.CreateCrop（播种直接 Instantiate）
- 废弃 CropManager.DestroyCrop（CropController 自己销毁）

**P2 — 继续 10.0.3 的计划**

在 CropManager 废弃后，10.0.3 的收获 DropTable 改造会更干净：
- 只需要修改 CropController.HarvestMature()
- 不需要同步修改 CropManager.TryHarvest()
- 消除了双重路径的维护负担

#### 风险评估

| 风险 | 影响 | 缓解 |
|------|------|------|
| 废弃 CropManager 后，是否有其他代码依赖它 | 编译错误 | 全局搜索 CropManager 引用，逐一处理 |
| FarmTileManager 是否能承担作物查找职责 | FarmTileData 已持有 CropInstanceData，但没有 CropController 引用 | 可以在 FarmTileData 中新增 CropController 引用，或通过 cellPosition 查找 |
| 存档兼容性 | DynamicObjectFactory 已经使用 seedData.cropPrefab，不受影响 | 无风险 |
| InventoryBootstrap 种子注入 | 需要确保 SeedBagHelper.InitializeSeedBag() 被调用 | 这是独立 bug，与 CropManager 废弃无关 |

### 3.5 总结

农田系统经过 9.0.1 到 10.0.2 共 8 个工作区的迭代，CropController 已经成长为一个功能完整的自治控制器。但 CropManager 作为早期设计的遗留物，不仅没有跟上演进方向，反而成为了播种链路断裂的直接原因。

当前最紧迫的问题是播种不工作（场景无 CropManager + 全局 cropPrefab 设计错误）。纠正方向很明确：废弃 CropManager，让播种链路直接使用 SeedData.cropPrefab，与树木系统的模式完全对齐。

---

*报告完成，等待用户审核后决定后续行动方向。*
