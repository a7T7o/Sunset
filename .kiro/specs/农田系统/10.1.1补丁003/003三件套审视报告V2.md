# 补丁003 三件套全面审视报告 V2

> 审视目标：逐条审核 design.md 和 tasks.md 的合理性、可实施性、遗漏风险
> 审视原则：基于当前会话中实际读取的代码事实，不凭记忆推断
> V2 说明：基于用户四点反馈和代码事实核查，对 V1 报告进行全面修正重写。纠正内容直接融入正文，不再追加尾部修正章节。

---

## 一、P1/P5 作物位置修复 — 父子物体方案

### 1.1 问题根因（代码事实已验证）

CropController 第34行：`[RequireComponent(typeof(SpriteRenderer))]`
CropController Awake 第175行：`spriteRenderer = GetComponent<SpriteRenderer>()` — 获取自身的 SR
AlignSpriteBottom 第729行：`spriteRenderer.transform.localPosition` — 因为 SR 在自身上，等于直接修改 GameObject 的 localPosition，覆盖了 `Instantiate` 设置的正确世界坐标。

TreeController 的对比结构（注释第21-23行）：
```
Tree_M1_00 (父物体) ← 位置 = 树根 = 种植点
├─ Tree (SpriteRenderer) ← sprite底部对齐父物体中心
└─ Shadow (SpriteRenderer)
```
TreeController 用 `GetComponentInChildren<SpriteRenderer>()` 获取子物体的 SR，AlignSpriteBottom 修改子物体 localPosition，父物体世界坐标不受影响。

### 1.2 用户确认方案：套一层父物体

用户明确：采用类似 Rock C1.prefab 的结构，手动修改 Prefab：
- 父物体（空 Transform）放在格子中心
- 子物体 = 现有 Prefab 全部内容（SpriteRenderer + CropController + BoxCollider2D）
- AlignSpriteBottom 修改子物体 localPosition，父物体世界位置不受影响

### 1.3 方案评估：✅ 干净可行

此方案的优势：
- 不需要运行时迁移逻辑（design.md V1 的 Awake 检测+创建子物体方案完全不需要了）
- `[RequireComponent(typeof(SpriteRenderer))]` 保留（SR 仍在 CropController 同一 GameObject 上）
- `[SerializeField] spriteRenderer` 序列化值保留（仍指向同 GameObject 的 SR）
- `GetComponent<SpriteRenderer>()` 仍然能找到（因为 SR 在同一 GameObject）
- AlignSpriteBottom 代码无需修改（修改的是 `spriteRenderer.transform.localPosition`，现在 spriteRenderer 所在的 GameObject 是子物体，localPosition 相对于父物体）

### 1.4 需要注意的细节

1. 外部代码引用：如果有外部脚本通过 `transform.position` 获取作物位置，现在需要获取父物体的 position（格子中心），而不是子物体的 position（经过 AlignSpriteBottom 偏移后的位置）。CropController 自身的 `transform` 是子物体，`transform.parent.position` 才是格子中心。
   - 需要全局搜索确认哪些地方引用了 CropController 的 transform.position
   - **风险等级：中** — 需要验证

2. 存档加载兼容：`DynamicObjectFactory.TryReconstructCrop` 通过 `Instantiate(cropPrefab)` 创建，如果 Prefab 已经是父子结构，Instantiate 会保持结构，无需额外处理。
   - **风险等级：低**

3. 种植流程：`ExecutePlantSeed` 中 `Instantiate(seedData.cropPrefab, cropWorldPos, ...)` 会把整个 Prefab（父+子）放在 cropWorldPos。父物体在格子中心，子物体通过 AlignSpriteBottom 调整 localPosition。
   - **风险等级：低** — 逻辑正确

4. Prefab 批量修改：需要一个 Editor 工具或手动操作来给所有作物 Prefab 套一层父物体。
   - **风险等级：低** — 一次性操作

### 1.5 design.md 需要更新

- P1/P5 方案从"运行时 Awake 迁移"改为"手动修改 Prefab 结构"
- 移除 Awake 中的检测+迁移逻辑
- 新增 Editor 批量工具或手动操作指南
- 新增验证项：全局搜索 CropController 的 transform.position 引用


---

## 二、P3 队列逻辑修复：动画帧触发 tile 更新

### 2.1 延迟执行机制评估：✅ 方向正确

当前代码问题（已验证）：
- `ExecuteFarmAction` Till 分支（第2495行）：`FaceTarget` → `RequestAction(Crush)` → `ExecuteTillSoil` 三者同帧同步执行
- tile 在动画开始瞬间就完成变化，用户要求动画播放到约50%进度时才触发

design.md 的延迟执行方案（记录 `_pendingTileUpdate` + Update 监听进度）方向正确。

### 2.2 动画可打断性（代码事实核查 — 纠正 V1 错误）

V1 报告假设"动画可被 WASD 中断"，这是错误的。代码事实：

PlayerInteraction.PerformAction 第89行：
```csharp
if (isPerformingAction) return;  // 动画期间拒绝新的 RequestAction
```

HandleMovement 第437-446行：
```csharp
if (lockManager != null && lockManager.IsLocked)
{
    if (input.sqrMagnitude > 0.01f)
        lockManager.CacheDirection(input);  // 缓存方向，不执行移动
    playerMovement.SetMovementInput(Vector2.zero, false);
    return;  // 动画期间 WASD 被拦截
}
```

结论：动画播放期间不可被打断。`isPerformingAction` 守卫阻止新动画，`lockManager.IsLocked` 阻止 WASD 移动。

HandleMovement 第427-434行的队列中断逻辑：
```csharp
bool hasWASD = input.sqrMagnitude > 0.01f;
bool hasActiveQueue = _farmActionQueue.Count > 0 || _isProcessingQueue;
if (hasWASD && hasActiveQueue)
{
    ClearActionQueue();
    CancelFarmingNavigation();
    ...
    ToolActionLockManager.Instance?.ForceUnlock();
}
```
这段在 lockManager 检查之前，但只在有活跃队列时触发。单个动画播放期间（`_isProcessingQueue` 可能为 true），WASD 会触发 `ClearActionQueue` + `ForceUnlock`，然后继续到 lockManager 检查。但 `ForceUnlock` 解除了锁定，所以 WASD 可以在动画期间清空队列并开始移动。

等等，这里需要更仔细地分析：
- 动画播放中 → `_isProcessingQueue = true`（因为 ProcessNextAction 设置了它）
- WASD 按下 → `hasActiveQueue = true` → 进入中断分支
- `ClearActionQueue()` 清空队列，`_isProcessingQueue = false`
- `ForceUnlock()` 解除 lockManager 锁定
- 继续往下 → lockManager.IsLocked 现在为 false → 不会被拦截 → 正常移动

所以实际上：WASD 可以在动画期间通过 ForceUnlock 解除锁定并开始移动。但动画本身（`isPerformingAction`）仍然为 true，动画会继续播放到完成。只是玩家可以移动了。

这意味着：
- 动画不会被"中断"（动画继续播放到完成）
- 但玩家可以在动画播放期间移动（通过 ForceUnlock）
- 动画完成后 OnActionComplete 仍然会被调用

### 2.3 `_pendingTileUpdate` 清理场景（修正后）

前提：动画播放期间不可被打断（`isPerformingAction` 守卫 + `lockManager.IsLocked` 阻止 WASD 移动）。WASD 只能在动画完成后打断后续操作。

但补丁002新增的队列中断逻辑（HandleMovement 中 lockManager 检查之前）在有活跃队列时会触发 `ClearActionQueue` + `ForceUnlock`，解除锁定后玩家可以移动，但动画本身继续播放到完成。

基于上述分析，`_pendingTileUpdate` 的清理场景：

场景A：正常流程
- 动画播放 → 进度到50% → `_pendingTileUpdate` 被消费执行 → 动画完成 → OnActionComplete
- 无需额外清理

场景B：动画播放期间 WASD 输入触发队列中断（有活跃队列时）
- WASD 输入 → 补丁002队列中断逻辑触发 → `ClearActionQueue()` 清空队列 + `ForceUnlock()` 解除锁定
- 玩家可以移动了，但动画继续播放到完成
- 如果此时 `_pendingTileUpdate` 尚未被消费（进度<50%），动画继续播放到50%时仍然会触发 tile 更新
- 问题：用户已经 WASD 移走了，但 tile 更新仍然在原位置执行了
- **风险等级：高** — `ClearActionQueue` 必须同时清理 `_pendingTileUpdate`，并且清空队列内缓存的所有预览

场景C：动画完成后 WASD 打断后续操作（无活跃队列时）
- 动画正常完成 → `_pendingTileUpdate` 已在50%进度时被消费 → 无残留
- WASD 打断的是 OnActionComplete 中的后续操作（长按分支或队列下一个）
- 无 `_pendingTileUpdate` 清理问题

核心原则：只要 WASD 触发了打断，所有后续缓存都必须清除（`_pendingTileUpdate` + 队列 + 队列预览），确保干净回到 Idle 状态。

### 2.4 松开分支时序问题（代码事实已验证）

OnActionComplete 松开分支（第255-270行）：
```csharp
// 松开鼠标 → 通知队列取下一个
gimRelease.OnFarmActionAnimationComplete();  // ← 触发 ProcessNextAction
// ...
layerAnimSync?.ForceHideTool();
animController?.StopAnimationTracking();
isPerformingAction = false;                  // ← 太晚！
lockManager?.EndAction(false);
```

`OnFarmActionAnimationComplete` → `ProcessNextAction` → `ExecuteFarmAction(B)` → `RequestAction(Crush)` → `PerformAction` → 第89行 `if (isPerformingAction) return;` — 被拦截！

因为 `isPerformingAction = false` 在 `OnFarmActionAnimationComplete` 之后才执行。

design.md 的修复方案（`isPerformingAction = false` 移到 `OnFarmActionAnimationComplete` 之前）是正确的。

### 2.5 长按分支 vs 松开分支清理顺序不一致

长按分支（第230-238行）：
```csharp
animController?.StopAnimationTracking();
lockManager?.EndAction(false);
lockManager?.ClearAllCache();
isPerformingAction = false;
gimContinue.OnFarmActionAnimationComplete();
```
顺序：StopTracking → EndAction → ClearCache → isPerformingAction=false → OnFarmActionAnimationComplete

松开分支修复后应该是：
```
isPerformingAction = false → OnFarmActionAnimationComplete → ForceHideTool → StopTracking → EndAction → ...
```

两个分支清理顺序完全不同。建议统一，减少维护风险。
- **风险等级：中**


---

## 三、P2 长按退化修复

### 3.1 问题根因（代码事实已验证）

HandleUseCurrentTool 第703行：
```csharp
bool isFirstPress = Input.GetMouseButtonDown(0);
if (!isFirstPress) return;
```
注释写"改为 GetMouseButton 支持长按"，但代码用的是 `GetMouseButtonDown`，长按只触发一帧。

### 3.2 长按与队列是两种独立交互模式（纠正 V1 核心错误）

V1 报告错误地将长按和队列混为一谈。基于需求迭代分析：

- 10.1.0 AC-1.2：长按 = 动画结束后以当前鼠标位置启动新动作链
- 001 验收指南 B1-B5：长按锄头 = 耕完后继续获取当前鼠标位置耕下一块
- 002 design.md 1.1："废弃长按连续操作"（这是对用户意图的误解，003 需要恢复）

两种模式的正确定义：

| 维度 | 单击队列（FIFO） | 长按依次触发 |
|------|-----------------|-------------|
| 输入检测 | `GetMouseButtonDown(0)` | `GetMouseButton(0)` 持续按住 |
| 缓存方式 | FIFO 队列（多个位置） | 只缓存最近一个（当前鼠标位置） |
| 执行时机 | 队列出队时 | 动画完成瞬间 |
| 位置来源 | 入队时的鼠标位置 | 动画完成时的实时鼠标位置 |

### 3.3 正确的实现路径

- `HandleUseCurrentTool` 中 `GetMouseButtonDown(0)` → 走队列入队分支（保持不变）
- `OnActionComplete` 长按分支中检测 `Input.GetMouseButton(0)` 仍为 true → 获取当前鼠标位置执行下一个操作
- 两者通过输入检测自然区分，不冲突

OnActionComplete 长按分支（第224行）已经有 `shouldContinue = isCurrentlyHolding && IsToolAction(currentAction)` 的检测。农田工具的长按分支调用 `gimContinue.OnFarmActionAnimationComplete()`，这会走 `ProcessNextAction`。

需要修改的是：长按分支中，如果队列为空且仍在长按，应该获取当前鼠标位置执行新操作（而不是结束）。这是 design.md 任务5 的内容，方向正确。

### 3.4 design.md 任务4 需要修正

design.md 任务4 说"HandleUseCurrentTool 入口检测从 `GetMouseButtonDown` 改为 `GetMouseButton`"——这是错误的。

正确做法：`HandleUseCurrentTool` 的正常流程分支保持 `GetMouseButtonDown`（单击入队）。长按的连续执行由 `OnActionComplete` 长按分支处理，不需要改 HandleUseCurrentTool 的入口检测。

如果改为 `GetMouseButton`，会导致长按期间每帧都进入 HandleUseCurrentTool，鼠标扫过的每个格子都被入队——这不是用户想要的行为。

### 3.5 执行保护分支的行为

执行保护分支（第690行）：
```csharp
if (_isExecutingFarming || playerInteraction.IsPerformingAction())
{
    if (Input.GetMouseButtonDown(0) && ...)
        TryEnqueueFromCurrentInput();
    return;
}
```
这里用 `GetMouseButtonDown` 是正确的——动画期间只有新的单击才入队，长按不入队。长按的连续执行由 OnActionComplete 长按分支处理。

---

## 四、P4 导航入队统一

### 4.1 用户确认：所有单击都入队

用户明确：不存在"更新目的地"逻辑。所有单击事件都纳入队列。

### 4.2 当前代码的导航分支（第710-735行）

```csharp
if (_farmNavState == FarmNavState.Navigating || _farmNavState == FarmNavState.Locked)
{
    if (_isProcessingQueue)
    {
        TryEnqueueFromCurrentInput();
        return;
    }
    // ... 中断当前导航，重新开始
}
```

需要简化为：导航中的单击统一走入队，不中断当前导航。

### 4.3 方案评估：✅ 基本合理

导航中点击新位置 → 入队等待 → 当前导航正常完成 → ProcessNextAction 取下一个 → 判断距离 → 导航到新位置。

不需要取消旧导航（V1 报告的 V8 建议"取消旧导航"不适用）。旧导航会正常完成，完成后自动取队列下一个。

### 4.4 需要注意的边界情况

如果当前不在队列处理中（`_isProcessingQueue = false`）且正在导航（比如右键导航），入队后 `EnqueueAction` 内部会调用 `ProcessNextAction`。此时需要确保不会启动重复导航。

实际上如果 `_isProcessingQueue = false` 且正在农田导航，说明是非队列的导航场景。入队后启动队列处理是合理的——但需要先取消当前的非队列导航。

不过根据用户的简化方案，导航中的点击统一入队，这个边界情况可以通过确保 `_isProcessingQueue` 在导航期间为 true 来避免。
- **风险等级：低**


---

## 五、P6 预览系统改造

### 5.1 颜色叠加方案：⚠️ 有技术问题

design.md 方案：`ghostTilemap.SetColor(pos, new Color(0, 1, 0, 0.3f))` 实现绿色半透明叠加。

`Tilemap.SetColor` 的实际行为是对 Tile 颜色进行乘法混合（tint），不是叠加：
- 如果 Tile 本身是棕色（耕地），乘以绿色后 = 深绿棕色，不是"绿色半透明叠加"
- 红色同理：棕色 × 红色 = 深红棕色

这不是 design.md 描述的效果。

替代方案：
- 方案A（推荐）：在 GhostTilemap 上放置纯白色 Tile，然后 `SetColor` 设置半透明绿/红色。白色 × 绿色 = 纯绿色，效果正确。
- 方案B：创建专用的绿色/红色半透明 Sprite 作为 Tile 资源。
- 方案C：使用额外的 SpriteRenderer 覆盖层。

- **风险等级：高** — 必须修改 design.md 的颜色叠加实现方式

### 5.2 浇水图案预览

design.md 说"从 `FarmlandBorderManager` 或 `LayerTilemaps.waterPuddleTilemapNew` 获取水渍 Tile"，但没有具体 API 调用方式。需要实际验证 `waterPuddleTilemapNew` 上的 Tile 类型能否直接用于 GhostTilemap。
- **风险等级：中** — 需要验证 API

### 5.3 种子作物预览

从 `cropPrefab` 获取 `stages[0].normalSprite` 的可行性：
- `stages` 是 `[SerializeField] private CropStageConfig[] stages`（第44行）— private 字段
- 可以通过 `seedData.cropPrefab.GetComponent<CropController>()` 获取 Prefab 上的 CropController
- 但 `stages` 是 private，外部无法直接访问
- 需要添加 public 访问器（如 `public Sprite GetFirstStageSprite()`）或在 SeedData 上直接配置
- **风险等级：中** — 需要修改 CropController 添加公开方法

### 5.4 多位置队列预览与 ClearGhostTilemap 冲突：⚠️ 架构问题

ClearGhostTilemap（第801-810行）：
```csharp
private void ClearGhostTilemap()
{
    foreach (var pos in currentPreviewPositions)
        ghostTilemap.SetTile(pos, null);
    currentPreviewPositions.Clear();
}
```

当前逻辑：清除 `currentPreviewPositions` 中所有位置的 Tile。

问题：鼠标移动时 `UpdateHoePreview` 调用 `ClearGhostTilemap()` → 如果队列预览位置也在 `currentPreviewPositions` 中，会被一起清除。

解决方案：
- 方案A：队列预览和鼠标跟随预览使用不同的 Tilemap（新增 queuePreviewTilemap）
- 方案B：`ClearGhostTilemap` 改为只清除非队列位置（维护两个 position 集合）
- 方案C：队列预览不使用 Tilemap，而是用独立的 SpriteRenderer 对象池

- **风险等级：高** — design.md 完全没有提到这个架构冲突

---

## 六、跨问题交互风险

### 6.1 P3（延迟执行）+ P2（长按）— ✅ 无冲突

长按期间：A 动画播放 → 进度到50% → 触发 A 的 tile 更新 → A 动画完成 → OnActionComplete 长按分支 → 获取当前鼠标位置执行 B → B 动画 → 进度到50% → 触发 B 的 tile 更新。时序正确。

### 6.2 P3（延迟执行）+ P6（预览）— ✅ 视觉合理

tile 更新延迟到动画50%时执行，但预览在入队时就锁定了（LockPosition）。用户看到：预览显示 → 动画播放 → 50%时 tile 变化 → 预览消失。视觉上合理。

### 6.3 WASD 中断 + 队列清空 + 预览清除 — ⚠️ 有遗漏

WASD 移动 → `ClearActionQueue` → 队列清空。但：
- `_pendingTileUpdate` 没有被清理（design.md 遗漏）
- 预览的 `ClearAllQueuePreviews` 也需要在 `ClearActionQueue` 中调用
- **风险等级：高**


---

## 七、tasks.md 可实施性评估

### 7.1 任务粒度评估

| 任务 | 粒度 | 评估 |
|------|------|------|
| 1. CropController 子物体改造 | ⚠️ 需重写 | 方案已变更为手动修改 Prefab，不再是运行时迁移 |
| 2. 松开分支时序修复 | ✅ 合理 | 简单明确 |
| 3. 动画帧触发机制 | ✅ 合理 | 需补充 `_pendingTileUpdate` 清理子任务 |
| 4. 长按支持 | ⚠️ 需修正 | 不应改 HandleUseCurrentTool 入口为 GetMouseButton |
| 5. 长按连续执行 | ✅ 合理 | OnActionComplete 长按分支处理，方向正确 |
| 6. 导航入队统一 | ✅ 合理 | 简化为统一入队即可 |
| 7-10. 预览改造 | ⚠️ 需补充 | 缺少颜色叠加方案修正和架构分离任务 |
| 11. 多位置队列预览 | ⚠️ 需补充 | 与 ClearGhostTilemap 冲突未解决 |
| 12. 集成验证 | ✅ 合理 | 覆盖面足够 |

### 7.2 需要修改的任务

1. 任务1 重写：从"运行时 Awake 迁移"改为"手动修改 Prefab 结构 + Editor 批量工具"
   - 1.1 移除 → 不需要移除 `RequireComponent`（SR 仍在同一 GameObject）
   - 1.2 改为 → 编写 Editor 工具或手动操作：给每个作物 Prefab 套一层父物体
   - 1.3 改为 → 验证 `spriteRenderer` 字段仍然正确引用
   - 新增 → 全局搜索 CropController 的 `transform.position` 引用，确认无外部依赖

2. 任务3 补充：
   - 新增 → `ClearActionQueue` 中清理 `_pendingTileUpdate`
   - 新增 → WASD 中断时确保 `_pendingTileUpdate` 不会残留执行

3. 任务4 修正：
   - 4.1 删除 → 不应改入口检测为 `GetMouseButton`
   - 4.2-4.3 删除 → 不需要防重复入队逻辑（长按不走入队）
   - 整个任务4 应该删除或合并到任务5

4. 任务5 保留并明确：
   - OnActionComplete 长按分支：队列为空且仍在长按 → 获取当前鼠标位置 → 执行新操作
   - 这是长按连续执行的唯一实现路径

5. 任务7-11 前置：
   - 新增 → 颜色叠加方案修正（纯白 Tile + SetColor 或专用 Sprite）
   - 新增 → 队列预览与鼠标预览的架构分离（新增 Tilemap 或修改 ClearGhostTilemap）

6. 任务9 补充：
   - 新增 → CropController 添加 `public Sprite GetFirstStageSprite()` 方法

---

## 八、001/002 教训对照检查

### 8.1 001 的教训：边界情况遗漏

003 的对照检查：
- ✅ P1/P5 用户方案（手动修改 Prefab）彻底消除了运行时迁移的所有风险
- ⚠️ P3 的 `_pendingTileUpdate` 清理仍有遗漏
- ⚠️ P6 的 ClearGhostTilemap 与队列预览冲突未解决

### 8.2 002 的教训：设计阶段未充分验证 API 行为

003 的对照检查：
- ❌ `Tilemap.SetColor` 的行为（乘法而非叠加）未验证
- ❌ CropController.stages 是 private，外部无法获取第一阶段 Sprite
- ✅ `GetAnimationProgress()` 的行为已验证（基于时间计时器）
- ✅ `OnActionComplete` 的分支逻辑已详细分析
- ✅ 动画可打断性已通过代码事实核查

### 8.3 改进建议

- 每个修改点都应该列出"影响范围"
- 每个 API 调用都应该标注"已验证"或"待验证"
- 对于不确定的 API 行为，在 tasks.md 中添加"验证 API 行为"的前置任务


---

## 九、漏洞清单与优先级

| 编号 | 漏洞描述 | 风险等级 | 涉及问题 | 说明 |
|------|---------|---------|---------|------|
| V1 | `ClearActionQueue` 未清理 `_pendingTileUpdate` | 高 | P3 | WASD 中断队列后，已记录的 tile 更新仍会在动画50%时执行 |
| V2 | 长按/松开分支清理顺序不一致 | 中 | P3 | 两个分支的 StopTracking/EndAction/isPerformingAction 顺序不同，增加维护风险 |
| V3 | `Tilemap.SetColor` 是乘法混合不是颜色叠加 | 高 | P6 | 棕色耕地 × 绿色 ≠ 绿色半透明叠加，视觉效果完全不符预期 |
| V4 | ClearGhostTilemap 会清除队列预览 | 高 | P6 | 鼠标移动时清除所有预览位置，队列预览也被清除 |
| V5 | CropController.stages 是 private | 中 | P6 | 外部无法获取第一阶段 Sprite，需要添加公开方法 |
| V6 | design.md 任务4 方向错误 | 中 | P2 | 不应将 HandleUseCurrentTool 入口改为 GetMouseButton |
| V7 | 外部代码可能依赖 CropController 的 transform.position | 中 | P1/P5 | 套父物体后 CropController 的 transform 是子物体，position 经过偏移 |

### 高风险漏洞汇总（必须在更新 design.md 前解决）

1. V1 — `ClearActionQueue` 清理 `_pendingTileUpdate`：方案明确，直接在 `ClearActionQueue` 中加入 `_pendingTileUpdate = null`
2. V3 — 颜色叠加实现：改用纯白 Tile + SetColor，或使用专用半透明 Sprite
3. V4 — 预览架构分离：新增 queuePreviewTilemap 或修改 ClearGhostTilemap 逻辑

---

## 十、改进建议汇总

### 10.1 必须修改 design.md 的项目

1. P1/P5：方案从"运行时 Awake 迁移"改为"手动修改 Prefab 结构"
2. P2：删除任务4（不改 HandleUseCurrentTool 入口），保留任务5（OnActionComplete 长按分支）
3. P3：新增 `_pendingTileUpdate` 清理策略
4. P3：建议统一长按/松开分支的清理顺序
5. P6：颜色叠加改为纯白 Tile + SetColor 方案
6. P6：新增队列预览与鼠标预览的架构分离方案
7. P6：CropController 添加公开方法获取第一阶段 Sprite

### 10.2 必须修改 tasks.md 的项目

1. 任务1 重写：手动修改 Prefab + Editor 工具 + 全局搜索 transform.position 引用
2. 任务3 补充：`ClearActionQueue` 清理 `_pendingTileUpdate`
3. 任务4 删除或合并到任务5
4. 任务7-11 前置：颜色叠加方案修正 + 预览架构分离
5. 任务9 补充：CropController 添加公开方法

---

> V2 审视完成。相比 V1 的12个漏洞，V2 精简为7个（V1 的 V1/V2/V3/V6/V7 因用户方案变更而作废，V8 因用户明确"所有单击入队"而不再适用）。剩余的 V1（_pendingTileUpdate 清理）、V3（颜色乘法）、V4（预览冲突）是最可能导致验收 bug 的高风险项。
