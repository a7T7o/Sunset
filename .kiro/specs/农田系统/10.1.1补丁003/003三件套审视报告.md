# 补丁003 三件套全面审视报告

> 审视目标：逐条审核 design.md 和 tasks.md 的合理性、可实施性、遗漏风险
> 审视原则：基于当前会话中实际读取的代码事实，不凭记忆推断

---

## 一、P1/P5 作物位置修复 — 视觉子物体方案

### 1.1 方案合理性：⚠️ 有隐患

设计方案：Awake 中检测 SpriteRenderer 在自身上 → 创建 Visual 子物体 → 迁移 SpriteRenderer。

**代码事实**：
- CropController 第34行有 `[RequireComponent(typeof(SpriteRenderer))]`
- Awake 第174行：`spriteRenderer = GetComponent<SpriteRenderer>()`
- AlignSpriteBottom 第723行：修改 `spriteRenderer.transform.localPosition`
- spriteRenderer 是 `[SerializeField]` 字段（第80行），Prefab Inspector 上可能已经拖拽赋值

**发现的漏洞**：

1. **`RequireComponent` 与运行时销毁冲突**
   - `[RequireComponent(typeof(SpriteRenderer))]` 会阻止运行时 `Destroy(sr)`
   - Unity 会报错："Can't destroy SpriteRenderer because CropController depends on it"
   - design.md 任务1.1说"移除 RequireComponent"，但 tasks.md 没有验证移除后 Prefab 是否会出问题
   - **风险等级：高** — 如果忘记移除，运行时直接报错

2. **`[SerializeField] private SpriteRenderer spriteRenderer` 的序列化值**
   - Prefab 上 spriteRenderer 字段可能已经通过 Inspector 拖拽赋值指向自身的 SpriteRenderer
   - Awake 中 `if (spriteRenderer == null)` 检测会失败（因为序列化值不为 null）
   - 迁移逻辑不会触发，AlignSpriteBottom 继续修改自身 localPosition
   - **风险等级：严重** — 这是 design.md 完全没考虑到的场景

3. **SpriteRenderer 属性迁移完整性**
   - design.md 只写了"复制 sr 的关键属性到 newSR"，没有列出具体属性清单
   - 需要迁移的属性至少包括：sprite、color、sortingLayerID、sortingOrder、material、flipX、flipY、drawMode、maskInteraction
   - 遗漏任何一个都会导致视觉异常
   - **风险等级：中**

4. **其他脚本对 CropController.spriteRenderer 的引用**
   - UpdateVisuals 第692行直接操作 spriteRenderer.sprite 和 spriteRenderer.color
   - 如果迁移成功，spriteRenderer 指向子物体，这些操作是正确的
   - 但如果有外部脚本通过 `GetComponent<SpriteRenderer>()` 获取（而非通过 CropController 字段），迁移后会获取不到
   - **风险等级：低**（需要全局搜索确认）

### 1.2 改进建议

**方案A（推荐）：修改 Awake 检测逻辑**

```
Awake():
  // 不管 spriteRenderer 是否已序列化赋值，都检查它是否在自身上
  var selfSR = GetComponent<SpriteRenderer>();
  if (selfSR != null) {
    // 在自身上 → 必须迁移（无论 spriteRenderer 字段是否为 null）
    创建子物体并迁移
    DestroyImmediate(selfSR);  // RequireComponent 已移除，可以销毁
    spriteRenderer = newSR;
  } else {
    // 不在自身上 → 已经是子物体结构
    spriteRenderer = GetComponentInChildren<SpriteRenderer>();
  }
```

**方案B：不运行时迁移，直接修改 Prefab**
- 手动修改所有作物 Prefab：添加 Visual 子物体 + SpriteRenderer
- 移除自身的 SpriteRenderer
- 优点：不需要运行时迁移逻辑，更干净
- 缺点：需要手动修改每个 Prefab

**tasks.md 需要补充的验证项**：
- [ ] 验证移除 `[RequireComponent]` 后 Prefab 不报错
- [ ] 验证 `[SerializeField] spriteRenderer` 序列化值被正确覆盖
- [ ] 列出 SpriteRenderer 属性迁移清单并逐项验证
- [ ] 全局搜索 `GetComponent<SpriteRenderer>()` 在 CropController 相关上下文中的使用

---

## 二、P3 动画帧触发 tile 更新 — 延迟执行机制

### 2.1 方案合理性：⚠️ 有设计缺陷

**代码事实**：
- `PlayerAnimController.GetAnimationProgress()` 基于 `Time.time - _actionStartTime`，返回 0-1
- `toolAnimationDuration = 0.8f`
- `_isPerformingToolAction` 由 `StartAnimationTracking()` 设为 true，`StopAnimationTracking()` 设为 false
- `StopAnimationTracking()` 在 `OnActionComplete` 中调用

**发现的漏洞**：

1. **动画中断时 `_pendingTileUpdate` 的清理**
   - design.md 没有说明：如果玩家在动画进度 < 50% 时按 WASD 移动，`_pendingTileUpdate` 怎么处理
   - 当前代码中 `ClearActionQueue()` 会清空队列，但 design.md 没有在 ClearActionQueue 中加入清理 `_pendingTileUpdate` 的逻辑
   - 后果：如果不清理，下次动画可能误触发上次的 tile 更新
   - **风险等级：高**

2. **`GetAnimationProgress()` 在 `StopAnimationTracking()` 后返回 0**
   - 代码第267行：`if (!_isPerformingToolAction) return 0f;`
   - OnActionComplete 中先调用 `StopAnimationTracking()`，此后 `GetAnimationProgress()` 返回 0
   - 如果 Update 中的延迟执行监听在 OnActionComplete 之后的同一帧检查，会读到 0，永远不会触发
   - 但实际上 OnActionComplete 是在 Update 中 `IsAnimationFinished()` 返回 true 后触发的
   - 时序：Update → IsAnimationFinished=true → OnActionComplete → StopTracking
   - 问题：如果 `tileUpdateTriggerProgress=0.5` 但动画在 0.5 之前被中断（如切换工具），tile 更新永远不会执行
   - **风险等级：中** — 需要明确中断时的行为（是放弃 tile 更新还是立即执行）

3. **Update 轮询的帧精度**
   - `GetAnimationProgress()` 基于 `Time.time`，不是真实动画帧
   - 在低帧率下（如30fps），每帧间隔约33ms，0.8s动画只有约24个采样点
   - 50%进度点可能被跳过（从45%直接跳到55%），但 `>=` 比较可以处理
   - **风险等级：低** — `>=` 比较足够健壮

4. **同一帧内 RequestAction + 记录待执行的时序**
   - ExecuteFarmAction Till 分支：`RequestAction(Crush)` → 记录 `_pendingTileUpdate`
   - `RequestAction` 内部调用 `PerformAction` → `StartAction` → `StartAnimationTracking()`
   - 这意味着 `_actionStartTime = Time.time` 在记录 `_pendingTileUpdate` 之前设置
   - 同一帧的 Update 已经执行过了，下一帧才会检查进度
   - **时序正确**，无问题

### 2.2 松开分支时序修复

**代码事实**（OnActionComplete 松开分支，当前代码）：
```csharp
// 松开分支当前代码：
gimRelease.OnFarmActionAnimationComplete();  // ← 触发 ProcessNextAction
layerAnimSync?.ForceHideTool();
animController?.StopAnimationTracking();
isPerformingAction = false;                  // ← 太晚
lockManager?.EndAction(false);
ApplyCachedHotbarSwitch();
lockManager?.ClearAllCache();
```

**发现的漏洞**：

5. **`isPerformingAction = false` 提前后对通用工具分支的影响**
   - design.md 只说"移到 OnFarmActionAnimationComplete 之前"
   - 但松开分支不只处理农田工具，还处理通用工具（镐子/斧头）
   - 通用工具的松开分支也走这段代码
   - 如果 `isPerformingAction = false` 提前，通用工具的 `OnFarmActionAnimationComplete` 会调用 `ProcessNextAction`
   - 但通用工具不走队列系统，`ProcessNextAction` 会发现队列为空直接返回
   - **风险等级：低** — 队列为空时 ProcessNextAction 是安全的

6. **长按分支 vs 松开分支的时序不一致**
   - 长按分支（当前代码）：`StopTracking → EndAction → ClearCache → isPerformingAction=false → OnFarmActionAnimationComplete`
   - 松开分支（修复后）：`isPerformingAction=false → OnFarmActionAnimationComplete → ForceHideTool → StopTracking → EndAction → ...`
   - 两个分支的清理顺序完全不同
   - **建议**：统一两个分支的清理顺序，减少维护风险

### 2.3 改进建议

- `ClearActionQueue` 中必须加入 `_pendingTileUpdate = null` 清理
- 明确中断策略：动画被中断时，如果 tile 更新尚未触发，应该放弃（不执行）
- 统一长按/松开分支的清理顺序
- tasks.md 需要补充：验证 WASD 中断动画时 `_pendingTileUpdate` 被正确清理

---

## 三、P2 长按退化修复

### 3.1 方案合理性：⚠️ 有逻辑漏洞

**代码事实**：
- HandleUseCurrentTool 第703行当前用 `GetMouseButtonDown(0)`（只触发一帧）
- 执行保护分支（第690行）：`_isExecutingFarming || playerInteraction.IsPerformingAction()` 时，用 `GetMouseButtonDown(0)` 入队
- 正常流程分支（第703行）：也用 `GetMouseButtonDown(0)`

**发现的漏洞**：

1. **执行保护分支仍然用 `GetMouseButtonDown`**
   - design.md 只说改正常流程分支的入口检测
   - 但执行保护分支（第690行）也用 `GetMouseButtonDown(0)`
   - 长按期间，如果动画正在播放（`_isExecutingFarming = true`），执行保护分支拦截
   - 执行保护分支内部用 `GetMouseButtonDown(0)`，长按第二帧开始就不会触发
   - 这意味着长按期间只能在动画开始前入队一次，动画期间无法入队新位置
   - **但这可能是正确行为**：长按同一位置时不需要重复入队，由 OnActionComplete 长按分支处理重复执行
   - **风险等级：中** — 需要明确：长按移动鼠标到新位置时，是否应该在动画期间也能入队？

2. **`GetMouseButton` 每帧触发的性能和逻辑影响**
   - 改为 `GetMouseButton(0)` 后，每帧都会进入 HandleUseCurrentTool
   - 正常流程分支每帧都会执行到 `TryEnqueueFarmTool`
   - `TryEnqueueFarmTool` → `EnqueueAction` → `_queuedPositions.Contains(key)` 去重
   - 去重逻辑依赖 `_queuedPositions`，但 `OnFarmActionAnimationComplete` 中会 `Remove` 已执行的位置
   - 如果长按同一位置：A执行完 → Remove → 下一帧 GetMouseButton 触发 → 重新入队 → 执行B
   - **这实际上就是 design.md 任务5的"长按同一位置连续执行"**
   - 但 design.md 把这个逻辑放在 OnActionComplete 长按分支中，而不是 HandleUseCurrentTool 中
   - **两种实现路径冲突**：
     - 路径A：HandleUseCurrentTool 每帧检测 + EnqueueAction 去重 → 自动实现连续执行
     - 路径B：OnActionComplete 长按分支中手动重新入队
   - 如果两个都实现，会导致重复入队（虽然有去重，但逻辑冗余）
   - **风险等级：中** — 需要选择一种路径，不能两个都做

3. **长按移动鼠标时的行为**
   - 长按 + 移动鼠标 → 每帧检测新位置 → 如果新位置有效且不在队列中 → 入队
   - 这会导致鼠标扫过的每个格子都被入队
   - 用户可能只是在移动鼠标寻找目标，不想入队中间经过的格子
   - **风险等级：中** — 需要明确是否需要"首次按下入队 + 持续按住不入队新位置"的区分

### 3.2 改进建议

- 明确长按行为定义：
  - 方案A（简单）：只改正常流程分支为 `GetMouseButton`，执行保护分支保持 `GetMouseButtonDown`。长按同一位置的连续执行由 OnActionComplete 长按分支处理。
  - 方案B（完整）：正常流程分支用 `GetMouseButton` + 位置变化检测。只有鼠标位置变化时才入队新位置。
- 删除 tasks.md 任务5（OnActionComplete 长按分支重新入队），因为 HandleUseCurrentTool 的 `GetMouseButton` 已经自动实现了这个功能
- 或者保留任务5但删除 HandleUseCurrentTool 的 `GetMouseButton` 改造，只在 OnActionComplete 中处理

---

## 四、P4 导航入队统一

### 4.1 方案合理性：✅ 基本合理

**代码事实**：
- 当前导航分支（第714行）：导航中 + 队列处理中 → 入队；否则 → 中断导航重新开始
- 还有"点击同一位置不中断"的特殊处理

**发现的漏洞**：

1. **"中断导航重新开始"逻辑被移除后的边界情况**
   - 当前逻辑：导航中 + 非队列处理 + 新位置有效 → 中断导航 → 继续往下走正常入队
   - 改造后：统一入队
   - 但如果当前不在队列处理中（`_isProcessingQueue = false`），入队后 `EnqueueAction` 会立即调用 `ProcessNextAction`
   - `ProcessNextAction` 会判断距离，远距离会启动新导航
   - 问题：旧导航还在进行中，新导航又启动了
   - **需要确保入队前取消旧导航**
   - **风险等级：中**

### 4.2 改进建议

- 统一入队前，如果当前在导航中，先调用 `CancelFarmingNavigation()`
- tasks.md 任务6需要补充：验证导航中入队时旧导航被正确取消

---

## 五、P6 预览系统改造 — 范围最大、风险最高

### 5.1 颜色叠加方案

**代码事实**：
- `ghostTilemap` 是 `Tilemap` 组件
- 当前使用 `ghostTilemap.SetTile(pos, tile)` 设置预览 Tile
- `Tilemap.SetColor(pos, color)` 是 Unity API，可以对单个位置设置颜色
- 但 `SetColor` 是对 Tile 的颜色进行乘法混合（tint），不是叠加

**发现的漏洞**：

1. **`SetColor` 的行为不是"颜色叠加"而是"颜色乘法"**
   - `Tilemap.SetColor(pos, new Color(0, 1, 0, 0.3f))` 会将 Tile 的颜色乘以绿色
   - 如果 Tile 本身是棕色（耕地），乘以绿色后会变成深绿棕色，不是"绿色半透明叠加"
   - 红色同理：棕色 × 红色 = 深红棕色
   - **这不是 design.md 描述的"颜色叠加"效果**
   - **风险等级：高** — 视觉效果可能完全不符合预期

2. **替代方案**：
   - 方案A：使用白色 Tile + SetColor 设置半透明绿/红色 → 纯色半透明覆盖层
   - 方案B：创建专用的绿色/红色半透明 Sprite 作为 Tile
   - 方案C：使用 SpriteRenderer 覆盖层而非 Tilemap
   - **推荐方案A**：在 GhostTilemap 上放置纯白色 Tile，然后 SetColor 设置颜色，这样乘法结果就是纯色

### 5.2 浇水图案预览

**发现的漏洞**：

3. **水渍 Tile 的获取路径不明确**
   - design.md 说"从 FarmlandBorderManager 或 LayerTilemaps.waterPuddleTilemapNew 获取水渍 Tile"
   - 但没有具体说明 API 调用方式
   - 需要确认 `waterPuddleTilemapNew` 上的 Tile 是什么类型，能否直接用于 GhostTilemap 预览
   - **风险等级：中** — 需要实际验证 API

### 5.3 种子作物预览

4. **从 cropPrefab 获取 stages[0].normalSprite 的可行性**
   - `stages` 是 `[SerializeField] private CropStageConfig[] stages`（第44行）
   - cropPrefab 是未实例化的 Prefab
   - 可以通过 `seedData.cropPrefab.GetComponent<CropController>()` 获取 Prefab 上的 CropController
   - 但 `stages` 是 private 字段，外部无法直接访问
   - 需要添加 public 访问器或在 SeedData 上直接配置第一阶段 Sprite
   - **风险等级：中** — 需要修改 CropController 添加公开方法，或修改 SeedData

5. **`_seedPreviewSpriteRenderer` 的生命周期管理**
   - 创建临时 SpriteRenderer 需要创建 GameObject
   - 切换工具/退出种子模式时需要销毁
   - 多次切换可能导致 GameObject 泄漏
   - **风险等级：低** — 只要在 Hide/切换时正确销毁即可

### 5.4 多位置队列预览

6. **GhostTilemap 上的多位置预览与鼠标跟随预览的冲突**
   - 当前 `ClearGhostTilemap()` 会清除所有位置的 Tile
   - 鼠标移动时 `UpdateHoePreview` 调用 `ClearGhostTilemap()` → 队列预览也被清除
   - 需要将队列预览和鼠标跟随预览分离到不同的 Tilemap，或者 ClearGhostTilemap 只清除非队列位置
   - **风险等级：高** — 这是架构层面的冲突，design.md 完全没有提到

7. **`ClearGhostTilemap` 当前实现**
   - 清除 `currentPreviewPositions` 中所有位置的 Tile
   - 如果队列预览位置也在 `currentPreviewPositions` 中，会被一起清除
   - 如果队列预览位置不在 `currentPreviewPositions` 中，不会被清除，但鼠标移动到队列位置时会覆盖

### 5.5 改进建议

- 颜色叠加：改用纯白色 Tile + SetColor，或使用专用半透明 Sprite
- 多位置预览：需要新增一个独立的 Tilemap（queuePreviewTilemap），与 ghostTilemap 分离
- 种子预览：在 CropController 上添加 `public Sprite GetFirstStageSprite()` 方法
- tasks.md 需要大幅补充预览系统的架构改造任务

---

## 六、跨问题交互风险

### 6.1 P3（延迟执行）+ P2（长按）

- 长按期间，A 动画播放中 → 进度到 50% → 触发 tile 更新 → 动画继续 → 完成 → OnActionComplete
- OnActionComplete 长按分支 → OnFarmActionAnimationComplete → ProcessNextAction
- 如果 HandleUseCurrentTool 的 `GetMouseButton` 已经在 A 动画期间入队了 B
- ProcessNextAction 取出 B → 执行 B → B 动画播放 → 进度到 50% → 触发 B 的 tile 更新
- **时序正确**，无冲突

### 6.2 P3（延迟执行）+ P6（预览）

- tile 更新延迟到动画 50% 时执行
- 但预览在入队时就锁定了（LockPosition）
- 用户看到：预览显示 → 动画播放 → 50% 时 tile 变化 → 预览消失
- **视觉上合理**

### 6.3 P2（长按）+ P4（导航入队）

- 长按 + 鼠标移到远处 → 每帧入队新位置 → 队列中混合近距离和远距离目标
- ProcessNextAction 会对每个目标判断距离，远距离启动导航
- 但长按期间鼠标可能已经移走了，导航目标可能不是用户想要的
- **风险等级：中** — 这是 P2 长按行为定义不明确的延伸问题

### 6.4 动画中断 + 队列清空 + 预览清除

- WASD 移动 → ClearActionQueue → 队列清空
- 但 `_pendingTileUpdate` 没有被清理（design.md 遗漏）
- 预览的 `ClearAllQueuePreviews` 也需要在 ClearActionQueue 中调用
- **风险等级：高**

---

## 七、tasks.md 可实施性评估

### 7.1 任务粒度评估

| 任务 | 粒度 | 评估 |
|------|------|------|
| 1. CropController 子物体改造 | 合理 | 但缺少序列化值处理的子任务 |
| 2. 松开分支时序修复 | 合理 | 简单明确 |
| 3. 动画帧触发机制 | 合理 | 但缺少中断清理的子任务 |
| 4. 长按支持 | ⚠️ 有问题 | 与任务5逻辑冲突 |
| 5. 长按连续执行 | ⚠️ 有问题 | 可能被任务4自动实现，冗余 |
| 6. 导航入队统一 | 合理 | 但缺少取消旧导航的子任务 |
| 7-10. 预览改造 | ⚠️ 有问题 | 缺少架构层面的 Tilemap 分离任务 |
| 11. 多位置队列预览 | ⚠️ 有问题 | 与 ClearGhostTilemap 冲突未解决 |
| 12. 集成验证 | 合理 | 覆盖面足够 |

### 7.2 缺失的任务

1. **任务0（前置）：全局搜索 CropController 的 SpriteRenderer 引用**
   - 确认没有外部脚本直接 GetComponent<SpriteRenderer> 获取作物的渲染器

2. **任务1.2补充：处理 `[SerializeField] spriteRenderer` 已有序列化值的情况**
   - Awake 中不能用 `if (spriteRenderer == null)` 判断，必须用 `GetComponent<SpriteRenderer>()` 直接检测自身是否有 SR

3. **任务3补充：`ClearActionQueue` 中清理 `_pendingTileUpdate`**

4. **任务3补充：动画中断（WASD/切换工具）时清理 `_pendingTileUpdate`**

5. **任务4/5合并或二选一：避免长按逻辑冲突**

6. **任务6补充：导航中入队前取消旧导航**

7. **任务7-11前置：新增 queuePreviewTilemap 或修改 ClearGhostTilemap 逻辑**

8. **任务9补充：CropController 添加公开方法获取第一阶段 Sprite**

---

## 八、001/002 教训对照检查

### 8.1 001 的教训：边界情况遗漏

001 的问题是交互漏洞修补后仍有验收 bug，根因是没有充分考虑组件间交互。

003 的对照检查：
- ✅ P1/P5 方案考虑了存档加载兼容性
- ❌ P1/P5 没有考虑 `[SerializeField]` 序列化值的影响
- ❌ P3 没有考虑动画中断时的清理
- ❌ P6 没有考虑 ClearGhostTilemap 与队列预览的冲突

### 8.2 002 的教训：设计阶段未充分验证 API 行为

002 的问题是 FIFO 队列系统设计完成后验收发现6个严重问题，根因是设计阶段对代码细节的理解不够深入。

003 的对照检查：
- ❌ `Tilemap.SetColor` 的行为（乘法而非叠加）未验证
- ❌ 从未实例化的 Prefab 获取 private 字段的可行性未验证
- ❌ `RequireComponent` 与运行时 Destroy 的冲突未验证
- ✅ `GetAnimationProgress()` 的行为已验证（基于时间计时器）
- ✅ `OnActionComplete` 的分支逻辑已详细分析

### 8.3 共同模式：设计文档中的"伪代码"与实际代码的差距

001 和 002 的共同问题是设计文档中的伪代码看起来合理，但实际代码中有很多隐含的依赖和副作用没有被考虑到。

003 的改进建议：
- 每个修改点都应该列出"影响范围"（哪些其他方法/字段会受影响）
- 每个 API 调用都应该标注"已验证"或"待验证"
- 对于不确定的 API 行为，在 tasks.md 中添加"验证 API 行为"的前置任务

---

## 九、总结：漏洞清单与优先级

| 编号 | 漏洞描述 | 风险等级 | 涉及问题 |
|------|---------|---------|---------|
| V1 | `[RequireComponent]` 阻止运行时销毁 SpriteRenderer | 高 | P1/P5 |
| V2 | `[SerializeField] spriteRenderer` 序列化值导致迁移逻辑不触发 | 严重 | P1/P5 |
| V3 | SpriteRenderer 属性迁移清单缺失 | 中 | P1/P5 |
| V4 | 动画中断时 `_pendingTileUpdate` 未清理 | 高 | P3 |
| V5 | 长按分支 vs 松开分支清理顺序不一致 | 中 | P3 |
| V6 | 任务4（HandleUseCurrentTool GetMouseButton）与任务5（OnActionComplete 重新入队）逻辑冲突 | 中 | P2 |
| V7 | 长按移动鼠标时每帧入队新位置（扫过的格子全部入队） | 中 | P2 |
| V8 | 导航中入队未取消旧导航 | 中 | P4 |
| V9 | `Tilemap.SetColor` 是乘法混合不是颜色叠加 | 高 | P6 |
| V10 | ClearGhostTilemap 会清除队列预览 | 高 | P6 |
| V11 | CropController.stages 是 private，外部无法获取第一阶段 Sprite | 中 | P6 |
| V12 | `ClearActionQueue` 未清理 `_pendingTileUpdate` | 高 | P3+P4 |

---

## 十、改进建议汇总

### 10.1 必须修改 design.md 的项目

1. P1/P5：Awake 迁移逻辑改为基于 `GetComponent<SpriteRenderer>()` 检测，不依赖 `spriteRenderer == null`
2. P1/P5：列出 SpriteRenderer 属性迁移完整清单
3. P3：新增 `_pendingTileUpdate` 清理策略（ClearActionQueue + 动画中断）
4. P3：统一长按/松开分支的清理顺序
5. P2：明确长按行为定义，解决任务4/5冲突
6. P4：导航中入队前取消旧导航
7. P6：颜色叠加改为纯白 Tile + SetColor 方案
8. P6：新增 queuePreviewTilemap 或修改 ClearGhostTilemap 逻辑
9. P6：CropController 添加公开方法获取第一阶段 Sprite

### 10.2 必须修改 tasks.md 的项目

1. 任务1补充：验证 `[RequireComponent]` 移除、序列化值处理、属性迁移清单
2. 任务3补充：`ClearActionQueue` 清理 `_pendingTileUpdate`、动画中断清理
3. 任务4/5：合并或明确分工，避免逻辑冲突
4. 任务6补充：导航中入队前取消旧导航
5. 任务7-11前置：新增预览架构改造任务（Tilemap 分离或 ClearGhostTilemap 改造）
6. 任务9补充：CropController 添加公开方法
7. 新增前置验证任务：全局搜索 CropController 的 SpriteRenderer 引用

---

> 审视完成。以上12个漏洞中，V2（序列化值）、V4（中断清理）、V9（颜色乘法）、V10（预览冲突）、V12（队列清理遗漏）是最可能导致验收 bug 的高风险项。建议在更新 design.md 和 tasks.md 之前，先确认这些漏洞的修复方案。


---

## 十一、用户反馈修正（会话1续7）

> 基于用户对审视报告的四点反馈，结合当前会话重新读取的代码事实和历史需求文档，对审视报告进行修正。

### 11.1 第1点修正 — 作物预制体结构

用户方案：套一层父物体（父=空 Transform，子=现有 Prefab 含 SR+CropController），类似 Rock C1.prefab 结构。

Rock C1.prefab 实际结构（已验证）：
- 父物体 `C1`：Transform + OcclusionTransparency
- 子物体 `Rock`：SpriteRenderer + StoneController + PolygonCollider2D
- 子物体 localPosition.y = 1.34375（底部对齐偏移）

采纳用户方案后的影响：
- V1（`[RequireComponent]` 冲突）→ **不再适用**，不需要运行时销毁 SR
- V2（`[SerializeField]` 序列化值问题）→ **不再适用**，不需要运行时迁移
- V3（SR 属性迁移清单缺失）→ **不再适用**，不需要迁移属性

design.md P1/P5 需要改为：
- 手动修改作物 Prefab 结构（或编写 Editor 批量工具）
- 父物体放在格子中心，CropController + SR 在子物体上
- AlignSpriteBottom 修改子物体 localPosition，父物体世界位置不受影响
- CropController 的 `[RequireComponent(typeof(SpriteRenderer))]` 保留（SR 仍在同一 GameObject）
- `spriteRenderer` 字段的 `[SerializeField]` 保留（仍指向同 GameObject 的 SR）

### 11.2 第2点修正 — 动画不可被打断

代码事实（当前会话已验证）：
- `PerformAction` 第87行：`if (isPerformingAction) return;` — 动画期间新动画被拒绝
- `HandleMovement` 第437行：`lockManager.IsLocked` 时 WASD 被缓存不执行移动

结论：用户正确，动画播放期间不可被打断。

V4 修正：
- 原文："动画中断时 `_pendingTileUpdate` 未清理"
- 修正为："动画完成后 WASD 打断队列时 `_pendingTileUpdate` 未清理"
- 动画本身不会被中途打断，`_pendingTileUpdate` 在动画 50% 进度时正常触发
- 清理场景：动画完成后，WASD 触发 `ClearActionQueue` 时需要同时清理 `_pendingTileUpdate`
- 风险等级维持高，但原因不同

V12 修正：
- 原文："`ClearActionQueue` 未清理 `_pendingTileUpdate`"
- 修正为：仍然成立，`ClearActionQueue` 确实需要清理 `_pendingTileUpdate`
- 但触发场景是"队列被 WASD 清空"而非"动画被中断"

### 11.3 第3点修正 — 长按是独立交互模式

历史需求验证：
- 10.1.0 AC-1.2：长按 = 动画结束后以当前鼠标位置启动新动作链
- 001 验收指南 B1-B5：长按锄头 = 耕完后继续获取当前鼠标位置耕下一块
- 002 design.md 1.1："废弃长按连续操作"（这是对用户意图的误解）

用户明确：长按根本不是触发入队分支，而是单独的一个交互。

V6 修正：
- 原文："任务4（HandleUseCurrentTool GetMouseButton）与任务5（OnActionComplete 重新入队）逻辑冲突"
- 修正为：**V6 判断基础错误，整条作废**
- 长按不走入队，HandleUseCurrentTool 中 `GetMouseButtonDown(0)` 用于队列入队，`OnActionComplete` 长按分支用于长按连续执行
- 两者不冲突，因为它们处理的是不同的输入模式

V7 修正：
- 原文："长按移动鼠标时每帧入队新位置"
- 修正为：**V7 判断基础错误，整条作废**
- 长按不入队，不存在"每帧入队"的问题
- 长按只在动画完成瞬间获取当前鼠标位置执行一次

### 11.4 第4点修正 — 所有单击都入队

用户明确：所有单击事件都纳入队列，不存在"更新目的地"逻辑。

V8 修正：
- 原文："导航中入队未取消旧导航"
- 修正为：导航中点击新位置 → 入队等待 → 当前导航正常完成 → ProcessNextAction 取下一个
- 不需要取消旧导航，因为旧导航会正常完成后自动取队列下一个
- **V8 的"取消旧导航"建议不适用**，改为确保入队逻辑在导航期间正常工作即可
- 风险等级降为低

---

## 十二、修正后的漏洞清单

| 编号 | 原始描述 | 修正后状态 | 风险等级 |
|------|---------|-----------|---------|
| V1 | `[RequireComponent]` 阻止运行时销毁 SR | **作废**（用户方案不需要运行时销毁） | - |
| V2 | `[SerializeField]` 序列化值导致迁移不触发 | **作废**（用户方案不需要运行时迁移） | - |
| V3 | SR 属性迁移清单缺失 | **作废**（用户方案不需要迁移属性） | - |
| V4 | 动画中断时 `_pendingTileUpdate` 未清理 | **修正**：改为"队列被 WASD 清空时清理" | 高 |
| V5 | 长按/松开分支清理顺序不一致 | 维持 | 中 |
| V6 | 任务4和任务5逻辑冲突 | **作废**（长按和队列是独立模式） | - |
| V7 | 长按移动鼠标时每帧入队 | **作废**（长按不入队） | - |
| V8 | 导航中入队未取消旧导航 | **修正**：不需要取消，入队等待即可 | 低 |
| V9 | `Tilemap.SetColor` 是乘法混合 | 维持 | 高 |
| V10 | ClearGhostTilemap 会清除队列预览 | 维持 | 高 |
| V11 | CropController.stages 是 private | 维持 | 中 |
| V12 | `ClearActionQueue` 未清理 `_pendingTileUpdate` | 维持（触发场景修正） | 高 |

修正后仍有效的高风险漏洞：V4（修正版）、V9、V10、V12
