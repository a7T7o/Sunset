# 补丁003 全面分析与修复方案 V2

> V2 重构说明：结合 V2/V3 审视报告的所有已锁定方案和 7 个漏洞修补，基于代码事实重新组织。
> 来源：用户验收 002 补丁后报告的 6 个严重问题 + 审视报告 V2/V3 的全面纠正。
> 所有方案已锁定，无待确认项。

---

## 一、问题清单与已锁定方案总览

| 编号 | 严重度 | 问题描述 | 根因 | 已锁定方案 |
|------|--------|---------|------|-----------|
| P1/P5 | 🔴 致命 | 作物/种子位置完全错误 | AlignSpriteBottom 修改自身 localPosition 覆盖世界坐标 | 手动修改 Prefab 套父物体 |
| P2 | 🔴 严重 | 长按左键退化，只触发一次 | HandleUseCurrentTool 用 GetMouseButtonDown | 不改入口，由 OnActionComplete 长按分支处理 |
| P3 | 🔴 严重 | 队列 bug：近距离B地无动画直接变耕地 | ExecuteFarmAction 同帧同步执行 tile 更新 + 松开分支时序错误 | 动画帧触发 + `_pendingTileUpdate` + 时序修复 |
| P4 | 中等 | 导航期间预览变更 | 设计变更 | 所有左键统一入队 |
| P6 | 中等 | 预览系统全面优化 | 设计增强 | 种子复刻放置系统 + 耕地/浇水方案C + 双 Tilemap + 对象池 |

---

## 二、P1/P5 根因分析：作物/种子位置完全错误

### 2.1 根因（代码事实验证）

CropController 第34行：`[RequireComponent(typeof(SpriteRenderer))]`
CropController.Awake 第175行：`spriteRenderer = GetComponent<SpriteRenderer>()` — 获取自身 SR
AlignSpriteBottom 第723行：`spriteRenderer.transform.localPosition` — SR 在自身上，等于直接修改 GameObject 的 localPosition

对比 TreeController 的父子结构：
```
Tree_M1_00 (父物体) ← 位置 = 树根
├─ Tree (SpriteRenderer) ← GetComponentInChildren
└─ Shadow
```
TreeController 用 `GetComponentInChildren<SpriteRenderer>()` 获取子物体 SR，AlignSpriteBottom 只影响子物体 localPosition，父物体世界坐标不受影响。

### 2.2 已锁定方案：手动修改 Prefab 套父物体

学习 Rock C1.prefab 的结构，手动修改所有作物 Prefab：
- 父物体（空 Transform）放在格子中心
- 子物体 = 现有 Prefab 全部内容（SpriteRenderer + CropController + BoxCollider2D）

优势：
- 不需要运行时迁移逻辑
- `[RequireComponent(typeof(SpriteRenderer))]` 保留（SR 仍在 CropController 同一 GameObject）
- `GetComponent<SpriteRenderer>()` 仍然能找到
- AlignSpriteBottom 代码无需修改（修改子物体 localPosition，父物体不受影响）

### 2.3 注意事项

1. 外部代码引用：CropController 的 `transform` 现在是子物体，`transform.position` 经过 AlignSpriteBottom 偏移。需要全局搜索确认哪些地方引用了 CropController 的 transform.position（V7 漏洞）
2. 存档兼容：`DynamicObjectFactory.TryReconstructCrop` 通过 `Instantiate(cropPrefab)` 创建，Prefab 已是父子结构则自动保持
3. 种植流程：`ExecutePlantSeed` 中 `Instantiate(seedData.cropPrefab, cropWorldPos, ...)` 会把整个 Prefab（父+子）放在 cropWorldPos，逻辑正确
4. 需要 Editor 批量工具或手动操作给所有作物 Prefab 套父物体

---

## 三、P3 根因分析：队列 bug — 近距离B地无动画

### 3.1 根因1：tile 更新与动画同帧执行

ExecuteFarmAction Till 分支（第2495行）：
```csharp
FaceTarget(request.worldPos);                              // ① 朝向
playerInteraction?.RequestAction(AnimState.Crush);         // ② 播放动画
ExecuteTillSoil(request.layerIndex, request.cellPos);      // ③ 同帧立即执行！
```
③ 和 ② 在同一帧执行，tile 在动画开始瞬间就完成变化。用户要求动画播放到第四帧（约50%进度）时才触发。

### 3.2 根因2：松开分支时序错误

OnActionComplete 松开分支（第255行起）：
```csharp
gimRelease.OnFarmActionAnimationComplete();  // ← 触发 ProcessNextAction
// ...
isPerformingAction = false;                  // ← 太晚！
```
`OnFarmActionAnimationComplete` → `ProcessNextAction` → `ExecuteFarmAction(B)` → `RequestAction(Crush)` → `PerformAction` → `if (isPerformingAction) return;` — 被拦截。

### 3.3 已锁定方案

1. 延迟执行：ExecuteFarmAction 的 Till/Water 分支只做朝向+播放动画+记录 `_pendingTileUpdate`，Update 中监听动画进度 >= 0.5f 时执行
2. 时序修复：松开分支中 `isPerformingAction = false` 移到 `OnFarmActionAnimationComplete()` 之前
3. `_pendingTileUpdate` 清理策略（V1 漏洞）：`ClearActionQueue` 中必须清理 `_pendingTileUpdate = null`

### 3.4 `_pendingTileUpdate` 清理场景分析

场景A（正常）：动画播放 → 50%触发 → 消费完毕 → 无残留
场景B（WASD中断有活跃队列）：WASD → ClearActionQueue + ForceUnlock → 玩家移走，但动画继续播放 → 如果 `_pendingTileUpdate` 未清理，50%时仍会在原位置执行 tile 更新 → **必须在 ClearActionQueue 中清理**
场景C（动画完成后WASD）：动画正常完成 → `_pendingTileUpdate` 已消费 → 无残留

核心原则：只要 WASD 触发打断，所有后续缓存都必须清除（`_pendingTileUpdate` + 队列 + 队列预览）。

---

## 四、P2 根因分析：长按左键退化

### 4.1 根因

HandleUseCurrentTool 第703行：
```csharp
bool isFirstPress = Input.GetMouseButtonDown(0);
if (!isFirstPress) return;
```
注释写"改为 GetMouseButton 支持长按"但代码用的是 `GetMouseButtonDown`，长按只触发一帧。

### 4.2 已锁定方案（V3 审视报告纠正）

**不改 HandleUseCurrentTool 入口**（V6 漏洞纠正）。如果改为 `GetMouseButton`，长按期间每帧都进入 HandleUseCurrentTool，鼠标扫过的每个格子都被入队——不是用户想要的行为。

正确做法：
- HandleUseCurrentTool 保持 `GetMouseButtonDown`（单击入队）
- 长按连续执行由 OnActionComplete 长按分支处理：队列为空且仍在长按 → 获取当前鼠标位置 → 执行新操作
- 两种模式通过输入检测自然区分，不冲突

| 维度 | 单击队列（FIFO） | 长按依次触发 |
|------|-----------------|-------------|
| 输入检测 | `GetMouseButtonDown(0)` | `GetMouseButton(0)` 持续按住 |
| 缓存方式 | FIFO 队列（多个位置） | 只缓存最近一个（当前鼠标位置） |
| 执行时机 | 队列出队时 | 动画完成瞬间 |
| 位置来源 | 入队时的鼠标位置 | 动画完成时的实时鼠标位置 |

---

## 五、P4 设计变更：导航入队统一

### 5.1 已锁定方案

所有左键点击统一走入队逻辑。导航期间的点击不再中断导航，而是将新操作加入队列。

简化 HandleUseCurrentTool 中的导航状态分支：
- 导航中/执行中的左键点击 → 统一 `TryEnqueueFromCurrentInput`
- 移除"中断导航重新开始"的逻辑

---

## 六、P6 预览系统全面改造

### 6.1 种子预览：复刻放置系统树苗放置效果 — ✅ 已锁定

直接复刻 PlacementPreview 的树苗放置效果：
- 底部格子：程序化生成 32×32 白色方框 sprite（PlacementGridCell 方式），通过 `SetValid(bool)` 切换颜色
  - 有效：`validColor = new Color(0f, 1f, 0f, 0.4f)`（绿色）
  - 无效：`invalidColor = new Color(1f, 0f, 0f, 0.4f)`（红色）
- 物品预览：SpriteRenderer 显示作物第一阶段 sprite
  - 有效：`Color.white`（原色 + alpha）
  - 无效：`new Color(1f, 0.5f, 0.5f)`（偏红 + alpha）
- 有效条件：目标格子是已耕地且无作物（`isFarmland && !hasCrop`）

前置需求：CropController 添加 `public Sprite GetFirstStageSprite()` → 返回 `stages[0].normalSprite`（stages 是 private）

### 6.2 耕地预览：方案C（程序化 SpriteRenderer 覆盖层）— ✅ 已锁定

取消当前 `cursorRenderer` 方框光标，改为整个 tile 的颜色覆盖：
- 程序化生成纯色半透明方块（类似 PlacementGridCell 的 `CreateGridSprite`，但只要纯色填充，不要边框）
- 可交互 = 绿色半透明覆盖
- 不可交互 = 红色半透明覆盖
- 颜色完全可控，不受 tile 原色影响，不需要 shader

为什么不用 `Tilemap.SetColor`：SetColor 是乘法混合（tint），棕色耕地 × 绿色 = 深绿棕色，不是用户想要的"绿色覆盖"（V3 漏洞）。

### 6.3 浇水预览：随机水渍样式 + 颜色覆盖 — ✅ 已锁定

- FarmVisualManager 已有 `wetPuddleTiles`（`TileBase[]`，3种变体）
- 每次 `cellPos` 变化时 `Random.Range(0, 3)` 选一个变体
- 颜色覆盖：和耕地一样，方案C（程序化 SpriteRenderer 覆盖层）
- 需要 FarmVisualManager 暴露公开方法：`public TileBase[] GetPuddleTiles()` 或 `public TileBase GetRandomPuddleTile()`

### 6.4 队列预览：双 Tilemap 分离 + SpriteRenderer 对象池 — ✅ 已锁定

架构问题（V4 漏洞）：`ClearGhostTilemap` 清除 `currentPreviewPositions` 中所有位置，鼠标移动时队列预览也被清除。

解决方案：
- `ghostTilemap`（现有）→ 专门用于鼠标跟随预览
- 新增 `queuePreviewTilemap` → 专门用于队列锁定预览（原始 tile + 透明度，无颜色叠加）
- `ClearGhostTilemap` 只清除 `ghostTilemap`，不影响 `queuePreviewTilemap`
- 种子队列预览：独立 SpriteRenderer 对象池（作物第一阶段 sprite + 降低 alpha + 无颜色叠加）
- WASD 中断时 `ClearAllQueuePreviews` 清除 `queuePreviewTilemap` + 回收对象池

### 6.5 预览区分

| 预览类型 | 鼠标跟随预览 | 队列锁定预览 |
|---------|-------------|-------------|
| 耕地 | 方案C 颜色覆盖（绿/红） | 原始 tile + 透明度，无颜色 |
| 浇水 | 水渍 tile + 方案C 颜色覆盖 | 水渍 tile + 透明度，无颜色 |
| 种子 | 底部格子方框 + 物品 sprite + 颜色切换 | 物品 sprite + 降低 alpha，无格子 |

---

## 七、漏洞修补清单（V3 审视报告 7 个漏洞）

| 编号 | 漏洞 | 风险 | 修补方案 |
|------|------|------|---------|
| V1 | `ClearActionQueue` 未清理 `_pendingTileUpdate` | 高 | ClearActionQueue 中加入 `_pendingTileUpdate = null` |
| V2 | 长按/松开分支清理顺序不一致 | 中 | 统一两个分支的清理顺序 |
| V3 | `Tilemap.SetColor` 是乘法混合 | 高 | 方案C 已锁定（程序化 SpriteRenderer 覆盖层） |
| V4 | `ClearGhostTilemap` 会清除队列预览 | 高 | 双 Tilemap 分离方案已锁定 |
| V5 | `CropController.stages` 是 private | 中 | 添加 `GetFirstStageSprite()` 公开方法 |
| V6 | design.md 任务4 方向错误 | 中 | 删除任务4，长按由 OnActionComplete 处理 |
| V7 | 外部代码可能依赖 CropController 的 transform.position | 中 | 全局搜索验证 |

---

## 八、修复优先级与依赖关系

```
P1/P5（作物位置）→ 独立，最高优先级
P3（队列逻辑 + 帧触发）→ 核心队列执行逻辑
P2（长按）→ 依赖 P3 的 OnActionComplete 改造
P4（导航入队）→ 依赖 P3 的队列系统
P6（预览改造）→ 依赖 P3/P4 + 前置接口暴露
```

建议修复顺序：P1/P5 → P3（含 V1/V2 漏洞修补）→ P2 → P4 → P6 前置接口 → P6 预览改造
