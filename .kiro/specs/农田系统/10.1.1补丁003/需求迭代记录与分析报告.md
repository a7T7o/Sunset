# 需求迭代记录与分析报告

> 目的：梳理农田系统交互需求从 10.1.0 到 003 的完整迭代脉络，确保对用户意图的理解准确无误
> 创建时间：2026-02-19 会话1续7
> 工作区：`.kiro/specs/农田系统/10.1.1补丁003/`

---

## 一、需求迭代时间线

### 1.1 10.1.0 — 原始需求定义

核心交互模型定义了两种独立的输入模式：

| 模式 | 触发方式 | 行为 | 来源 |
|------|---------|------|------|
| 单击缓存 | `GetMouseButtonDown(0)` | 动画期间缓存最后一次点击，动画结束后消费缓存执行完整动作链 | AC-1.1 |
| 长按连续 | `GetMouseButton(0)` | 动画结束后自动以当前鼠标位置作为输入，启动新的完整动作链 | AC-1.2 |

关键约束（AC-1.2 原文）：
- 长按左键时，动画结束后自动以当前鼠标位置作为缓存输入
- 如果当前鼠标位置有效，启动新的完整动作链
- 如果无效，不执行任何操作，回到 Idle
- 长按不应对同一块已耕作的地重复播放空动画

导航中重新输入（AC-1.3）：
- 导航途中点击新位置 → 中断当前导航 → 更新预览 → 重新导航到新位置

### 1.2 补丁001 — 交互漏洞修补

用户确认的行为规范（design.md Q1-Q4）：

长按行为细化：
- 长按 = 快速连续输入，只有第一个位置生效并锁定
- 长按期间预览框跟随鼠标（不锁定）
- 动画完成瞬间锁定当前鼠标位置作为下一个目标
- 耕完后如果仍在长按，获取此时鼠标位置并锁定执行

实现方案（方案B）：
- `OnActionComplete` 长按分支区分农田工具和通用工具
- 农田工具：`EndAction → isPerformingAction=false → ProcessFarmInputAt(鼠标位置)` 或 `ConsumePendingFarmInput`
- 通用工具：保持原有 `StartAction(repeat)` 行为

验收指南 B1-B5 定义了长按的具体测试场景：
- B1：长按锄头近距离 → 耕完第一块后继续获取当前鼠标位置耕下一块
- B2：长按锄头远距离 → 耕完后导航到鼠标位置再耕
- B3：长按浇水壶 → 与锄头一致
- B4/B5：长按镐子/斧头 → 原地连续（保持原有行为）

### 1.3 补丁002 — FIFO 队列化改造

用户确认的目标交互模式（design.md 1.1）：
- 锄头/浇水/种子/收获全部改为「连续左键点击 + FIFO 队列缓存」
- **废弃长按连续操作**（P1 原始需求的长按方案被用户否决）
- 收获从右键迁移到左键，优先级最高
- 镐子/斧头等通用工具保持原有长按行为不变

关键变更：
- `CacheFarmInput`（单缓存）→ `EnqueueAction`（FIFO 队列）
- `ConsumePendingFarmInput` → `ProcessNextAction`
- 导航中重新点击 → 入队等待（不再中断导航更新目的地）

### 1.4 补丁003 — 002 验收后的修复

用户报告的6个严重问题：
1. 作物位置完全错误（AlignSpriteBottom 结构性问题）
2. 耕地/浇水长按退化（HandleUseCurrentTool 用 GetMouseButtonDown）
3. 连续左键队列 bug（OnActionComplete 松开分支时序错误）
4. 取消导航期间预览变更 → 改为连续左键直接入队
5. 种子坐标错误（与问题1同源）
6. 连续点击队列需全面优化

---

## 二、关键需求演变分析

### 2.1 长按行为的演变

| 版本 | 长按定义 | 与队列的关系 |
|------|---------|-------------|
| 10.1.0 | 动画结束后以当前鼠标位置启动新动作链 | 独立于队列，只缓存最近一个 |
| 001 | 动画完成瞬间锁定当前鼠标位置执行 | 独立于队列，由 OnActionComplete 长按分支处理 |
| 002 | **废弃**（design.md 明确写"废弃长按连续操作"） | 被队列取代 |
| 003 | 用户报告"长按退化" → 需要恢复 | **与队列并存，两种独立模式** |

002 的"废弃长按"决策是用户在 002 设计阶段确认的。但 003 验收时用户报告"长按退化"，说明用户期望长按功能仍然存在。

这意味着 002 的"废弃长按"理解有误——用户想要的是：
- 单击 → 入队（FIFO）
- 长按 → 不入队，而是动画完成后自动以当前鼠标位置执行下一个（只缓存最近一个）

两种模式完全独立，不应混淆。

### 2.2 导航中重新点击的演变

| 版本 | 行为 |
|------|------|
| 10.1.0 | 中断当前导航 → 更新预览 → 重新导航到新位置 |
| 002 | 队列处理中 → 入队等待；非队列处理 → 中断导航重新开始 |
| 003（用户明确） | 所有单击事件都纳入队列，不存在"更新目的地"逻辑 |

用户在 003 反馈中明确：不存在"正在导航到A点时点击B点触发更新目的地直接去B点"的逻辑。所有点击都是入队。

### 2.3 作物预制体结构的演变

| 版本 | 结构 |
|------|------|
| 当前 | CropController + SpriteRenderer 在同一 GameObject 上 |
| 003 design.md | 运行时迁移：Awake 中创建 Visual 子物体 |
| 003 审视报告方案B | 手动修改 Prefab |
| 用户明确 | 套一层父物体（父=空Transform，子=现有Prefab内容），类似 Rock/Stone 结构 |

Rock C1.prefab 的实际结构（当前会话已验证）：
- 父物体 `C1`：Transform + OcclusionTransparency
- 子物体 `Rock`：SpriteRenderer + StoneController + PolygonCollider2D + PersistentId
- 子物体 localPosition.y = 1.34375（底部对齐偏移）

用户要的作物结构：
- 父物体 `CropRoot`：只有 Transform（放置在格子中心）
- 子物体 `Crop`：SpriteRenderer + CropController + BoxCollider2D（现有 Prefab 的全部内容）
- AlignSpriteBottom 修改子物体的 localPosition，不影响父物体的世界位置

---

## 三、两种输入模式的最终定义

基于用户在 003 反馈中的明确表述，最终的交互模型如下：

### 3.1 模式一：单击队列（FIFO）

- 触发：`GetMouseButtonDown(0)`（每次按下触发一次）
- 行为：将目标位置入队，FIFO 依次执行
- 动画期间点击：入队等待
- 导航期间点击：入队等待（不中断当前导航）
- 队列去重：同一 (layerIndex, cellPos) 不重复入队

### 3.2 模式二：长按依次触发

- 触发：`GetMouseButton(0)`（持续按住）
- 行为：动画完成后自动获取当前鼠标位置，执行下一个操作
- 不入队：只缓存最近一个位置（当前鼠标位置）
- 适用工具：锄头、浇水壶、种子
- 通用工具（镐子/斧头）：保持原有 `StartAction(repeat)` 行为

### 3.3 两种模式的区分

- 单击 = `GetMouseButtonDown(0)` 为 true 的那一帧 → 走队列入队
- 长按 = `GetMouseButton(0)` 为 true 但 `GetMouseButtonDown(0)` 为 false → 走长按缓存
- 两种模式在 `HandleUseCurrentTool` 中通过输入检测自然区分
- `OnActionComplete` 长按分支：检测 `Input.GetMouseButton(0)` 仍为 true → 获取当前鼠标位置执行

### 3.4 关键区别

| 维度 | 单击队列 | 长按依次触发 |
|------|---------|-------------|
| 输入检测 | GetMouseButtonDown | GetMouseButton（持续） |
| 缓存方式 | FIFO 队列（多个） | 只缓存最近一个（当前鼠标位置） |
| 执行时机 | 队列出队时 | 动画完成瞬间 |
| 位置来源 | 入队时的鼠标位置 | 动画完成时的实时鼠标位置 |
| 导航行为 | 入队等待 | 动画完成后判断距离 |

---

## 四、动画可打断性分析

### 4.1 代码事实（当前会话已验证）

`PerformAction` 第87行：
```csharp
if (isPerformingAction) return;  // 动画期间拒绝新的 RequestAction
```

`HandleMovement` 中 lockManager 检查（第437行）：
```csharp
if (lockManager != null && lockManager.IsLocked)
{
    if (input.sqrMagnitude > 0.01f)
        lockManager.CacheDirection(input);  // 缓存方向，不执行移动
    playerMovement.SetMovementInput(Vector2.zero, false);
    return;  // 动画期间 WASD 被拦截
}
```

### 4.2 结论

用户是对的：动画播放期间不可被打断。

- `isPerformingAction` 守卫阻止了新的动画请求
- `lockManager.IsLocked` 阻止了 WASD 移动
- WASD 只能在动画完成后打断后续操作（队列中的下一个、或长按的下一个）

补丁002新增的队列中断逻辑（HandleMovement 第427行）在 lockManager 之前，但只在有活跃队列时触发。单个动画播放期间（无队列），lockManager 仍然阻止移动。

### 4.3 审视报告 V4 的修正

V4 原文："动画中断时 `_pendingTileUpdate` 未清理"

修正：动画本身不会被中断。`_pendingTileUpdate` 的清理场景应该是：
- 动画正常完成后，如果 WASD 打断了后续队列操作 → ClearActionQueue 需要清理 `_pendingTileUpdate`
- 动画正常完成后，tile 更新已在 50% 进度时执行完毕 → `_pendingTileUpdate` 已被消费
- 唯一需要清理的场景：动画完成但 tile 更新尚未触发（理论上不应发生，因为 50% < 100%）

实际上 `_pendingTileUpdate` 的清理仍然重要，但原因不是"动画中断"，而是"队列被 WASD 清空时，可能有尚未执行的 tile 更新残留"。

---

## 五、总结

本报告梳理了从 10.1.0 到 003 的需求迭代脉络，核心发现：

1. 长按和队列是两种完全独立的交互模式，002 的"废弃长按"是对用户意图的误解
2. 所有单击事件都纳入队列，不存在"更新目的地"逻辑
3. 动画播放期间不可被打断，只有动画完成后才能被 WASD 打断后续操作
4. 作物预制体应采用"套一层父物体"模式，类似 Rock 的结构

这些理解将作为后续更新审视报告和改进方案的基础。
