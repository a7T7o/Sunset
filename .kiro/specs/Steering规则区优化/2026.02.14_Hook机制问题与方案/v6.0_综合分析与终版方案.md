# Hook v6.0 综合分析与终版方案

## 一、用户原始 Prompt 完整摘抄

> 首先很明确你的判断完全是对的了，但是你看下图，这里是你刚刚继承过的对话内容，现在你的输出内容很混乱，包含你的分析，没有明确的工作格式，而且甚至你没有在对应的继承memory文件夹创建继承memory快照，我也没办法检查你的创建格式是否正确但是你看你之前虽然判断错误，但是书写格式是完美的，简洁高效，下图这个内容是你之前的版本时候触发继承时hook执行的情况，虽然确实是在继承后但是判断错误了，可是去除判断逻辑，原来的内容和步骤是完全正确的，.kiro\specs\Steering规则区优化\2026.02.14_Hook机制问题与方案\v4.5Hook.md，大致是这个版本附近的情况，你可以参照这个记录下来的4.5内容进行分析现在就是要结合历代版本所有的优点进行结合，并且彻底完善，把所有bug都修复

## 二、问题诊断

### 2.1 v5.3 当前版本的问题（截图1证据）

v5.3 的判断逻辑终于正确了（标记方案有效），但输出格式严重退化：

| 问题 | 具体表现 |
|------|----------|
| 输出格式混乱 | 包含"最后一条真实用户消息是..."等分析性文字，不是简洁的步骤式报告 |
| 没有步骤编号 | v4.x 有清晰的"第零步→分支一→执行"流程，v5.3 变成了自由发挥 |
| 没有创建快照 | 继承恢复场景下应该创建快照但没有（注：这次判断为没压缩是对的，但格式问题仍然存在） |

### 2.2 v4.5 版本的优点（截图2证据）

v4.5 虽然判断逻辑有 bug（压缩检测不准），但执行格式堪称完美：

| 优点 | 具体表现 |
|------|----------|
| 步骤式输出 | "第零步：IS_COMPRESSING = 否/是" → "分支一：..." → 执行 |
| 简洁高效 | 每步一行，不多说一个字 |
| 流程清晰 | 读者一眼就能看出 Hook 做了什么判断、执行了什么操作 |
| 快照格式完整 | 包含用户 prompt 完整摘抄、AI 进度、修改文件、智能补充 |

### 2.3 v5.0Hook.md 完整版的优点

| 优点 | 具体表现 |
|------|----------|
| 真实用户消息定义精确 | 明确排除 ADDITIONAL_INSTRUCTIONS / steering-reminder / 工具返回 / Hook prompt |
| 检测逻辑精确 | 找最后一条真实用户消息→检查其后 AI 回复末尾是否有标记（不是"存在任何标记"） |
| 分支逻辑完整 | 分支一（正常）+ 分支二（压缩）+ 子检查（主 memory 同步） |

### 2.4 v5.3 锐评分析的优点

| 优点 | 具体表现 |
|------|----------|
| 输出格式锁定 | 只允许 4 种固定回复格式 |
| 逐条黑名单 | 6 条❌独占一行，约束力强 |
| 立即停止指令 | "完成后立即停止" |
| 角色锁定 | "你是记录员" |

## 三、历代版本优缺点对比

| 维度 | v4.5 | v5.0Hook.md | v5.3（当前） |
|------|------|-------------|-------------|
| 压缩检测准确性 | ❌ 低（关键词匹配失败） | ✅ 高（标记方案+精确定位） | ✅ 高（标记方案） |
| 输出格式 | ✅ 完美（步骤式） | ✅ 完美（步骤式） | ❌ 混乱（自由发挥） |
| 快照创建流程 | ✅ 完整（5步） | ✅ 完整（5步） | ⚠️ 有模板但缺步骤 |
| 约束力 | ✅ 强（白名单+黑名单） | ✅ 强（白名单+黑名单） | ✅ 强（6条黑名单） |
| 真实用户消息定义 | ❌ 缺失 | ✅ 精确 | ✅ 精确 |
| Token 消耗 | ~1200 | ~1500 | ~920 |
| 标记格式 | 带时间戳 | 带时间戳 | 无时间戳（【输出完毕】） |

## 四、v6.0 终版方案设计

### 4.1 设计原则

1. 压缩检测：采用 v5.x 的标记方案（准确率最高）
2. 检测逻辑：采用 v5.0Hook.md 的精确定位（最后一条真实用户消息→其后 AI 回复末尾）
3. 输出格式：采用 v4.5 的步骤式报告（简洁高效）
4. 约束力：采用 v5.3 锐评分析的逐条黑名单 + 输出格式锁定
5. 快照流程：采用 v5.0Hook.md 的 5 步快照创建
6. 标记格式：【输出完毕】（无时间戳，v5.2 已确认）

### 4.2 v6.0 Hook Prompt 草案

```
你是记录员。唯一职责：判断是否需要更新 memory 和/或创建继承快照，需要则执行，然后停止。

===== 第零步：压缩检测 =====
找最后一条真实用户消息（= 用户在聊天框输入的内容，包括 CONTEXT TRANSFER 继承消息）。
排除：ADDITIONAL_INSTRUCTIONS / steering-reminder / 工具返回 / Hook prompt。
检查该消息之后 AI 回复末尾是否有【输出完毕】。
- 有 → IS_COMPRESSING = 否
- 没有 → IS_COMPRESSING = 是

===== 分支一：正常 memory 更新 =====
- 无实质工作 → 回复「不需要更新」，跳到分支二
- memory 已更新过 → 检查主 memory 是否同步：
  · 主 memory 未同步 且 IS_COMPRESSING = 否 → 追加主 memory
  · 主 memory 未同步 且 IS_COMPRESSING = 是 → 跳过
  · 主 memory 已同步 → 无需操作
  跳到分支二
- 有工作且未更新 → 执行：
  1. 追加子 memory 会话记录
  2. IS_COMPRESSING = 否 → 追加主 memory 摘要
  3. IS_COMPRESSING = 是 → 跳过主 memory
  跳到分支二

===== 分支二：继承快照（仅 IS_COMPRESSING = 是） =====
IS_COMPRESSING = 否 → 流程结束，停止。
IS_COMPRESSING = 是 → 执行：
1. 确定子工作区路径
2. 创建 继承会话memory/ 文件夹（如不存在）
3. 创建快照文件（{YYYY-MM-DD}_{会话N}_{续N}.md）
4. 快照内容：
   · 用户 prompt 完整摘抄（不删减）
   · AI 进度摘要（已完成/未完成）
   · 修改文件列表
   · 智能补充（可能丢失的上下文）

===== 输出格式（严格执行） =====
必须按步骤输出，每步一行：
```
第零步：IS_COMPRESSING = 否/是（原因简述）
分支一：[判断结果]（执行了什么操作）
分支二：[跳过/执行]（执行了什么操作）
```
最终回复只允许以下格式之一：
- 「不需要更新」
- 「已更新子 memory」
- 「已更新子 memory + 主 memory」
- 「已更新子 memory + 创建继承快照」

===== 禁止事项 =====
❌ 禁止读取任何代码文件
❌ 禁止运行任何命令
❌ 禁止执行任何未完成的任务
❌ 禁止输出恢复报告或分析
❌ 禁止修改 memory/快照以外的文件
❌ 禁止规划、建议、讨论后续工作
完成后立即停止。不多说一个字。
```

### 4.3 v5.3→v6.0 变更对比

| 维度 | v5.3 | v6.0 |
|------|------|------|
| 输出格式 | 只规定了 4 种最终回复 | 规定了步骤式中间输出 + 4 种最终回复 |
| 步骤报告 | ❌ 无（导致自由发挥） | ✅ 每步一行（第零步→分支一→分支二） |
| 分支二流程 | 只有 4 项模板 | 完整 4 步执行流程（确定路径→创建文件夹→创建文件→写入内容） |
| 分支一→分支二衔接 | ❌ 缺失（分支一结束后没有明确跳到分支二） | ✅ 每个分支一出口都写了"跳到分支二" |
| Token 消耗 | ~920 | ~1100 |

### 4.4 关键 bug 修复清单

| Bug | 来源版本 | v6.0 修复方式 |
|-----|---------|-------------|
| 压缩检测不准（关键词匹配） | v4.0-v4.4 | 标记方案（v5.x 已修复） |
| "存在任何标记"导致永远判断没压缩 | v5.0 | 精确定位"最后一轮 AI 回复末尾"（v5.1 已修复） |
| 输出格式混乱（自由发挥） | v5.3 | 强制步骤式输出格式 |
| 分支一结束后不跳分支二 | v5.3 | 每个出口明确写"跳到分支二" |
| 快照创建流程缺失步骤 | v5.3 | 恢复完整 4 步流程 |
| 时间戳无法精确获取 | v5.0-v5.1 | 去掉时间戳（v5.2 已修复） |

## 五、待用户确认

1. v6.0 草案是否可以执行？
2. 输出格式中的"步骤式中间输出"是否满足你对"简洁高效"的要求？
3. Token 消耗从 ~920 增加到 ~1100，是否可接受？（增加的部分全部用于步骤式输出格式和分支衔接）
