# Phase 4.1 - 使用场景深度分析与规则行为化方案

**创建日期**: 2026-02-12
**前置文档**: Phase4.0方案设计.md
**目标**: 基于实际使用频次分析，将"静态规则"转变为"动态行为"，同时优化上下文恢复机制

---

## 一、实际使用场景频次分析

### 你的日常工作模式（从工作区历史推断）

| 场景 | 频率 | 占比 | 典型操作 |
|------|------|------|---------|
| 阅读锐评 → 审核 → 执行/回应 | 极高 | ~40% | 读锐评文件、事实核查、生成审视报告或直接执行 |
| 按 tasks.md 执行任务 | 高 | ~25% | 读三件套、写代码、更新 memory |
| 文档讨论/方案设计 | 高 | ~20% | 讨论方案、写设计文档、写分析报告 |
| 规则/Steering 维护 | 中 | ~10% | 修改 steering 文件、优化规则 |
| 纯代码调试/修 bug | 低 | ~5% | 直接改代码、不走三件套流程 |

### 关键发现

1. **锐评处理是最高频场景**，但 code-reaper-review.md 是 manual 加载
2. **文档工作占比远超代码工作**，但当前规则体系偏向代码规范
3. **上下文继承最常发生在**：锐评阅读中途、长任务执行中途
4. **对话模式高度固定**：用户给文件路径 → AI 阅读 → AI 分析/执行 → 更新 memory


---

## 二、当前规则中"应该是行为而不是静态文本"的内容

### 什么叫"应该是行为"？

静态规则 = 每次加载到上下文里，AI 被动遵守
行为（Hook） = 在特定事件触发时，AI 主动执行一个动作

区别在于：静态规则消耗 Token 但可能用不上；Hook 只在需要时触发，且能强制执行动作。

### 逐条分析

#### 1. 锐评处理流程（code-reaper-review.md）→ 应转为 Hook

**当前状态**: manual 加载，~800 tokens
**问题**: 你每次给我锐评文件路径时，我需要先加载这个规则才知道怎么处理。但你说的对——锐评处理是最高频场景，流程又是固定的。

**应该变成的行为**:
- 当用户消息中包含"锐评"、"阅读"、文件路径含"锐评"时
- Hook 自动提醒 AI：加载 code-reaper-review.md，按流程处理
- 同时提醒：认同度高→直接执行不中断；认同度低→生成回应文档不在对话框写满

**节省**: 不需要每次手动 # 加载，也不需要在 rules.md 里写锐评相关规则

#### 2. 上下文恢复（000-context-recovery.md）→ 应升级为智能恢复 Hook

**当前状态**: always 加载，~400 tokens
**问题**: 你说得很准——当前的恢复机制太机械。每次都停下来问你确认，但很多时候任务很明确（比如你刚给了一个锐评路径，继承后我应该知道你要我读那个锐评）。

**应该变成的行为**:
- 检测到继承对话时，不是机械地列出"请确认"
- 而是：回顾继承前的最后一条用户消息和我的最后输出
- 判断任务是否明确：
  - 明确（如"阅读这个锐评"）→ 直接复述任务并继续执行，不等确认
  - 不明确（如多个并行任务、复杂讨论）→ 才需要确认
- 关键改进：准确回顾"继承前用户的最后诉求"和"我输出的最后状态"

#### 3. Memory 更新提醒 → 应转为 agentStop Hook

**当前状态**: workspace-memory.md 中的规则，~2,500 tokens 的一部分
**问题**: "每次对话结束前必须更新 memory"这条规则，靠 AI 自觉遵守。但上下文继承时经常来不及更新。

**应该变成的行为**:
- 创建 `agentStop` 类型的 Hook
- 每次 AI 停止输出时，Hook 提醒：检查是否需要更新 memory
- 这比"写在规则里希望 AI 记住"要可靠得多

#### 4. 修改文件后列出清单 → 应转为 postToolUse Hook

**当前状态**: rules.md 和 000-context-recovery.md 中都有这条规则
**问题**: 这条规则在两个文件里重复写了，而且靠 AI 自觉。有时候改了很多文件后会漏列。

**应该变成的行为**:
- 创建 `postToolUse` 类型的 Hook，监听 write 类工具
- 每次写入文件后，Hook 自动记录修改的文件
- 在回复结束时自动汇总

**注意**: 这个 Hook 可能触发太频繁（每次 fsWrite/strReplace 都触发），需要评估 Token 成本。如果成本太高，保留为静态规则可能更合适。

#### 5. 锐评认同度判断 → 应内化到锐评 Hook 的提示词中

**当前状态**: code-reaper-review.md 中的路径 A/B/C 分流
**你的诉求**: 认同度高就直接简要说明可行然后开始执行；认同度低就生成回应文档而不在对话框里写满内容

**应该变成的行为**:
- 在锐评 Hook 的提示词中明确：
  - 核查全通过 → 一句话"核查通过，开始执行"，直接干
  - 有重大异议 → 直接创建审视报告文件，对话中只说"已生成审视报告，请查看"
  - 不要在对话框里写大段分析（浪费上下文空间）

#### 6. 文档写入规范 → 放宽阈值，保持静态规则（不用 Hook）

**当前状态**: rules.md 中的规则，~300 tokens，阈值设为 40 行
**问题**: 
- 40 行的阈值太保守，实际上一次写 100-150 行完全没问题
- 只有超过 ~200 行时才容易触发写入中断（aborted）
- 如果用 preToolUse Hook，每次 write 都触发（一次对话 5-20 次），Token 成本 ~400-1,600，不划算

**结论：放宽阈值 + 保持静态规则，不转 Hook**

精简后的规则（替换当前 rules.md 中的文档写入规范）：
```
## 文档写入规范
- fsWrite 首次创建文件：建议不超过 150 行
- fsAppend 追加内容：每次不超过 150 行
- 超过 200 行的内容必须分段写入
- 不要在表格或代码块中间断开
- 如果写入被中断（aborted），从断点用 fsAppend 继续
```

**节省**: 规则从 ~300 tokens 精简到 ~100 tokens，且不需要 Hook 的额外开销


---

## 三、上下文恢复机制升级方案

### 当前问题

你截图里展示的就是典型场景：每次继承都机械地输出"上下文恢复检查"然后等你说 bingo。这有几个问题：

1. **浪费一轮对话**：你说 bingo，我才开始工作，白白消耗一轮上下文
2. **有时候我以为做完了但其实没做完**：比如你让我读锐评，我开始读了但继承发生在读的过程中，继承后我可能以为已经读完了
3. **不够智能**：不管任务多明确，都要停下来问

### 升级方案：智能恢复

将 `000-context-recovery.md` 从"静态规则"升级为"智能判断"：

```
检测到继承对话
    ↓
回顾继承摘要中的关键信息：
  - 用户最后一条消息的完整内容
  - 我最后的输出状态（是否完成、进行到哪一步）
    ↓
判断任务明确度
    ├─ 明确且未完成 → 直接复述任务 + 继续执行
    │   例："你让我阅读锐评003，继承前我正在阅读中，现在重新读取并继续"
    │
    ├─ 明确且已完成 → 简述完成状态 + 等待新指令
    │   例："上一轮我已完成锐评003的执行，等你的下一步指示"
    │
    └─ 不明确/多任务 → 才需要列出回顾并请求确认
        例：复杂的多步骤讨论、方向性决策中断
```

### 关键改进点

1. **准确回顾继承前状态**：不是猜测，而是从 Conversation Summary 中提取"用户最后诉求"和"AI 最后输出"
2. **区分"进行中"和"已完成"**：如果摘要显示我正在执行某个操作（如"正在阅读文件"），继承后应该重新执行而不是假设已完成
3. **减少不必要的确认**：任务明确时直接干，不要显得业余
4. **保留确认机制作为兜底**：只在真正不确定时才问

### 具体规则文本（替换当前 000-context-recovery.md）

```markdown
# 上下文恢复

## 检测条件
输入中有 Conversation Summary / 对话摘要 / summarized = 继承对话

## 恢复流程

### 第一步：提取关键信息
从继承摘要中提取：
1. 用户最后一条消息的核心诉求
2. AI 最后的输出状态（完成/进行中/等待确认）
3. 当前工作区和子工作区路径

### 第二步：判断并行动

**情况 A：任务明确 + 未完成**
→ 输出一句话复述任务，然后直接继续执行
→ 格式："🔄 继承恢复：你让我[任务描述]，继承前我[进度]，现在继续。"
→ 不等确认，直接开始

**情况 B：任务明确 + 已完成**
→ 简述完成状态，等待新指令
→ 格式："🔄 继承恢复：上一轮已完成[任务]，等你的下一步指示。"

**情况 C：任务不明确 / 多个并行任务**
→ 列出回顾，请求确认
→ 这是唯一需要等待确认的情况

### 第三步：重新获取必要上下文
- 如果任务涉及特定文件（如锐评），重新 readFile 获取
- 不要假设继承前已经读过的文件内容还在上下文中
- 继承 = 上下文清空，所有文件都需要重新读取
```

### 与 Hook 的配合

上下文恢复规则本身应该保持 `always` 加载（因为它只有 ~400 tokens，且每次继承都需要）。但可以配合 promptSubmit Hook 使用：

- 恢复规则负责：判断是否继承、决定行动路径
- Hook 负责：根据恢复后的任务内容，加载对应的领域规则


---

## 四、Hook 体系设计

基于使用场景分析，建议创建以下 Hook：

### Hook 1：规则路由（promptSubmit）— 已在 Phase 4.0 设计

每次用户发消息时，根据内容按需加载 steering 规则文件。
这个不再赘述，参见 Phase4.0 步骤 2。

### Hook 2：锐评流程守卫（promptSubmit）

**触发条件**: 用户消息中包含"锐评"、"阅读"、文件路径含"锐评"
**目的**: 强制执行锐评处理流程，避免不规范行为

```json
{
  "name": "锐评流程守卫",
  "version": "1.0.0",
  "description": "检测到锐评相关任务时，强制执行标准锐评处理流程",
  "when": {
    "type": "promptSubmit"
  },
  "then": {
    "type": "askAgent",
    "prompt": "检查用户消息是否涉及锐评处理（关键词：锐评、阅读锐评、审查、Code Reaper，或文件路径含'锐评'）。如果是，执行以下流程：1）先用 readFile 加载 .kiro/steering/code-reaper-review.md 获取完整流程规范 2）完整阅读锐评文件 3）进行事实核查 4）判断认同度：认同度高（核查全✅）→ 一句话说明'核查通过，开始执行'然后直接执行，不中断会话；认同度低（有❌）→ 直接创建审视报告文件，对话中只简述异议要点，不在对话框写大段分析。核心原则：减少对话框中的冗余输出，重要内容写到文件里。"
  }
}
```

**这个 Hook 解决的问题**：
- 不需要每次手动 # 加载 code-reaper-review.md
- 强制执行"认同就直接干、不认同就写文件"的流程
- 避免在对话框里写满分析内容然后再问"要不要创建文档"

### Hook 3：Memory 更新提醒（agentStop）

**触发条件**: AI 停止输出时
**目的**: 确保每次对话结束前都更新 memory

```json
{
  "name": "Memory更新检查",
  "version": "1.0.0",
  "description": "AI 停止输出时检查是否需要更新 memory",
  "when": {
    "type": "agentStop"
  },
  "then": {
    "type": "askAgent",
    "prompt": "检查本次对话是否有实质性工作（代码修改、文档创建、锐评执行、方案讨论等）。如果有，检查是否已更新对应工作区的 memory.md。如果没更新，立即追加本次会话记录到 memory.md（包括：用户需求、完成任务、修改文件）。如果本次只是简单问答/闲聊，不需要更新。注意：memory 只追加不修改历史记录。"
  }
}
```

**这个 Hook 解决的问题**：
- 不再依赖 AI 自觉记住"结束前更新 memory"
- 即使上下文快满了，agentStop 时也会触发提醒
- 减少"忘记更新 memory"的情况

### ~~Hook 4：文档写入守卫~~ → 取消，改为精简静态规则

**原方案**: preToolUse Hook，每次 write 前检查内容长度
**取消原因**: 
- 每次 write 都触发（一次对话 5-20 次），Token 成本 ~400-1,600，不划算
- 实际上一次写 100-150 行完全没问题，只有 200+ 行才容易中断
- 原规则的 40 行阈值太保守，导致不必要的分段

**替代方案**: 在 rules-core.md 中保留精简版静态规则（~100 tokens）：
- fsWrite/fsAppend 每次不超过 150 行
- 超过 200 行必须分段
- 被中断（aborted）时从断点用 fsAppend 继续
- 不在表格/代码块中间断开


---

## 五、Hook 与静态规则的分工

### 最终架构

```
┌─────────────────────────────────────────────────────┐
│ 第一层：always 加载（~2,000 tokens）                  │
│                                                       │
│  000-context-recovery.md（升级版，~500 tokens）        │
│  rules-core.md（精简版，~1,500 tokens）               │
│    - 最高优先级规则（玩家位置/碰撞/遮挡）              │
│    - 绝对禁止事项                                     │
│    - Unity 6 API                                      │
│    - 核心语言规则（中文优先）                          │
│    - 核心禁令（禁止覆盖/删除/可选任务）               │
│    - 先设计后实现                                     │
│    - 新增并兼容                                       │
└─────────────────────────────────────────────────────┘
         ↓ 每次对话自动加载

┌─────────────────────────────────────────────────────┐
│ 第二层：Hook 驱动行为（~250 tokens/次触发）           │
│                                                       │
│  Hook 1: 规则路由（promptSubmit）                     │
│    → 按需加载领域规则文件                              │
│                                                       │
│  Hook 2: 锐评流程守卫（promptSubmit）                 │
│    → 检测锐评任务，强制执行标准流程                    │
│    → 认同→直接干；不认同→写文件不写对话框              │
│                                                       │
│  Hook 3: Memory 更新提醒（agentStop）                 │
│    → 对话结束前检查 memory 是否已更新                  │
└─────────────────────────────────────────────────────┘
         ↓ 事件触发时自动执行

┌─────────────────────────────────────────────────────┐
│ 第三层：manual 按需加载                               │
│                                                       │
│  layers.md          - 层级/楼层/放置                  │
│  communication.md   - 一条龙模式/完整沟通规范          │
│  workspace-memory.md - 完整 memory 规范/格式模板       │
│  animation.md       - 动画系统                        │
│  ui.md              - UI 系统                         │
│  trees.md           - 树木系统                        │
│  so-design.md       - SO 设计                         │
│  items.md           - 物品系统                        │
│  systems.md         - 时间/导航/遮挡                  │
│  coding-standards.md - 编码规范                       │
│  等等...                                              │
└─────────────────────────────────────────────────────┘
         ↓ Hook 自动加载 或 用户 # 手动加载
```

### 哪些内容从静态规则移到了 Hook

| 原来的位置 | 内容 | 移到哪里 | 理由 |
|-----------|------|---------|------|
| rules.md | 智能规则加载章节（~800 tokens） | Hook 1 替代 | Hook 比静态规则更可靠 |
| rules.md | 文档写入规范（~300 tokens） | Hook 4 强制执行 | 靠自觉不如靠 Hook |
| rules.md + 000-context-recovery.md | 修改文件后列出清单 | 保留在 rules-core.md | Hook 触发太频繁，成本不划算 |
| code-reaper-review.md | 锐评处理流程 | Hook 2 自动触发加载 | 最高频场景，不应该手动加载 |
| workspace-memory.md | memory 更新提醒 | Hook 3 强制执行 | 结束前更新 memory 是刚需 |
| 000-context-recovery.md | 机械式确认 | 升级为智能恢复 | 减少不必要的确认轮次 |


---

## 六、Hook 合并优化：减少 promptSubmit Hook 数量

### 问题

Hook 1（规则路由）和 Hook 2（锐评流程守卫）都是 promptSubmit 类型。如果两个都存在，每次用户发消息都会触发两个 Hook，消耗双倍 Token。

### 方案：合并为一个 promptSubmit Hook

将规则路由和锐评流程守卫合并为一个 Hook，在提示词中同时处理两个职责：

```json
{
  "name": "智能助手",
  "version": "1.0.0",
  "description": "每次用户发消息时：1）按需加载领域规则 2）检测锐评任务并执行标准流程",
  "when": {
    "type": "promptSubmit"
  },
  "then": {
    "type": "askAgent",
    "prompt": "执行两个检查：【规则路由】分析用户消息，如涉及以下领域且规则未加载，用 readFile 静默加载（不告诉用户）：层级/楼层→layers.md | 动画→animation.md | UI→ui.md | SO/物品ID→so-design.md+items.md | 物品/背包→items.md | 时间/导航/遮挡→systems.md | 树木→trees.md | 放置→placeable-items.md | 农田/作物→archive/farming.md | 日志/Debug→debug-logging-standards.md | 编码/命名→coding-standards.md | 一条龙→communication.md | 工作区/memory→workspace-memory.md | 场景修改→scene-modification-rule.md。路径前缀：.kiro/steering/。【锐评检测】如果用户消息涉及锐评（关键词：锐评、阅读锐评、审查，或文件路径含'锐评'），额外加载 code-reaper-review.md，并按以下流程处理：完整阅读→事实核查→认同度高则一句话说明后直接执行不中断→认同度低则直接创建审视报告文件，对话中只简述异议要点。"
  }
}
```

### 合并后的 Token 消耗

- 单个 Hook 提示词：~350 tokens（比两个分开的 ~500 tokens 少 30%）
- 每次消息只触发一次，不是两次
- 净节省：~150 tokens/消息

### 最终 Hook 清单（2 个）

| Hook | 类型 | 触发频率 | Token 成本 |
|------|------|---------|-----------|
| 智能助手 | promptSubmit | 每条消息 | ~350 tokens |
| Memory 更新检查 | agentStop | 每次停止 | ~100 tokens |

---

## 七、上下文恢复的具体改进

### 当前 000-context-recovery.md 的问题

1. **机械确认**：不管任务多明确都要等用户说 bingo
2. **状态误判**：继承后可能以为已经完成了实际上还在进行中的操作
3. **没有重新获取**：继承后不会主动重新读取之前正在处理的文件

### 改进后的规则文本

保持 `inclusion: always`，但内容升级：

```markdown
# 上下文恢复

## 检测条件
输入中有 Conversation Summary / 对话摘要 / summarized = 继承对话

## 恢复流程

### 1. 提取关键信息
从继承摘要中精确提取：
- 用户最后一条消息的完整内容（原文）
- AI 最后的输出状态：是"已完成"还是"正在执行中"
- 当前工作区路径

### 2. 判断并行动

**任务明确 + 正在执行中**（最常见的继承场景）
→ 格式："🔄 继承恢复：你让我[复述用户原始诉求]，继承前我正在[具体进度]，现在重新获取文件并继续。"
→ 立即重新 readFile 获取相关文件，继续执行
→ 不等确认

**任务明确 + 已完成**
→ 格式："🔄 继承恢复：上一轮已完成[任务摘要]。等你的下一步指示。"
→ 等待用户新指令

**任务不明确 / 多个并行任务 / 方向性讨论中断**
→ 列出回顾，请求确认（当前的格式）
→ 这是唯一需要等确认的情况

### 3. 关键原则
- 继承 = 上下文完全清空，之前读过的文件内容都不在了
- 必须重新 readFile 获取正在处理的文件
- 不要假设"我已经读过了"——继承后你没读过
- 复述用户的原始诉求比复述自己的进度更重要
```

### 与截图中场景的对比

**当前行为**（你截图中的）：
```
🔄 上下文恢复检查
用户最近的核心要求：Phase 4.0 方案设计文档...
当前进度：已完成...待完成...
请确认：以上理解是否正确？
```
→ 你说 bingo → 我才开始工作 → 浪费一轮

**改进后的行为**：
```
🔄 继承恢复：你让我完成 Phase 4.0 方案设计文档的剩余章节，
继承前我已写完前6章，现在继续写步骤3、六、七、八。
```
→ 直接开始写 → 省掉一轮确认


---

## 八、规则内容的"行为化"改造总结

### 改造前后对比

| 规则内容 | 改造前 | 改造后 | 效果 |
|---------|--------|--------|------|
| 智能规则加载 | rules.md 中 ~800 tokens 静态文本 | Hook 1（promptSubmit）自动执行 | 从被动遵守→主动执行 |
| 锐评处理流程 | manual 加载 code-reaper-review.md | Hook 2（promptSubmit）自动触发 | 最高频场景不再需要手动加载 |
| 锐评认同度分流 | 规则文本描述路径 A/B/C | Hook 提示词中强制：认同→直接干，不认同→写文件 | 杜绝"对话框写满分析再问要不要建文档" |
| Memory 更新 | workspace-memory.md 中的规则 | Hook 3（agentStop）自动提醒 | 不再依赖 AI 自觉 |
| 文档写入分段 | rules.md 中 ~300 tokens，阈值 40 行 | 精简静态规则，阈值放宽到 150 行 | 减少不必要的分段，节省 ~200 tokens |
| 上下文恢复 | 机械式确认模板 | 智能判断：明确→直接干，不明确→才确认 | 省掉不必要的确认轮次 |
| 修改文件列清单 | 两个文件中重复写 | 保留在 rules-core.md（Hook 成本太高） | 去重，保持静态 |

### 改造原则

1. **高频固定流程 → Hook**：锐评处理、memory 更新这种每次都要做的固定流程，用 Hook 比静态规则更可靠
2. **防御性规则 → preToolUse Hook**：文档写入分段这种"违反后果严重"的规则，用 Hook 强制执行
3. **低频但重要 → 保持静态规则**：玩家位置、碰撞体用途这种写代码时才需要的规则，保持在 rules-core.md
4. **触发太频繁 → 保持静态规则**：修改文件列清单如果用 postToolUse Hook，每次 write 都触发，成本太高

---

## 九、实施优先级建议

### P0（立即实施，收益最大）

1. **精简 rules.md + 降级 3 个文件**（Phase 4.0 步骤 1-4）
   - 默认 Token 从 ~9,400 降到 ~2,000
   - 这是最大的收益来源

2. **创建合并版 promptSubmit Hook（智能助手）**
   - 规则路由 + 锐评流程守卫合二为一
   - 解决"对话中间切换话题"和"锐评自动加载"两个问题

3. **升级 000-context-recovery.md**
   - 智能恢复替代机械确认
   - 减少不必要的确认轮次

### P1（第二批实施）

4. **创建 agentStop Hook（Memory 更新检查）**
   - 确保每次对话结束都更新 memory
   - 低风险，低成本

### P2（观察后决定）

5. **文档写入规范放宽阈值**
   - 从 40 行放宽到 150 行，超过 200 行才强制分段
   - 随 rules.md 精简一起完成，不需要单独实施

---

## 十、总结

### 核心思路变化

```
Phase 4.0：把"每次全部加载"变成"核心常驻 + 按需路由"
    ↓
Phase 4.1：进一步把"静态规则"变成"动态行为"
    - 固定流程 → Hook 自动执行
    - 防御性规则 → Hook 强制检查
    - 上下文恢复 → 智能判断替代机械确认
```

### 预期效果

| 指标 | 优化前 | Phase 4.0 后 | Phase 4.1 后 |
|------|--------|-------------|-------------|
| 默认 Token 消耗 | ~9,400 | ~2,000 | ~2,000（不变） |
| 锐评场景效率 | 手动加载规则→阅读→分析 | Hook 自动加载规则 | Hook 自动加载+强制流程 |
| 上下文恢复 | 每次都等确认（浪费1轮） | 同左 | 明确任务直接继续 |
| Memory 更新遗漏 | 靠自觉，偶尔遗漏 | 同左 | agentStop Hook 提醒 |
| 文档写入失败 | 靠自觉，阈值 40 行太保守 | 同左 | 阈值放宽到 150 行，精简规则 |
| 锐评认同度处理 | 对话框写满分析再问 | 同左 | 认同→直接干，不认同→写文件 |
