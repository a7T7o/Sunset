# Phase 4.0 - 规则加载减负方案设计

**创建日期**: 2026-02-12
**目标**: 在保持规则准确度的前提下，最大程度减少默认 Token 消耗，并解决"对话中间切换话题时规则不跟随"的问题

---

## 一、当前问题量化

### 默认加载的 5 个文件（每次对话必定消耗）

| 文件 | 大小 | 估算 Tokens | 每次都需要？ |
|------|------|------------|-------------|
| `rules.md` | 13,053 字节 | ~3,200 | ⚠️ 部分需要 |
| `workspace-memory.md` | 10,109 字节 | ~2,500 | ⚠️ 部分需要 |
| `layers.md` | 6,728 字节 | ~1,700 | ❌ 只有涉及层级时需要 |
| `communication.md` | 6,498 字节 | ~1,600 | ⚠️ 部分需要 |
| `000-context-recovery.md` | 1,494 字节 | ~400 | ✅ 极小，保留 |
| **合计** | **~37,882 字节** | **~9,400** | |

### 核心矛盾

1. 每次对话开头就消耗 ~9,400 tokens 在规则上
2. Kiro 上下文窗口有限，一两次提问就触发上下文继承
3. 上下文继承后，之前加载的规则全部丢失，又要重新消耗
4. 对话中间切换话题时，不会自动加载新的相关规则

---

## 二、减负分析：哪些内容真的需要"每次都加载"？

### rules.md（13KB，最大的消耗源）

| 章节 | 估算 Tokens | 使用频率 | 判断 |
|------|------------|---------|------|
| 最高优先级规则（玩家位置/树木碰撞/遮挡/先设计后实现/新增并兼容） | ~600 | 每次写代码 | ✅ 核心，保留 |
| 绝对禁止事项 | ~400 | 每次写代码 | ✅ 核心，保留 |
| Unity 6 API 更新 | ~100 | 写代码时 | ✅ 小，保留 |
| 编辑器交互规范（Tag/Layer 多选） | ~500 | 写 Editor 代码时 | ❌ 可拆出 |
| SO 访问/事件/动画/性能/命名/调试规范 | ~800 | 写代码时 | ❌ 可拆出到 coding-standards |
| 文档写入规范 | ~100 | 写文档时 | ✅ 精简后保留 |
| 智能规则加载章节 | ~800 | 对话开头用一次 | 🔄 需要重新设计 |

**结论**: rules.md 可以从 ~3,200 tokens 精简到 ~1,500 tokens（减少 ~53%）

### workspace-memory.md（10KB）

| 章节 | 估算 Tokens | 使用频率 | 判断 |
|------|------------|---------|------|
| 核心原则 + Specs 目录结构 | ~400 | 每次 | ✅ 保留 |
| Memory 文档规范 + 格式 | ~600 | 写 memory 时 | ⚠️ 可精简 |
| 工作流程 | ~300 | 开始/继续工作区时 | ✅ 保留 |
| 最高优先级规则（禁止覆盖/任务列表） | ~400 | 每次 | ✅ 保留 |
| 代码文件追踪规范 | ~500 | 修改代码后 | ⚠️ 可精简 |
| 核心讨论触发记录 | ~200 | 讨论时 | ⚠️ 可精简 |

**结论**: 可以精简约 30%，但这个文件的核心规则确实需要常驻

### layers.md（6.7KB）

| 内容 | 使用频率 | 判断 |
|------|---------|------|
| 楼层结构 + Sorting Layers | 涉及层级/放置/渲染时 | ❌ 不是每次都需要 |
| 树木层级结构 | 涉及树木时 | ❌ 不是每次都需要 |
| 命中检测规范 | 涉及战斗/交互时 | ❌ 不是每次都需要 |

**结论**: layers.md 完全可以降级为按需加载，节省 ~1,700 tokens

### communication.md（6.5KB）

| 章节 | 估算 Tokens | 使用频率 | 判断 |
|------|------------|---------|------|
| 一条龙完成模式 | ~400 | 用户说"一条龙"时 | ❌ 可按需加载 |
| 语言要求（中文优先） | ~200 | 每次 | ✅ 核心，保留 |
| 方案讨论规范 | ~300 | 讨论方案时 | ⚠️ 可精简 |
| 回复风格 | ~200 | 每次 | ✅ 保留 |
| 中文用户语言规范 | ~200 | 引用英文文档时 | ⚠️ 可精简 |

**结论**: 可以精简约 50%，核心只需要"语言要求"和"回复风格"

---

## 三、方案设计：三层架构

### 第一层：精简核心（inclusion: always）

只保留"不管做什么都必须遵守"的规则，目标 ~3,000 tokens（从 9,400 降低 68%）。

**保留的文件和内容**：

| 文件 | 改动 | 目标大小 |
|------|------|---------|
| `000-context-recovery.md` | 不动 | ~400 tokens |
| `rules-core.md`（新建） | 从 rules.md 提取核心禁止事项 | ~1,200 tokens |
| `workspace-memory-core.md`（新建） | 从 workspace-memory.md 提取核心规则 | ~800 tokens |
| `communication-core.md`（新建） | 从 communication.md 提取语言+风格 | ~600 tokens |

**或者更简单的方案**：不拆文件，而是精简现有文件内容，把非核心内容移到对应的 manual 规则文件中。

### 第二层：Hook 驱动的按需加载

创建一个 `promptSubmit` 类型的 Hook，每次用户发消息时触发。

### 第三层：手动 # 标签兜底

用户随时可以用 `#规则名` 手动加载任何规则。

---

## 四、Hook 机制详解

### 什么是 Hook？

Hook 是 Kiro 的自动化机制。你可以把它理解为"事件监听器"：
- 当某个事件发生时（比如你发了一条消息），Hook 会自动执行一个动作
- 动作可以是"给 AI 发一条提醒"或"执行一个命令"

### promptSubmit Hook 的工作流程

```
你发送消息 "帮我修改树木的砍伐动画"
    ↓
Kiro 检测到 promptSubmit 事件
    ↓
Hook 自动给 AI 发送一条提醒（你看不到这条提醒）
    ↓
AI 收到提醒，分析你的消息内容
    ↓
AI 判断需要加载 trees.md 和 animation.md
    ↓
AI 用 readFile 加载这两个文件
    ↓
AI 开始正式回答你的问题
```

### Hook 的 Token 消耗

- Hook 的提示词本身：~100-200 tokens（很小）
- 每次触发都会消耗这些 tokens
- 但它替代了"默认加载所有规则"的 ~9,400 tokens

### Hook 的配置文件

```json
{
  "name": "智能规则路由",
  "version": "1.0.0",
  "when": {
    "type": "promptSubmit"
  },
  "then": {
    "type": "askAgent",
    "prompt": "检查用户消息，如果涉及以下领域，用 readFile 加载对应规则（已加载的跳过）：动画→animation.md，UI→ui.md，SO/物品→so-design.md+items.md，树木→trees.md，放置→placeable-items.md，层级/楼层→layers.md，农田→archive/farming.md，锐评→code-reaper-review.md，一条龙→communication.md。路径前缀：.kiro/steering/"
  }
}
```

### 关键特性

1. **每次消息都触发**：不只是对话开头，对话中间切换话题也会触发
2. **静默执行**：你不会看到 Hook 的提醒内容
3. **累积加载**：已经加载过的规则不会重复加载
4. **极低消耗**：提示词只有 ~150 tokens，远小于默认加载的 9,400 tokens


---

## 五、具体实施方案

### 步骤 1：精简默认加载文件（减负核心）

目标：默认加载从 5 个文件 ~9,400 tokens → 2 个文件 ~2,000 tokens

#### 改动一览

| 文件 | 当前状态 | 改为 | 理由 |
|------|---------|------|------|
| `000-context-recovery.md` | always (~400 tokens) | **保留 always** | 极小，上下文恢复是刚需 |
| `rules.md` | always (~3,200 tokens) | **精简后保留 always (~1,600 tokens)** | 拆出非核心内容 |
| `layers.md` | always (~1,700 tokens) | **改为 manual** | 只有涉及层级/放置/渲染时才需要 |
| `communication.md` | always (~1,600 tokens) | **改为 manual** | 核心语言规则合并到 rules.md |
| `workspace-memory.md` | always (~2,500 tokens) | **改为 manual** | 核心规则合并到 rules.md |

#### rules.md 精简方案

从 rules.md 中移除以下内容（移到对应的 manual 文件中）：

| 移出的内容 | 移到哪里 | 节省 Tokens |
|-----------|---------|------------|
| 编辑器交互规范（Tag/Layer 多选） | `coding-standards.md` | ~500 |
| SO 访问规范 | `so-design.md` | ~100 |
| 事件系统规范 | `systems.md` | ~100 |
| 动画系统规范 | `animation.md` | ~150 |
| 性能规范（导航网格/遮挡检测） | `systems.md` | ~200 |
| 命名规范（动画资产/物品ID/标签） | `coding-standards.md` | ~200 |
| 调试规范 | `debug-logging-standards.md` | ~150 |
| 智能规则加载章节（整个删除） | 由 Hook 替代 | ~800 |

rules.md 保留的核心内容（~1,600 tokens）：
1. 最高优先级规则（玩家位置/树木碰撞/遮挡/先设计后实现/新增并兼容/列出修改文件）
2. 绝对禁止事项
3. Unity 6 API 更新（极小）
4. 文档写入规范
5. 从 communication.md 合并的核心语言规则（3 行：中文对话、中文文档、一条龙触发词提醒）
6. 从 workspace-memory.md 合并的核心规则（禁止覆盖/禁止删除/禁止可选任务/memory 只追加）

#### communication.md 降级后的处理

communication.md 改为 `inclusion: manual`，完整内容保留不动。

在 rules.md 中只保留一段极简引用（~150 tokens）：

```markdown
## 语言与沟通（核心摘要）
- 所有对话和文档使用中文（代码/术语除外）
- 默认用文字描述方案，不展示代码，用户确认后再写代码
- 用户说"一条龙/直接全部完成"时 → 加载 communication.md 获取完整流程
```

#### workspace-memory.md 降级后的处理

workspace-memory.md 改为 `inclusion: manual`，完整内容保留不动。

在 rules.md 中只保留核心禁令（~200 tokens）：

```markdown
## 工作区记忆（核心禁令）
- 禁止覆盖任何文档（requirements/design/tasks/memory 只允许新增）
- 禁止删除任何文档
- memory.md 只允许追加新会话记录，不允许修改历史
- tasks.md 中所有任务都是必须完成的，禁止使用 * 标记可选
- 每次修改代码后必须在 memory 中记录修改的文件
- 完整规范：加载 workspace-memory.md
```

#### layers.md 降级后的处理

layers.md 改为 `inclusion: manual`，完整内容保留不动。

在 rules.md 的"最高优先级规则"中保留关键约束（已有，不需要额外添加）：
- 玩家位置 = Collider 中心（已有）
- 树木碰撞体只覆盖树根（已有）
- 遮挡系统与碰撞体无关（已有）

这些是 rules.md 原本就有的内容，不需要从 layers.md 复制。


### 步骤 2：创建 promptSubmit Hook（对话中间的规则路由）

#### Hook 配置

```json
{
  "name": "规则路由",
  "version": "1.0.0",
  "description": "每次用户发消息时，检查是否需要加载额外的 steering 规则文件",
  "when": {
    "type": "promptSubmit"
  },
  "then": {
    "type": "askAgent",
    "prompt": "分析用户消息内容，判断是否涉及以下领域。如果涉及且对应规则尚未在本次对话中加载过，立即用 readFile 静默加载（不要告诉用户你在加载规则）。映射表：层级/楼层/Sorting/放置位置→layers.md | 动画/帧/同步/AnimController→animation.md | UI/面板/快捷键/背包UI/箱子UI→ui.md | SO/ScriptableObject/物品ID/品质/ItemData→so-design.md+items.md | 物品/背包/堆叠/拾取/掉落→items.md | 时间/季节/导航/遮挡/NavGrid→systems.md | 树木/砍树/Tree→trees.md | 放置/树苗/箱子放置/底部对齐→placeable-items.md | 农田/种田/作物/浇水/Crop→archive/farming.md | 锐评/Code Reaper/审查→code-reaper-review.md | 日志/Debug/Log/报错→debug-logging-standards.md | 编码/命名/Region→coding-standards.md | 一条龙/直接全部完成→communication.md | 工作区/memory/新建工作区→workspace-memory.md | 场景修改/Inspector→scene-modification-rule.md。路径前缀：.kiro/steering/（archive 文件加 archive/ 前缀）。如果用户消息不涉及任何领域（纯讨论/闲聊），不加载任何文件。"
  }
}
```

#### Hook 运行逻辑详解

```
┌─────────────────────────────────────────────┐
│ 用户发送消息                                  │
│ "帮我修改树木的砍伐动画"                       │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ Kiro 检测到 promptSubmit 事件                 │
│ 触发 Hook："规则路由"                          │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ Hook 给 AI 发送提醒（用户看不到）              │
│ "分析用户消息内容，判断是否涉及..."            │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ AI 分析用户消息：                              │
│ - "树木" → 命中 trees.md                      │
│ - "动画" → 命中 animation.md                  │
│ - 执行 readFile 加载这两个文件                 │
└──────────────────┬──────────────────────────┘
                   ↓
┌─────────────────────────────────────────────┐
│ AI 带着规则知识，正式回答用户问题              │
└─────────────────────────────────────────────┘
```

#### 对话中间切换话题的场景

```
消息 1："帮我修改树木的砍伐动画"
  → Hook 触发 → 加载 trees.md + animation.md
  → AI 回答

消息 2："对了，背包UI的拖拽也有个bug"
  → Hook 再次触发 → 检测到 "UI" → 加载 ui.md
  → AI 带着 trees.md + animation.md + ui.md 的知识回答

消息 3："好的，现在帮我看看存档的问题"
  → Hook 再次触发 → 检测到 "存档" → 加载 systems.md
  → AI 带着所有已加载规则的知识回答
```

#### Hook 的 Token 消耗分析

| 项目 | Tokens |
|------|--------|
| Hook 提示词（每次消息） | ~250 |
| 实际加载的规则文件（按需） | 0 ~ 3,000（取决于话题） |
| **对比：当前默认加载** | **~9,400（固定消耗）** |

最佳情况（纯讨论）：只消耗 ~250 tokens（Hook 提示词）
典型情况（涉及 1-2 个系统）：~250 + ~2,000 = ~2,250 tokens
最差情况（涉及很多系统）：~250 + ~5,000 = ~5,250 tokens

**平均节省：~4,000-7,000 tokens/对话**


### 步骤 3：手动 # 标签兜底

#### 为什么需要兜底？

Hook 的关键词匹配不可能覆盖所有场景。比如：
- 用户说"帮我看看那个 FarmTileManager 的代码"，没有明确的"农田"关键词
- 用户想提前加载某个规则，不想等 Hook 判断
- Hook 判断错误，漏加载了某个规则

#### 使用方式

在聊天输入框中使用 `#` 加上规则文件名即可手动加载：

| 输入 | 加载的文件 |
|------|-----------|
| `#layers` | `.kiro/steering/layers.md` |
| `#animation` | `.kiro/steering/animation.md` |
| `#ui` | `.kiro/steering/ui.md` |
| `#so-design` | `.kiro/steering/so-design.md` |
| `#items` | `.kiro/steering/items.md` |
| `#trees` | `.kiro/steering/trees.md` |
| `#farming` | `.kiro/steering/archive/farming.md` |
| `#communication` | `.kiro/steering/communication.md` |
| `#workspace-memory` | `.kiro/steering/workspace-memory.md` |
| `#coding-standards` | `.kiro/steering/coding-standards.md` |

#### 与 Hook 的关系

- Hook 是自动挡，# 标签是手动挡
- 两者可以同时使用，不冲突
- 如果 Hook 已经加载了某个规则，手动 # 不会重复加载（Kiro 自动去重）
- 如果 Hook 漏了，用户可以手动补上

#### 注意事项

- 手动 # 标签是 Kiro 原生功能，不需要额外配置
- 只需要确保 steering 文件的 `inclusion: manual` 设置正确
- 文件名就是标签名（去掉 .md 后缀）


---

## 六、实施顺序与风险评估

### 实施顺序

| 步骤 | 内容 | 风险 | 可回滚 |
|------|------|------|--------|
| 1 | 精简 rules.md，移出非核心内容到对应 manual 文件 | 低 | ✅ git revert |
| 2 | 将 communication.md 核心摘要合并到 rules.md，降级为 manual | 低 | ✅ git revert |
| 3 | 将 workspace-memory.md 核心禁令合并到 rules.md，降级为 manual | 低 | ✅ git revert |
| 4 | 将 layers.md 降级为 manual | 低 | ✅ git revert |
| 5 | 创建 promptSubmit Hook | 中 | ✅ 删除 Hook 文件即可 |
| 6 | 验证测试：发几条不同话题的消息，确认 Hook 正确加载规则 | - | - |

### 风险评估

#### 风险 1：Hook 关键词匹配不准确

- **概率**: 中
- **影响**: 某些场景下规则没有被自动加载
- **缓解**: 手动 # 标签兜底；持续优化 Hook 提示词中的关键词映射
- **最坏情况**: 用户手动加载，体验退回到纯手动模式

#### 风险 2：Hook 每次消息都消耗额外 Token

- **概率**: 确定（这是 Hook 的固有成本）
- **影响**: 每条消息额外 ~250 tokens
- **缓解**: 这远小于当前默认加载的 ~9,400 tokens
- **净收益**: 即使每条消息都触发 Hook，10 条消息也只消耗 ~2,500 tokens（Hook 提示词），远小于当前方案

#### 风险 3：精简 rules.md 后遗漏关键规则

- **概率**: 低
- **影响**: 某些场景下 AI 不遵守被移出的规则
- **缓解**: 移出的内容都放在对应的 manual 文件中，Hook 会按需加载
- **最坏情况**: 手动 # 加载

#### 风险 4：上下文继承后 Hook 状态丢失

- **概率**: 确定（上下文继承会丢失所有状态）
- **影响**: 继承后 AI 不知道之前加载了哪些规则
- **缓解**: Hook 每次消息都会重新触发，会根据当前消息重新判断需要加载什么
- **注意**: 这其实比当前方案更好——当前方案继承后也会丢失规则，但不会重新加载


---

## 七、预期效果对比

### Token 消耗对比

| 场景 | 优化前 | 优化后 | 节省 |
|------|--------|--------|------|
| 对话开头（默认加载） | ~9,400 tokens | ~2,000 tokens（rules-core + context-recovery） | **-78%** |
| 纯讨论/闲聊 | ~9,400 tokens | ~2,250 tokens（默认 + Hook 提示词） | **-76%** |
| 涉及 1 个系统（如树木） | ~9,400 tokens | ~3,500 tokens（默认 + Hook + trees.md） | **-63%** |
| 涉及 2 个系统（如树木+动画） | ~9,400 tokens | ~5,000 tokens（默认 + Hook + 2 文件） | **-47%** |
| 涉及 3+ 个系统 | ~9,400 tokens | ~6,500 tokens（默认 + Hook + 3 文件） | **-31%** |
| 对话中间切换话题 | 无法加载新规则 | Hook 自动加载对应规则 | **新能力** |

### 功能对比

| 能力 | 优化前 | 优化后 |
|------|--------|--------|
| 对话开头加载规则 | ✅ 全部加载（浪费） | ✅ 只加载核心 |
| 对话中间按需加载 | ❌ 不支持 | ✅ Hook 自动触发 |
| 手动加载规则 | ✅ # 标签 | ✅ # 标签（不变） |
| 上下文继承后恢复 | ❌ 规则丢失 | ⚠️ Hook 会重新判断当前消息 |
| 规则准确度 | ✅ 全部加载，不会遗漏 | ⚠️ 依赖 Hook 匹配 + 手动兜底 |

### 上下文寿命预估

假设 Kiro 上下文窗口为 ~100K tokens：

| 场景 | 优化前（每轮消耗） | 优化后（每轮消耗） |
|------|-------------------|-------------------|
| 规则消耗 | ~9,400 | ~2,000 + ~250/消息 |
| 用户消息 + AI 回复 | ~3,000 | ~3,000 |
| 代码读写 | ~5,000 | ~5,000 |
| 每轮合计 | ~17,400 | ~10,250 |
| 预估可用轮数 | ~5-6 轮 | ~9-10 轮 |

**上下文寿命提升约 60-70%**，显著减少上下文继承的频率。


---

## 八、回滚方案

如果 Hook 效果不理想，可以分级回滚：

### 回滚级别 1：微调 Hook 提示词

- **触发条件**: Hook 经常漏加载某些规则
- **操作**: 修改 Hook 的 prompt，补充遗漏的关键词
- **影响**: 无，只是优化匹配精度

### 回滚级别 2：恢复部分文件为 always

- **触发条件**: 某个文件被频繁手动加载，说明它确实需要常驻
- **操作**: 将该文件的 `inclusion` 改回 `always`
- **影响**: 默认 Token 消耗增加该文件的大小

### 回滚级别 3：完全回滚

- **触发条件**: Hook 机制整体不可用或效果很差
- **操作**:
  1. 删除 Hook 文件
  2. 用 git revert 恢复所有 steering 文件到优化前的状态
  3. rules.md 恢复原始内容
- **影响**: 回到优化前的状态，不会有任何损失

### 回滚操作命令

```bash
# 完全回滚（如果已经 git commit）
git log --oneline  # 找到优化前的 commit
git revert <commit-hash>

# 或者只回滚 steering 文件
git checkout <commit-hash> -- .kiro/steering/
```

---

## 九、总结

| 项目 | 数值 |
|------|------|
| 默认 Token 消耗 | 9,400 → 2,000（**-78%**） |
| 对话中间按需加载 | ❌ → ✅（**新能力**） |
| 上下文寿命 | ~5-6 轮 → ~9-10 轮（**+60-70%**） |
| 规则准确度 | 不变（Hook + 手动兜底） |
| 回滚风险 | 极低（git revert 即可） |
| 实施工作量 | 约 1 小时（精简文件 + 创建 Hook） |

**核心思路**: 把"每次全部加载"变成"核心常驻 + 按需路由"，用极小的 Hook 成本换取大幅的 Token 节省。
