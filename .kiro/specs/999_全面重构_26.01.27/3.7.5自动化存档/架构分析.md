# 存档系统架构分析 - 正视问题

**创建日期**: 2026-02-03  
**作者**: Kiro  
**目的**: 跳出修补思维，从大局审视当前存档系统的根本问题

---

## 一、当前架构的本质问题

### 1.1 设计哲学的偏差

当前存档系统的设计哲学是：**"让每个对象自己负责存档"**

```
IPersistentObject 接口
├── PersistentId（对象自己生成 GUID）
├── ObjectType（对象自己声明类型）
├── ShouldSave（对象自己决定是否保存）
├── Save()（对象自己序列化数据）
└── Load()（对象自己反序列化数据）
```

这个设计看似"面向对象"，实际上是**责任分散**：
- 每个对象都要实现一套存档逻辑
- 每个对象都要处理 GUID 生成、注册、注销
- 每个对象都要处理动态重建的 prefabId 问题
- 每个对象都要处理"假死"vs"真销毁"的逻辑

**结果**：
- TreeController 有一套逻辑
- StoneController 有另一套逻辑
- ChestController 又有一套逻辑
- WorldItemPickup 还有一套逻辑

每次新增一种可存档对象，都要重复实现这些逻辑，而且很容易遗漏细节。

### 1.2 prefabId 的设计缺陷

当前的 prefabId 机制存在严重问题：

| 问题 | 表现 |
|------|------|
| **命名不统一** | TreeController 用 `M1`、`M2`，ChestController 用 `storageData.name` |
| **手动配置** | PrefabRegistry 需要手动添加每个预制体映射 |
| **冗余字段** | prefabId 本质上就是预制体名称，为什么要额外存储？ |
| **容错性差** | 找不到预制体就直接失败，没有智能回退 |

### 1.3 注册机制的混乱

当前有多个注册中心，职责不清：

| 注册中心 | 职责 | 问题 |
|---------|------|------|
| `PersistentObjectRegistry` | 存档对象注册 | 需要对象主动注册/注销 |
| `ResourceNodeRegistry` | 资源节点注册 | 与存档系统独立，但有交叉 |
| `DynamicObjectFactory` | 动态重建 | 需要知道每种对象的重建方式 |

对象需要在多个地方注册/注销，很容易遗漏。

### 1.4 "假死"机制的补丁性质

为了解决"被销毁的对象无法恢复"的问题，我们引入了"假死"机制：
- `SetActive(false)` 而非 `Destroy()`
- 保留在 Registry 中
- Load() 时重新激活

这是一个**补丁**，不是**设计**。它带来了新问题：
- 假死对象占用内存
- 需要在 Load() 中手动激活
- 需要在 Load() 中重新注册到 ResourceNodeRegistry
- 不同对象的假死逻辑不一致

---

## 二、理想的存档系统应该是什么样的？

### 2.1 核心原则

1. **声明式而非命令式**：对象只需要声明"我需要被存档"，不需要实现存档逻辑
2. **统一管理而非分散管理**：一个中心负责所有存档逻辑
3. **自动化而非手动配置**：预制体映射、GUID 生成都应该自动化
4. **容错而非脆弱**：找不到预制体时有智能回退，而非直接失败

### 2.2 参考：NavGrid2D 的设计

NavGrid2D 的障碍物检测设计得很好：

```csharp
[SerializeField] private string[] obstacleTags;  // 多选 Tag
```

- 不需要每个障碍物实现 `IObstacle` 接口
- 只需要给对象打上 Tag
- NavGrid2D 自动扫描场景中带有这些 Tag 的对象

**这就是声明式设计**：对象只需要声明"我是障碍物"（通过 Tag），不需要实现任何逻辑。

### 2.3 理想的存档系统

```
SaveManager（统一管理中心）
├── persistableTags: string[]  // 多选 Tag，标识哪些对象需要存档
├── prefabFolders: string[]    // 预制体文件夹路径，自动扫描
│
├── SaveAll()                  // 自动扫描场景，保存所有带 Tag 的对象
├── LoadAll()                  // 自动恢复所有对象
│
└── 内部机制
    ├── 自动 GUID 管理（基于 InstanceID 或路径）
    ├── 自动预制体映射（基于预制体名称）
    ├── 自动序列化（基于组件类型）
    └── 智能重建（找不到预制体时的回退策略）
```

---

## 三、当前问题的根因总结

| 问题 | 根因 | 理想方案 |
|------|------|---------|
| 箱子不恢复 | prefabId 命名不统一 + PrefabRegistry 未配置 | 自动扫描预制体，用预制体名称作为 ID |
| 石头假死逻辑复杂 | 每个对象自己实现假死逻辑 | 统一的假死/重建机制 |
| 掉落物关联机制 | 手动实现 sourceNodeGuid | 自动的父子关系追踪 |
| 新增对象类型繁琐 | 需要实现 IPersistentObject 全部方法 | 只需打 Tag，自动处理 |

---

## 四、改进方向

### 方向 A：渐进式改进（保守）

在现有架构上修补：
1. 改进 PrefabRegistry，添加自动扫描功能
2. 统一 prefabId 命名规范
3. 抽取公共的假死/激活逻辑

**优点**：改动小，风险低
**缺点**：治标不治本，架构问题依然存在

### 方向 B：架构重构（激进）

重新设计存档系统：
1. 基于 Tag 的声明式存档
2. 统一的 SaveManager 管理中心
3. 自动化的预制体映射
4. 通用的序列化机制

**优点**：从根本上解决问题，未来扩展性好
**缺点**：改动大，需要迁移现有代码

### 方向 C：混合方案（推荐）

保留 IPersistentObject 接口（兼容现有代码），同时引入新机制：
1. 新增 `[Persistable]` Attribute，替代 Tag（更精确）
2. 新增 `PrefabDatabase`，自动扫描预制体
3. 新增 `SaveManager`，统一管理存档逻辑
4. 现有的 IPersistentObject 实现可以逐步迁移

**优点**：兼容现有代码，可以渐进式迁移
**缺点**：过渡期会有两套机制并存

---

## 五、我的建议

**选择方向 C（混合方案）**，分阶段实施：

### 阶段 1：解决当前问题（本次迭代）
- 改进 PrefabRegistry，添加自动扫描功能
- 统一 prefabId 命名规范（使用预制体名称）
- 修复箱子不恢复的问题

### 阶段 2：引入新机制（下次迭代）
- 新增 `[Persistable]` Attribute
- 新增 `PrefabDatabase` 自动扫描
- 新增 `SaveManager` 统一管理

### 阶段 3：迁移现有代码（后续迭代）
- 逐步将 TreeController、StoneController 等迁移到新机制
- 移除冗余的 IPersistentObject 实现
- 清理旧代码

---

**文档结束**
