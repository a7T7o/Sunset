# 动态对象重建系统 - 全面更新方案

**创建日期**: 2026-02-01
**作者**: Kiro
**目的**: 基于锐评001-005的回应，制定三件套文档的更新方案

---

## 一、锐评回应总结

### 已接受的指令

| 锐评 | 指令 | 我的态度 |
|------|------|---------|
| 001 | prefabId 是必要的 | ✅ 认同 |
| 001 | 掉落物持久化 | ✅ 接受（原本想延后，被驳回） |
| 002 | 旧存档兼容 Legacy Fallback | ✅ 认同 |
| 002 | 防闪烁方案 B | ✅ 认同 |
| 003 | 掉落物严禁延后 | ✅ 接受 |
| 003 | 季节加载顺序保证 | ✅ 认同 |
| 004 | 掉落物不需要复杂的 prefabId 映射 | ✅ 认同 |
| 005 | Drop Support 使用 WorldSpawnService | ✅ 认同 |

### 我的独立补充

| 补充项 | 说明 |
|--------|------|
| 季节渐变状态存档 | 用户明确要求"渐变不可逆"，需要存档 |
| 树桩血量存档 | 当前 TreeSaveData 缺失此字段 |
| 预制体命名确认 | 项目中是 M1/M2/M3，不是 Tree_Oak |

---

## 二、design.md 更新方案

### 2.1 新增章节：掉落物重建设计

```markdown
### 6. 掉落物重建设计（新增）

#### 6.1 数据结构

掉落物使用 `WorldObjectSaveData` + `genericData` 模式：

```csharp
// WorldObjectSaveData
{
    guid: "xxx",
    objectType: "Drop",
    prefabId: "",  // 掉落物不需要 prefabId
    positionX: 10.5,
    positionY: 5.2,
    genericData: "{\"itemId\":1200,\"quality\":0,\"amount\":3}"
}
```

#### 6.2 DropSaveData（存储在 genericData 中）

```csharp
[Serializable]
public class DropSaveData
{
    public int itemId;
    public int quality;
    public int amount;
}
```

#### 6.3 重建流程

```
DynamicObjectFactory.TryReconstruct(data)
  → if (data.objectType == "Drop")
    → 解析 genericData 为 DropSaveData
    → WorldSpawnService.SpawnById(itemId, quality, amount, position)
    → 设置 GUID
    → 返回 IPersistentObject
```

#### 6.4 WorldItemPickup 实现 IPersistentObject

```csharp
public class WorldItemPickup : MonoBehaviour, IPersistentObject
{
    private string _persistentId;
    
    public string PersistentId => _persistentId;
    public string ObjectType => "Drop";
    
    public WorldObjectSaveData Save()
    {
        var dropData = new DropSaveData
        {
            itemId = this.itemId,
            quality = this.quality,
            amount = this.amount
        };
        
        return new WorldObjectSaveData
        {
            guid = PersistentId,
            objectType = ObjectType,
            prefabId = "",  // 掉落物不需要
            // ... 位置等 ...
            genericData = JsonUtility.ToJson(dropData)
        };
    }
    
    public void Load(WorldObjectSaveData data)
    {
        var dropData = JsonUtility.FromJson<DropSaveData>(data.genericData);
        this.itemId = dropData.itemId;
        this.quality = dropData.quality;
        this.amount = dropData.amount;
        ApplyVisual();
    }
}
```
```

### 2.2 新增章节：季节渐变状态存档

```markdown
### 7. 季节渐变状态存档（新增）

#### 7.1 用户需求

> 所有树木自然渐变然后改变后不会回退，只有季节顺时针闭环变更

#### 7.2 TreeSaveData 扩展字段

```csharp
[Serializable]
public class TreeSaveData
{
    // ... 现有字段 ...
    
    /// <summary>树桩血量</summary>
    public int stumpHealth;
    
    /// <summary>是否已渐变到下一季节</summary>
    public bool hasTransitionedToNextSeason;
    
    /// <summary>渐变时的植被季节（用于判断是否需要重置）</summary>
    public int transitionVegetationSeason;
}
```

#### 7.3 TreeController 新增字段

```csharp
/// <summary>是否已渐变到下一季节（运行时状态）</summary>
private bool _hasTransitionedToNextSeason = false;

/// <summary>渐变时的植被季节</summary>
private int _transitionVegetationSeason;
```

#### 7.4 Save/Load 逻辑

**Save**:
```csharp
var treeData = new TreeSaveData
{
    // ... 现有字段 ...
    stumpHealth = currentStumpHealth,
    hasTransitionedToNextSeason = _hasTransitionedToNextSeason,
    transitionVegetationSeason = _transitionVegetationSeason
};
```

**Load**:
```csharp
// 恢复渐变状态
_hasTransitionedToNextSeason = treeData.hasTransitionedToNextSeason;
_transitionVegetationSeason = treeData.transitionVegetationSeason;

// 检查当前季节是否与存档时相同
var currentVegSeason = SeasonManager.Instance.GetCurrentVegetationSeason();
if ((int)currentVegSeason != _transitionVegetationSeason)
{
    // 季节已变更，重置渐变状态
    _hasTransitionedToNextSeason = false;
}

// 强制刷新视觉
UpdateVisuals();
```
```

### 2.3 更新章节：DynamicObjectFactory

```markdown
### 3. DynamicObjectFactory（更新）

#### 3.1 支持的对象类型

| ObjectType | 重建方式 | 说明 |
|------------|---------|------|
| Tree | PrefabRegistry | 需要 prefabId |
| Stone | PrefabRegistry | 需要 prefabId |
| Chest | PrefabRegistry | 需要 prefabId |
| Drop | WorldSpawnService | 不需要 prefabId |

#### 3.2 TryReconstruct 逻辑

```csharp
public static IPersistentObject TryReconstruct(WorldObjectSaveData data)
{
    // 1. 掉落物特殊处理
    if (data.objectType == "Drop")
    {
        return ReconstructDrop(data);
    }
    
    // 2. Legacy Fallback（旧存档兼容）
    if (string.IsNullOrEmpty(data.prefabId))
    {
        if (data.objectType == "Tree")
        {
            data.prefabId = "M1";  // 默认使用 M1 预制体
            Debug.LogWarning($"[DynamicObjectFactory] 旧存档兼容：使用默认预制体 M1");
        }
        else
        {
            Debug.LogWarning($"[DynamicObjectFactory] 无法重建：{data.objectType}，prefabId 为空");
            return null;
        }
    }
    
    // 3. 标准重建流程
    var prefab = _registry.GetPrefab(data.prefabId);
    if (prefab == null)
    {
        Debug.LogWarning($"[DynamicObjectFactory] 找不到预制体: {data.prefabId}");
        return null;
    }
    
    // 4. 实例化（防闪烁方案 B）
    var position = data.GetPosition();
    var instance = Object.Instantiate(prefab, position, Quaternion.identity);
    instance.SetActive(false);  // 先禁用
    
    // 5. 获取组件并设置 GUID
    var persistentObj = instance.GetComponentInChildren<IPersistentObject>();
    SetPersistentId(persistentObj, data.guid);
    
    // 6. 注册到 Registry
    PersistentObjectRegistry.Instance.Register(persistentObj);
    
    // 7. Load 后再启用
    // 注意：Load 在调用方执行，启用也在调用方执行
    
    return persistentObj;
}

private static IPersistentObject ReconstructDrop(WorldObjectSaveData data)
{
    // 解析 genericData
    var dropData = JsonUtility.FromJson<DropSaveData>(data.genericData);
    if (dropData == null)
    {
        Debug.LogError($"[DynamicObjectFactory] 无法解析 DropSaveData");
        return null;
    }
    
    // 使用 WorldSpawnService 生成
    var position = data.GetPosition();
    var pickup = WorldSpawnService.Instance.SpawnById(
        dropData.itemId, 
        dropData.quality, 
        dropData.amount, 
        position, 
        false,  // 不播放动画
        false   // 不设置生成冷却
    );
    
    if (pickup == null)
    {
        Debug.LogError($"[DynamicObjectFactory] WorldSpawnService 生成失败");
        return null;
    }
    
    // 设置 GUID
    // 注意：WorldItemPickup 需要实现 IPersistentObject
    var persistentObj = pickup as IPersistentObject;
    if (persistentObj != null)
    {
        SetPersistentId(persistentObj, data.guid);
        PersistentObjectRegistry.Instance.Register(persistentObj);
    }
    
    return persistentObj;
}
```
```

### 2.4 更新章节：预制体 ID 命名规范

```markdown
### 预制体 ID 命名规范（更新）

| 对象类型 | prefabId 格式 | 示例 | 说明 |
|---------|--------------|------|------|
| 树木 | `{TreeType}` | `M1`, `M2`, `M3` | 与预制体文件名一致 |
| 石头 | `Stone_{stoneId}` | `Stone_M1` | 待确认 |
| 箱子 | `Chest_{chestType}` | `Chest_Wood` | 待确认 |
| 掉落物 | 不需要 | - | 使用 WorldSpawnService |

**Legacy Fallback 默认值**：
- Tree: `M1`
```

---

## 三、tasks.md 更新方案

### 3.1 新增任务：掉落物持久化

```markdown
### 阶段 7: 掉落物持久化（新增）

- [ ] 9. 创建 DropSaveData 数据结构
  - 在 `SaveDataDTOs.cs` 中添加 `DropSaveData` 类
  - 字段：`itemId`, `quality`, `amount`
  - 文件: `Assets/YYY_Scripts/Data/Core/SaveDataDTOs.cs`

- [ ] 10. 修改 WorldItemPickup 实现 IPersistentObject
  - 添加 `_persistentId` 字段
  - 实现 `PersistentId` 属性
  - 实现 `ObjectType` 属性（返回 "Drop"）
  - 实现 `Save()` 方法
  - 实现 `Load()` 方法
  - 添加 `SetPersistentIdForLoad()` 方法
  - 文件: `Assets/YYY_Scripts/World/WorldItemPickup.cs`

- [ ] 11. 更新 DynamicObjectFactory 支持 Drop
  - 添加 `ReconstructDrop()` 私有方法
  - 在 `TryReconstruct()` 中检测 `objectType == "Drop"`
  - 调用 `WorldSpawnService.SpawnById()` 生成
  - 文件: `Assets/YYY_Scripts/Data/Core/DynamicObjectFactory.cs`
```

### 3.2 新增任务：季节渐变状态

```markdown
### 阶段 8: 季节渐变状态存档（新增）

- [ ] 12. 扩展 TreeSaveData 字段
  - 添加 `stumpHealth` (int)
  - 添加 `hasTransitionedToNextSeason` (bool)
  - 添加 `transitionVegetationSeason` (int)
  - 文件: `Assets/YYY_Scripts/Data/Core/SaveDataDTOs.cs`

- [ ] 13. 修改 TreeController 支持渐变状态存档
  - 添加 `_hasTransitionedToNextSeason` 字段
  - 添加 `_transitionVegetationSeason` 字段
  - 修改 `Save()` 方法保存渐变状态
  - 修改 `Load()` 方法恢复渐变状态
  - 在 `Load()` 末尾调用 `UpdateVisuals()`
  - 文件: `Assets/YYY_Scripts/Controller/TreeController.cs`
```

### 3.3 新增任务：加载顺序保证

```markdown
### 阶段 9: 加载顺序保证（新增）

- [ ] 14. 验证 SaveManager.LoadGame() 加载顺序
  - 确保 `RestoreGameTimeData()` 先于 `RestoreAllFromSaveData()` 执行
  - 如果顺序不对，调整代码
  - 文件: `Assets/YYY_Scripts/Data/Core/SaveManager.cs`
```

### 3.4 更新任务：DynamicObjectFactory

```markdown
### 阶段 3: 动态对象工厂（更新）

- [ ] 4. 创建 DynamicObjectFactory
  - 创建 `DynamicObjectFactory.cs`，包含：
    - `Initialize(PrefabRegistry)` 静态方法
    - `TryReconstruct(WorldObjectSaveData)` 静态方法
    - `ReconstructDrop(WorldObjectSaveData)` 私有方法（新增）
    - 预制体实例化逻辑
    - GUID 强制设置逻辑
    - **Legacy Fallback 逻辑**（新增）
    - **防闪烁方案 B**（新增）
  - 文件: `Assets/YYY_Scripts/Data/Core/DynamicObjectFactory.cs`
```

### 3.5 更新验收标准

```markdown
## 验收标准（更新）

### 功能验收

- [ ] 种植树苗 → 保存 → 重启游戏 → 加载 → 树苗出现在正确位置
- [ ] 树苗的生长阶段正确恢复
- [ ] 树苗的血量正确恢复
- [ ] 树苗的视觉外观正确恢复（无闪烁）
- [ ] 树苗的季节渐变状态正确恢复（新增）
- [ ] 掉落物 → 保存 → 重启游戏 → 加载 → 掉落物出现在正确位置（新增）
- [ ] 掉落物的 itemId、quality、amount 正确恢复（新增）
- [ ] 控制台显示"重建 N 个对象"的日志

### 兼容性验收

- [ ] 旧存档（prefabId 为空）不会导致加载失败
- [ ] 旧存档的树苗使用默认预制体 M1 重建（新增）
- [ ] 静态对象（石头）的加载不受影响
- [ ] 运行中保存/加载仍然正常工作

### 性能验收

- [ ] 加载 20+ 个动态对象的时间 < 1 秒
- [ ] 无视觉闪烁（新增）
```

---

## 四、requirements.md 更新方案

### 4.1 新增用户故事：掉落物持久化

```markdown
### US-4: 掉落物持久化（新增）

**作为**玩家
**我希望**地上的掉落物在重启游戏后仍然存在
**以便**我不会因为重启游戏而丢失未拾取的物品

**验收标准**：
- AC-4.1: 掉落物在保存时记录 itemId、quality、amount、position
- AC-4.2: 重启游戏后加载存档，掉落物出现在正确位置
- AC-4.3: 掉落物的视觉外观正确显示
```

### 4.2 新增用户故事：季节渐变状态

```markdown
### US-5: 季节渐变状态持久化（新增）

**作为**玩家
**我希望**树木的季节渐变状态在重启游戏后保持
**以便**游戏世界的视觉一致性

**验收标准**：
- AC-5.1: 已渐变到下一季节的树木，重启后仍显示下一季节
- AC-5.2: 季节变更后，渐变状态正确重置
- AC-5.3: 渐变是不可逆的（在同一季节内）
```

---

## 五、执行顺序

1. **更新 requirements.md**：添加 US-4、US-5
2. **更新 design.md**：添加掉落物重建设计、季节渐变状态存档、更新 DynamicObjectFactory
3. **更新 tasks.md**：添加阶段 7-9 任务，更新阶段 3 任务，更新验收标准
4. **更新 memory.md**：记录本次会话

---

## 六、文件修改清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `requirements.md` | 追加 | 添加 US-4、US-5 |
| `design.md` | 追加 | 添加掉落物设计、季节渐变设计、更新 DynamicObjectFactory |
| `tasks.md` | 追加 | 添加阶段 7-9 任务，更新验收标准 |
| `memory.md` | 追加 | 记录会话 3 |
| `锐评回应与独立思考.md` | 已更新 | 添加锐评004-005回应 |

---

**文档状态**: 待用户审核
**下一步**: 用户确认后，按顺序更新三件套文档
