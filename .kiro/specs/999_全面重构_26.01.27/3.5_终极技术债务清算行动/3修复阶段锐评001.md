此问题的根源在于 ItemData.cs 本身已经使用了 [Header] 属性来分类，而你的 ItemDataEditor.cs 又手动添加了 EditorGUILayout.LabelField（或者类似的标题绘制），导致标题重复出现（一次是 Unity 自带的 Header，一次是你代码里写的）。

关于“末尾内容跑到开头”：这通常是因为 DrawRemainingProperties 逻辑中的迭代器 GetIterator() 从序列化的第一个属性（通常是 m_Script）开始遍历，如果在这个过程中有一些未被标记为“已处理”的属性（可能是一些隐式的或者是脚本引用本身），它们会被 DrawRemainingProperties 绘制出来。虽然 DrawRemainingProperties 是在最后调用的，但如果你的布局逻辑中有 GUILayout.BeginArea 或者类似的排版错误，或者用户视觉上的错觉（比如脚本属性出现在了最下面，但用户觉得它应该在最上面），都会导致困惑。不过根据描述“出现在开头”，更有可能是 serializedObject.GetIterator() 包含了某些 Unity 内部属性，或者 ItemData 的字段顺序与你预想的不一致。

修复方案
我们将对 ItemDataEditor.cs 进行“消声处理”：

移除所有手动标题：删除 EditorGUILayout.LabelField("...")，直接利用 ItemData 中自带的 [Header]。

静默脚本属性：在 DrawRemainingProperties 中显式过滤掉 m_Script（脚本引用字段），因为它通常不需要在自定义 Inspector 的底部再次显示（或者如果你想显示，就放在最上面，但现在的逻辑是放在剩余属性里）。

修复分类逻辑：根据你提供的正确枚举（Tool, Plant, Material 等），修正 ShouldShow... 的判断。

请复制以下修复后的 ItemDataEditor.cs 代码：

C#

using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using FarmGame.Data;

namespace FarmGame.Editor
{
    /// <summary>
    /// ItemData 自定义编辑器 (修复版)
    /// 修复了标题重复显示的问题，并适配了正确的枚举类型
    /// </summary>
    [CustomEditor(typeof(ItemData), true)]
    public class ItemDataEditor : UnityEditor.Editor
    {
        #region 字段分组定义
        
        // 基础信息字段
        private static readonly string[] BasicInfoFields = new string[]
        {
            "itemID", "itemName", "description", "category"
        };
        
        // 视觉资源字段
        private static readonly string[] VisualsFields = new string[]
        {
            "icon", "bagSprite", "rotateBagIcon", "worldPrefab"
        };
        
        // 经济属性字段
        private static readonly string[] EconomyFields = new string[]
        {
            "buyPrice", "sellPrice"
        };
        
        // 堆叠属性字段
        private static readonly string[] StackFields = new string[]
        {
            "maxStackSize"
        };
        
        // 显示尺寸字段
        private static readonly string[] DisplaySizeFields = new string[]
        {
            "displayPixelSize"
        };

        // 杂项功能字段 (原 FunctionFields)
        // 注意：displayPixelSize 已在上面定义，这里不再重复
        
        // 放置配置字段
        private static readonly string[] PlacementFields = new string[]
        {
            "isPlaceable", "placementType", "placementPrefab", "buildingSize"
        };
        
        // 装备配置字段
        private static readonly string[] EquipmentFields = new string[]
        {
            "defense", "attributes", "equipmentModel"
        };
        
        // 消耗品配置字段
        private static readonly string[] ConsumableFields = new string[]
        {
            "restoreHealth", "restoreEnergy", "buffType" // 移除不存在的 potionBuffType
        };
        
        // 农田配置字段 (如果有 SeedData 等子类特定字段，需在此处或 DrawRemainingProperties 处理)
        private static readonly string[] FarmFields = new string[]
        {
            "daysToGrow", "cropPrefab", "seasonConfig" // 示例字段，根据实际 SeedData 调整
        };

        #endregion
        
        private SerializedProperty _currentCategoryProp;
        private ItemCategory _currentCategory;
        private HashSet<string> _handledProperties;

        private void OnEnable()
        {
            _currentCategoryProp = serializedObject.FindProperty("category");
            if (_currentCategoryProp != null)
            {
                _currentCategory = (ItemCategory)_currentCategoryProp.enumValueIndex;
            }
            
            BuildHandledPropertiesSet();
        }

        public override void OnInspectorGUI()
        {
            // 更新 SerializedObject
            serializedObject.Update();
            
            // 检查分类变化
            CheckChanges();

            // 1. 绘制基础信息 (移除 LabelField，使用自带 Header)
            DrawProperties(BasicInfoFields);
            
            // 2. 绘制视觉 (移除 LabelField)
            DrawProperties(VisualsFields);
            
            // 3. 绘制经济 (移除 LabelField)
            DrawProperties(EconomyFields);
            
            // 4. 绘制堆叠 (移除 LabelField)
            DrawProperties(StackFields);
            
            // 5. 绘制显示尺寸 (移除 LabelField)
            DrawProperties(DisplaySizeFields);

            // === 动态区域 ===

            // 6. 放置配置 (Furniture 或 开启了放置)
            if (ShouldShowPlacementConfig())
            {
                DrawProperties(PlacementFields);
            }
            
            // 7. 装备配置 (Tool 或 Equipment)
            if (ShouldShowEquipmentConfig())
            {
                DrawProperties(EquipmentFields);
            }
            
            // 8. 消耗品配置 (Consumable 或 Food)
            if (ShouldShowConsumableConfig())
            {
                DrawProperties(ConsumableFields);
            }

            // 9. 兜底绘制：绘制所有未被手动处理的字段 (例如子类特有的字段)
            // 这会处理 SeedData, ToolData 等子类中定义的新字段
            DrawRemainingProperties();

            // 应用修改
            serializedObject.ApplyModifiedProperties();
            
            // 绘制验证消息 (如果有)
            DrawValidationMessages();
        }

        private void CheckChanges()
        {
            if (_currentCategoryProp != null)
            {
                _currentCategory = (ItemCategory)_currentCategoryProp.enumValueIndex;
            }
        }

        /// <summary>
        /// 绘制指定列表的属性
        /// </summary>
        private void DrawProperties(string[] fields)
        {
            foreach (var fieldName in fields)
            {
                var prop = serializedObject.FindProperty(fieldName);
                if (prop != null)
                {
                    EditorGUILayout.PropertyField(prop, true);
                }
            }
        }

        /// <summary>
        /// 绘制剩余的所有属性 (防止子类字段被吞)
        /// </summary>
        private void DrawRemainingProperties()
        {
            SerializedProperty iterator = serializedObject.GetIterator();
            bool enterChildren = true;
            
            while (iterator.NextVisible(enterChildren))
            {
                enterChildren = false; // 只遍历第一层子属性
                
                // 过滤掉脚本引用(m_Script)和已处理的属性
                if (iterator.name == "m_Script") continue;

                if (!_handledProperties.Contains(iterator.name))
                {
                    EditorGUILayout.PropertyField(iterator, true);
                }
            }
        }

        #region 条件判断逻辑 (根据你的枚举修正)

        private bool ShouldShowPlacementConfig()
        {
            // 只有 Furniture 或 显式开启 isPlaceable 才显示
            var isPlaceableProp = serializedObject.FindProperty("isPlaceable");
            return _currentCategory == ItemCategory.Furniture || 
                   (isPlaceableProp != null && isPlaceableProp.boolValue);
        }
        
        private bool ShouldShowEquipmentConfig()
        {
            // Tool 类型 (包含工具和武器概念，如果在 Enum 里没有单独的 Weapon/Equipment)
            // 如果你有单独的 Equipment 枚举值，请加回来
            return _currentCategory == ItemCategory.Tool;
        }
        
        private bool ShouldShowConsumableConfig()
        {
            // Consumable 或 Food 类型
            return _currentCategory == ItemCategory.Consumable ||
                   _currentCategory == ItemCategory.Food;
        }
        
        #endregion
        
        #region 辅助方法
        
        private void BuildHandledPropertiesSet()
        {
            _handledProperties = new HashSet<string>
            {
                "m_Script" // 标记脚本字段为已处理
            };
            
            AddToSet(BasicInfoFields);
            AddToSet(VisualsFields);
            AddToSet(EconomyFields);
            AddToSet(StackFields);
            AddToSet(DisplaySizeFields);
            // FunctionFields 似乎与 DisplaySize 重复，暂忽略
            AddToSet(PlacementFields);
            AddToSet(EquipmentFields);
            AddToSet(ConsumableFields);
            AddToSet(FarmFields);
        }
        
        private void AddToSet(string[] fields)
        {
            foreach (var field in fields)
            {
                _handledProperties.Add(field);
            }
        }
        
        private void DrawValidationMessages()
        {
            // 这里可以把原 ItemData.OnValidate 的逻辑搬过来显示 HelpBox
            // 示例:
            /*
            SerializedProperty pixelSize = serializedObject.FindProperty("displayPixelSize");
            if (pixelSize != null && (pixelSize.intValue < 8 || pixelSize.intValue > 128))
            {
                EditorGUILayout.HelpBox($"displayPixelSize({pixelSize.intValue}) 超出推荐范围 8-128", MessageType.Warning);
            }
            */
        }
        
        #endregion
    }
}
为什么会出现“末尾内容在开头”？
这通常是因为 SerializedProperty iterator = serializedObject.GetIterator() 默认从对象的第一个序列化字段开始。如果 BuildHandledPropertiesSet 没有正确捕获某些字段（比如拼写错误，或者字段实际上是私有的但被标记为 [SerializeField]），DrawRemainingProperties 就会在底部将它们绘制出来。 但你说“出现在开头”——这极有可能是因为 Inspector 的重绘机制 或者 m_Script 字段的处理。在这个修复版中，我显式过滤了 m_Script，并确保 DrawRemainingProperties 严格在所有手动组之后调用。

下一步
应用此脚本：覆盖原有的 ItemDataEditor.cs。

检查 Material：查看分类为 Material 的物品（例如 Coal/Ore），确认 Inspector 是否干净，且没有重复标题。

检查子类：查看 Seed（种子）或 Sapling（树苗），确认它们特有的字段（如 growthDays）是否能正常显示在底部。
