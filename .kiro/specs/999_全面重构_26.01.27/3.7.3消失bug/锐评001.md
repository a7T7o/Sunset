你好，老大。**Code Reaper (锐评专家)** 满状态上线。

听到了你的“寒心”，我感同身受。这种“修了一个Bug，冒出三个新Bug”的循环，是开发中最折磨人的阶段。
我看过了控制台报错和 Kiro 的《问题审核报告》。这一次，Kiro 的尸检报告（`问题审核报告.md`）终于查到了**直接死因**，但他对**根本病灶**的理解依然不够深。

**结论先行：**
你遇到的“树木全灭”惨案，是由 **Unity 的命名机制** 和 **GUID 漂移** 共同制造的“双重谋杀”。

1. **第一刀（GUID 漂移）**：你重启游戏后，场景里的静态树生成了新 GUID（因为编辑器里没保存死）。存档里的旧 GUID 找不到对应的树，于是系统判定：“这些树都不存在了”，反向修剪把它们全**Disable**了。
2. **第二刀（重建失败）**：系统想：“既然找不到，那我就按存档数据重建吧”。结果存档里存的 `prefabId` 竟然是 **"M1 (1)"**（Unity 自动加的后缀）。工厂拿着这个名字去查注册表，查无此树，重建失败。
3. **结果**：旧的被杀，新的没造出来。场景一片空白。

以下是**终极锐评与处决方案**。这一次，我们要把这两个病灶连根拔起。

---

```markdown
# 💀 锐评 020：命名污染清除与静态锚点固化 (The Final Purge)

**致 Kiro (开发智能体):**

我是 Code Reaper。
老大的失望是有原因的。我们在架构上设计得天花乱坠，却在最基础的字符串处理上栽了跟头。
你的《问题审核报告》定位到了 `M1 (1)` 这个现象，这很好。但你必须明白，这不仅仅是“格式错误”，这是**对 Unity 命名规则的无知**。

我们现在要进行**外科手术式的修复**，并在工厂层加上**防弹衣**。

---

## 🔪 核心病灶一：脏名字 (The Dirty Name)
**现象**：`[PrefabRegistry] 找不到预制体: M1 (1)`
**原因**：Unity 会给重复或实例化的物体自动加后缀 `(1)`, `(Clone)`。你直接读取 `gameObject.name` 存入存档，导致 `prefabId` 变成了垃圾字符串。
**🛠️ 修复指令**：
在 `TreeController.cs` 的 `GetPrefabId()` 方法中，必须实施**强力清洗**。不要只依赖 `Split`，要用正则。

```csharp
// 引入正则
using System.Text.RegularExpressions;

private string GetPrefabId()
{
    // 1. 获取基础名称 (可能包含 (1), (Clone) 等)
    string rawName = gameObject.name.Replace("(Clone)", "").Trim();
    
    // 2. 如果是父子结构 (Tree_M1_00)，取父物体名字
    if (transform.parent != null)
    {
        rawName = transform.parent.name.Replace("(Clone)", "").Trim();
    }

    // 3. 🔥 关键：使用正则去除 Unity 的数字后缀 " (1)", " (2)" 等
    // 匹配模式：空格 + 左括号 + 数字 + 右括号，替换为空
    rawName = Regex.Replace(rawName, @"\s\(\d+\)$", "");

    // 4. 解析逻辑 (提取 M1, M2, M3)
    // 假设命名规范是 "M1", "M2", "Tree_M1", "M1_00" 等，我们要提取 "M1"
    // 简单粗暴的包含检测 (根据你的 PrefabRegistry Key)
    if (rawName.Contains("M1")) return "M1";
    if (rawName.Contains("M2")) return "M2";
    if (rawName.Contains("M3")) return "M3";

    // 5. 兜底
    Debug.LogWarning($"[TreeController] 无法解析 prefabId，原始名称: {gameObject.name}，清洗后: {rawName}");
    return "M1"; // 默认回退
}

```

---

## 🔪 核心病灶二：GUID 漂移 (The Drifting Anchors)

**现象**：`[Registry] 存档匹配率: 7/25`
**原因**：静态树木（场景自带的）在 Editor 阶段没有把 GUID **序列化到 Scene 文件里**。每次运行，它们都在 `Awake` 里生成新 GUID。重启游戏 = 换了一批 ID。
**🛠️ 执行指令 (给老大的操作指南)**：
你已经在代码里加了 `ForceRegenerateGUID`，但这还不够。必须让老大执行**保存场景**的操作。

**请明确告诉老大：**

1. 代码修改完回到 Unity。
2. 在 Hierarchy 搜索 `Tree`，全选所有树木。
3. 右键 -> `Force Regenerate GUID` (如果你的 ContextMenu 生效的话)。
4. **🔥 最重要的一步：按 `Ctrl + S` 保存场景 (Scene)！** * *只有保存了场景，这些 GUID 才会永久固定下来，重启游戏才不会变。*

---

## 🛡️ 防御层：工厂容错 (Factory Resilience)

**现象**：工厂因为找不到 `M1 (1)` 就直接放弃了。
**🛠️ 修复指令**：
在 `DynamicObjectFactory.cs` 的 `TryReconstruct` 中，增加**二次清洗**。
如果 `registry.GetPrefab(prefabId)` 返回 null，不要立刻放弃：

```csharp
if (prefab == null)
{
    // 尝试清洗 prefabId (去掉可能存在的 (1) 后缀)
    string cleanId = Regex.Replace(prefabId, @"\s\(\d+\)$", "");
    prefab = _registry.GetPrefab(cleanId);
    
    if (prefab != null)
    {
        Debug.LogWarning($"[Factory] 原始 ID {prefabId} 失败，清洗后 {cleanId} 成功匹配。");
    }
}

```

*这叫“防御性编程”。哪怕存档脏了，加载逻辑也要能把它洗干净吃下去。*

---

## 🚀 最终执行 (The Final Strike)

1. **修改 `TreeController.cs**`：实现正则清洗名字。
2. **修改 `DynamicObjectFactory.cs**`：增加工厂容错。
3. **告知老大**：**务必执行“全选树木 -> 生成GUID -> 保存场景”的操作**。

**这次必须成功。**

```

***

老大，这次的问题在于**“脏数据进，脏数据出”**。
Unity 的 `name` 属性是非常“脏”的，绝对不能直接作为 ID。Kiro 之前的处理太天真了。
加上正则清洗和工厂容错，就算名字里有 `(888)` 也能被识别出来。

同时，**静态树木的 GUID 必须保存在场景文件中**，这是物理定律。如果这一步没做，每次开始游戏都是新树，存档永远对不上。请务必执行那个“保存场景”的操作。

```