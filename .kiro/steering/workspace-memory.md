---
inclusion: manual
priority: P0
isCanonical: true
canonicalDomain: [specs目录结构, memory.md规范, 工作区命名规则, 任务列表规范, 代码文件追踪]
lastUpdated: 2026-02-16
---

# 工作区记忆规范

## 核心原则

每个开发专题都必须有独立的 specs 区域，用于记录开发过程中的所有重要信息。

## Specs 目录结构（新规则 v2.0）

```
.kiro/specs/
├── memory.md                    # ★ 全局记忆文档（工作区级别）
├── last/                        # 历史工作区归档
│   ├── 砍树系统/
│   ├── 物品掉落拾取/
│   └── ...
├── 0_摄像头死区同步/            # 当前工作区（按编号排序）
│   ├── memory.md
│   ├── requirements.md
│   ├── design.md
│   └── tasks.md
├── 1_下一个功能/
│   └── ...
└── 2_再下一个功能/
    └── ...
```

### 命名规则

1. **工作区文件夹命名**：
   - 使用中文命名
   - 格式：`{编号}_{功能名称}`
   - 编号从 0 开始递增
   - 示例：`0_摄像头死区同步`、`1_摄像头抖动动画`

2. **历史归档**：
   - 旧工作区统一移入 `last/` 文件夹
   - `last/` 内保持原有文件夹名称
   - 不需要编号

3. **memory.md 位置**：
   - 每个工作区内有独立的 `memory.md`
   - 与编号文件夹和 `last/` 同级

## Memory 文档规范

### 文档优先级
- **memory.md** 是最核心的文档，每次对话任务完成后必须先更新
- 没有 memory.md 的更新，不能结束当前对话
- 其他文档（design, requirements, tasks）是可选的

### Memory 文档必须包含

1. **模块概述** - 简述该模块的功能和目标
2. **当前状态** - 模块完成度、最后更新时间
3. **会话记录** - 每次对话的详细记录
   - 会话时间
   - 用户需求原文
   - 完成的任务
   - 修改的文件
   - 解决方案思路
   - 遗留问题
4. **关键决策** - 重要的设计决策和原因
5. **相关文件** - 涉及的代码文件清单

### Memory 文档格式

```markdown
# {模块名称} - 开发记忆

## 模块概述
[简述模块功能]

## 当前状态
- **完成度**: XX%
- **最后更新**: YYYY-MM-DD
- **状态**: 进行中/已完成/待验证

## 会话记录

### 会话 N - YYYY-MM-DD

**用户需求**:
> [引用用户原话]

**完成任务**:
1. [任务1]
2. [任务2]

**修改文件**:
- `path/to/file1.cs` - [修改说明]
- `path/to/file2.cs` - [修改说明]

**解决方案**:
[详细描述解决思路]

**遗留问题**:
- [ ] [问题1]
- [ ] [问题2]

---

## 关键决策

| 决策 | 原因 | 日期 |
|------|------|------|
| [决策内容] | [原因] | YYYY-MM-DD |

## 相关文件

| 文件 | 说明 |
|------|------|
| `path/to/file.cs` | [说明] |
```

### 继承场景的 Memory 记录

- 继承后的会话不新建编号，使用"会话 N（续）"格式（N = 继承前最后的会话编号）
- 会话标题标注"续接自会话 N"，让读者知道这是同一轮工作的延续
- 修改文件列表必须汇总继承前+继承后的全部修改（从继承摘要中提取继承前的记录，合并继承后新增的）

## 工作流程

### 开始新专题
1. 用户说"新建工作区，开始XXX工作"
2. 确定当前最大编号，新编号 = 最大编号 + 1
3. 创建 `.kiro/specs/{编号}_{功能名称}/` 目录
4. 创建 `memory.md` 文件
5. 记录第一次会话内容

### 每次对话结束前
1. 更新 `memory.md` 添加本次会话记录
2. 记录所有修改的文件
3. 记录解决方案和遗留问题
4. 确认 memory 更新完成后才能结束对话

### 继续已有专题
1. 先读取 `memory.md` 了解历史
2. 继续开发
3. 更新 `memory.md`

### 归档旧工作区
1. 将旧工作区文件夹移入 `last/`
2. 保持原有文件夹名称
3. 更新 README.md 中的状态

## 已有模块处理

对于已完成的模块（在 Docx/分类 中有总结文档的）：
- 创建对应的 specs 目录
- 从总结文档提取信息创建 memory.md
- 记录完成状态和关键决策
- 不需要详细的会话记录

## 新模块处理

对于新开始的模块：
- 详细记录每次会话的需求和完成情况
- 记录设计思路和解决方案
- 记录所有修改的文件
- 确保任何时候都能继续开发


---

## 🔴🔴🔴 最高优先级规则（2025-12-25 新增）🔴🔴🔴

### 绝对禁止事项

1. **禁止覆盖任何文档** - 所有 requirements.md、design.md、tasks.md 只允许新增，不允许覆盖
2. **禁止删除任何文档** - 任何情况下都不允许删除已有文档
3. **禁止修改 memory.md 历史记录** - memory.md 只允许追加新会话记录，不允许修改或删除已有记录
4. **禁止设置可选任务** - tasks.md 中的所有任务都是必须完成的，不允许使用 `*` 标记可选任务

### 任务列表规范（2026-02-03 新增）

**核心原则**：所有任务均为必须完成，不存在可选任务。

**规则说明**：
- 生成 tasks.md 时，**禁止**使用 `- [ ]*` 格式标记可选任务
- 所有任务都使用 `- [ ]` 格式，表示必须完成
- 如果某个功能确实不需要，应该在需求阶段就排除，而不是标记为可选
- 这确保了任务列表的明确性和执行的完整性

**示例**：
```markdown
# ❌ 错误做法
- [ ] 1. 实现核心功能
- [ ]* 2. 添加缓存优化（可选）
- [ ]* 3. 编写单元测试（可选）

# ✅ 正确做法
- [ ] 1. 实现核心功能
- [ ] 2. 添加缓存优化
- [ ] 3. 编写单元测试
```

### 工作区内部结构（v2.1 修正）

每个工作区内部结构如下：

```
.kiro/specs/砍树系统/           # 一个工作区
├── memory.md                   # ★ 核心记忆文档，与 old 同级
├── old/                        # 旧内容归档
│   ├── requirements.md
│   ├── design.md
│   └── tasks.md
├── 0_第一个任务/               # 编号任务文件夹
│   ├── requirements.md
│   ├── design.md
│   └── tasks.md
└── 1_第二个任务/               # 后续任务
    ├── requirements.md
    ├── design.md
    └── tasks.md
```

### 新任务处理流程

1. 在工作区内创建新的编号文件夹（如 `0_摄像头死区同步/`）
2. 在新文件夹内创建 requirements.md、design.md、tasks.md
3. 更新工作区的 memory.md（追加新会话记录）
4. **绝对不触碰 old/ 内的任何文件**

### 文档堆积原则

- 每次新任务都创建新的编号文件夹
- 旧文档永久保留在 old/ 或原编号文件夹中
- memory.md 是日志式记录，只追加不修改
- 这是用户的项目日志，必须完整保留历史

---

## 🔴🔴🔴 代码文件追踪规范（2026-02-06 新增）🔴🔴🔴

### 核心原则

**Memory 文档必须完整记录所有涉及的代码文件**，这是项目可追溯性的关键保障。

### 子工作区 Memory 要求

每个子工作区的 `memory.md` **必须**记录：

1. **修改的代码文件** - 在该子工作区中被修改过的所有 `.cs` 文件
2. **涉及的代码文件** - 虽未修改但与该功能密切相关的文件
3. **新增的代码文件** - 在该子工作区中新创建的文件
4. **删除的代码文件** - 在该子工作区中被删除的文件（标注原因）

**格式要求**：
```markdown
## 涉及的代码文件

### 核心文件（修改/新增）
| 文件 | 操作 | 说明 |
|------|------|------|
| `SaveManager.cs` | 修改 | 添加自动存档逻辑 |
| `AutoSaveService.cs` | 新增 | 自动存档服务 |

### 相关文件（引用/依赖）
| 文件 | 关系 |
|------|------|
| `TimeManager.cs` | 触发存档的时间源 |
| `PersistentManagers.cs` | 管理器注册 |
```

### 主工作区 Memory 要求

主工作区的 `memory.md` **必须**汇总所有子工作区涉及的代码文件：

1. **关键文件索引** - 按功能分类列出所有核心代码文件
2. **文件修改历史** - 记录哪些文件在哪个子工作区被修改
3. **跨子工作区文件** - 标注被多个子工作区修改的文件（高风险文件）

**格式要求**：
```markdown
## 关键文件索引

### 存档系统核心
| 文件 | 涉及的子工作区 | 最后修改 |
|------|---------------|---------|
| `SaveManager.cs` | 3.7.2, 3.7.4, 3.7.5 | 2026-02-05 |
| `SaveDataDTOs.cs` | 3.7.3, 3.7.4 | 2026-02-04 |

### 动态对象系统
| 文件 | 涉及的子工作区 | 最后修改 |
|------|---------------|---------|
| `DynamicObjectFactory.cs` | 3.7.2, 3.7.3 | 2026-02-03 |
```

### Memory 同步规则

**🔴 强制更新顺序：先子后主（2026-02-15 强化）**

> **核心原则**：子 memory 是详细记录，主 memory 是摘要索引。必须先有详细记录，再有摘要。
> **违反后果**：只更新主 memory 不创建/更新子 memory = 详细信息永久丢失，不可接受。

**强制执行顺序**：

```
第一步：创建/更新子工作区 memory.md（详细内容）
    ↓ 子 memory 写入完成后
第二步：更新主工作区 memory.md（摘要+索引）
```

**🔴 执行前自检（每次更新 memory 前必须在脑中确认）**：
- 我现在要写入的是子 memory 还是主 memory？
- 如果是主 memory → 子 memory 是否已经写入完成？如果没有 → 停下，先写子 memory
- 如果是子 memory → 正确，继续执行
- **绝对不允许先写主 memory 再写子 memory，即使"顺手"也不行**

**具体要求**：

1. **第一步：子 memory（详细记录）**
   - 如果子工作区没有 memory.md → 必须先创建
   - 记录完整的会话内容：用户需求原文、完成任务、修改文件、解决方案、遗留问题
   - 记录所有涉及的代码文件（修改/新增/引用）
   - 这是信息的"源头"，必须详尽

2. **第二步：主 memory（摘要索引）**
   - 在子 memory 完成后，更新主 memory 的对应会话记录
   - 主 memory 只记录摘要：任务概述、关键决策、核心文件、子工作区状态
   - 主 memory 的子工作区索引表必须同步更新

3. **禁止反向操作**
   - ❌ 禁止只更新主 memory 而不创建/更新子 memory
   - ❌ 禁止先更新主 memory 再更新子 memory（顺序不可颠倒）
   - ❌ 禁止跳过子 memory 直接在主 memory 写详细内容

3.5. **🔴 继承场景例外规则（2026-02-16 新增）**
   - **上下文压缩时（agentStop + 检测到系统压缩提示 `Conversation above has been summarized` 等）**：只更新子 memory + 创建继承快照，**不更新主 memory**
   - **正常情况（非压缩）**：子 memory 更新后，**必须**更新主 memory
   - **原因**：压缩时上下文已在边缘，额外读写主 memory 容易导致 Hook 超时或失控。主 memory 的同步留给继承后的新对话来做
   - **继承后新对话的责任**：在继承恢复完成并开始工作后，第一次 agentStop 时必须补充更新主 memory（将继承前遗漏的摘要补上）

4. **工作区迭代结束检查**
   - 每次工作区迭代结束前，必须按以下顺序检查：
   - 检查清单：
     - [ ] ①子 memory 已创建（如果是新工作区）
     - [ ] ②子 memory 已记录本次修改的所有文件和详细内容
     - [ ] ③主 memory 已同步子 memory 的摘要记录
     - [ ] ④主 memory 的子工作区索引表和"当前状态"已更新

5. **代码修改必须有效记录**
   - 每次代码修改都必须在当前会话的 memory 中体现
   - 不允许"隐性修改"（修改了代码但 memory 中没有记录）

### 核心讨论触发记录

以下情况也必须触发 memory 记录（即使没有代码修改）：

1. **架构决策** - 讨论并确定了重要的架构方向
2. **问题分析** - 深入分析了某个 bug 或问题的根因
3. **设计变更** - 决定改变原有的设计方案
4. **技术债务识别** - 发现并记录了需要后续处理的技术债务
5. **锐评执行** - 执行了外部架构师的锐评指令

**记录格式**：
```markdown
### 会话 N - YYYY-MM-DD（讨论/分析）

**讨论主题**: [主题]

**核心结论**:
1. [结论1]
2. [结论2]

**后续行动**:
- [ ] [待办事项]
```

### 违规后果

不遵守代码文件追踪规范会导致：
- 项目历史不可追溯
- 无法定位问题引入的时间点
- 跨会话协作困难
- 技术债务失控


---

## 🔴 子工作区嵌套规则（2026-02-15 新增）

### 套娃结构说明

子工作区内部可以再包含子工作区（即"子子工作区"），形成多层嵌套。例如：

```
.kiro/specs/999_全面重构_26.01.27/          # 主工作区（有 memory.md）
├── memory.md
├── 3.7.3消失bug/                           # 子工作区（有 memory.md）
│   ├── memory.md
│   └── 0_自动化GUID管理/                   # 子子工作区（也必须有 memory.md）
│       ├── memory.md
│       ├── requirements.md
│       ├── design.md
│       └── tasks.md
```

### 核心规则

1. **无论嵌套多深，只要是包含 requirements.md / design.md / tasks.md 等工作文档的文件夹，就必须有 memory.md**
2. **判断标准**：文件夹内有编号命名的子文件夹（如 `0_xxx/`）或有 `requirements.md` 等工作文档 → 该文件夹是工作区 → 必须有 memory.md
3. **例外**：`old/`、`code-reaper-reviews/`、`phases/`、`design/`（纯归档/纯文档目录）不需要 memory.md

### Memory 同步链

多层嵌套时，memory 同步遵循"逐级上报"原则，**严格从最内层开始**：

```
第一步：子子 memory 更新（最详细）
    ↓
第二步：子 memory 追加摘要（中等详细）
    ↓
第三步：主 memory 更新状态（最简摘要）
```

- 子子工作区完成任务后，**先**更新自己的 memory.md
- **然后**在上一级（子工作区）的 memory.md 中追加摘要
- **最后**在主工作区的 memory.md 中更新状态
- **严禁跳级**：不允许跳过中间层直接更新主 memory

### 简化处理

对于历史遗留的缺失 memory 的子工作区：
- 如果该子工作区已完成且不再活跃，可以创建一个简化版 memory.md，只包含模块概述和完成状态
- 如果该子工作区仍在活跃开发中，必须创建完整格式的 memory.md


---

## 🔴 对话编号规范（2026-02-16 新增）

### 编号定义

- **会话 N**：一个全新的对话（用户主动开启新话题或新工作区的第一次对话）
- **续 N**：同一个对话因上下文压缩/继承而延续的次数

### 递增规则

| 场景 | 编号变化 | 示例 |
|------|---------|------|
| 用户开启全新话题 | 会话 N+1 | 会话 1 → 会话 2 |
| 上下文压缩后继承恢复 | 对话编号不变，续 N+1 | 会话 1（续25）→ 会话 1（续26） |
| 首次会话无续接 | 会话 N（无续） | 会话 1 |

### 编号唯一来源

- **唯一根据是 memory.md**，每次获取只从 memory 获取
- 无 memory / 无法确定工作区时：不使用编号（兜底）
- 后续从无编号转为有编号（比如迭代中创建了 memory），以 memory 为主

### 三处统一

编号在以下三处必须严格一致：

| 位置 | 格式 | 示例 |
|------|------|------|
| memory.md 会话标题 | `### 会话 N（续M）` | `### 会话 1（续26）` |
| 输出完毕标记 | `【会话N-续M输出完毕】` | `【会话1-续26输出完毕】` |
| 快照文件名 | `{日期}_会话N_续M.md` | `2026-02-16_会话1_续26.md` |

### 关键原则

- 继承恢复 ≠ 新会话。对话编号不变，只有续编号递增
- Hook 记录员从输出完毕标记中提取编号，用于快照命名和 memory 记录
- 旧工作区没有统一编号格式时，从 memory 最新记录推算


---

## 🔴 继承会话 Memory 文件夹规范（2026-02-16 新增）

### 概述

"继承会话memory"是一种用空间换效率的机制：在对话即将被上下文总结压缩时，将当前对话的完整快照保存到文件，供继承后的新对话读取，避免压缩导致的信息丢失。

### 文件夹位置

每个子工作区根目录内，与 `memory.md` 同级：

```
.kiro/specs/农田系统/10.0.2农BUG农SO/     # 子工作区
├── memory.md                              # 常规记忆文档
├── 继承会话memory/                         # ★ 继承快照文件夹
│   ├── 2026-02-15_会话4_续1.md
│   └── 2026-02-16_会话5.md
├── requirements.md
├── design.md
└── tasks.md
```

### 文件命名格式

```
{日期}_{会话N}_{续N}.md
```

- 日期格式：`YYYY-MM-DD`
- 会话编号：与 memory.md 中的会话编号一致
- 续N：如果是继承后的续接会话，标注续接次数；首次会话不加"续"
- 示例：
  - `2026-02-15_会话4.md` — 会话4被压缩时的快照
  - `2026-02-15_会话4_续1.md` — 会话4续1被压缩时的快照
  - `2026-02-16_会话5.md` — 会话5被压缩时的快照

### 文件内容模板

```markdown
# 继承快照 - {会话编号}

> 对话时间特征：{对话开始的大致时间或日期}
> 工作区：{子工作区路径}
> 创建时间：{快照创建时间}

## 用户 Prompt 完整摘抄

[完整摘抄用户在本次对话中的所有 prompt，不做删减]

## AI 进度摘要

### 已完成
- [逐条列出已完成的任务/修改]

### 进行中 / 未完成
- [逐条列出正在进行或尚未完成的任务]

### 关键决策
- [本次对话中做出的重要决策]

## 修改文件列表

| 文件 | 操作 | 说明 |
|------|------|------|
| `文件名.cs` | 修改/新增/删除 | 简短说明 |

## 智能补充（可能丢失的上下文）

[AI 判断在压缩过程中可能丢失的重要上下文信息，主动补充记录]
[例如：讨论中的关键分歧、用户的特殊要求、尚未写入文档的口头约定等]
```

### 触发条件

- **时机**：`agentStop` 阶段
- **条件**：检测到系统自动生成的上下文压缩提示（`Conversation above has been summarized`、`about to reach the agent context limit`、`summarizing earlier messages` 等）
- **原理**：此时对话A还未跳转到对话B，原始内容尚未被压缩，是保存快照的完美时机
- **执行者**：由 `memory-update-check.kiro.hook` 的压缩检测分支负责
- 🔴 **不要与继承恢复混淆**：`CONTEXT TRANSFER` / `Here is a summary` 是继承后新对话（对话B）的标志，不是压缩触发条件

### 与常规 Memory 的关系

| 维度 | memory.md（常规记忆） | 继承会话memory（快照） |
|------|----------------------|----------------------|
| 更新频率 | 每次 agentStop | 仅检测到上下文总结时 |
| 内容详细度 | 结构化摘要 | 完整快照（含用户原文） |
| 用途 | 长期项目记忆 | 继承恢复时的详细参考 |
| 生命周期 | 永久保留 | 暂不清理（待后续制定策略） |

### 注意事项

1. 快照文件创建后不可修改、不可删除（遵循文档堆积原则）
2. 用户 prompt 完整摘抄是最低保证，不允许省略或缩写
3. AI 进度摘要应简洁但完整，覆盖所有已完成和未完成的工作
4. "智能补充"部分鼓励 AI 主动记录可能在压缩中丢失的上下文
5. 清理策略暂不处理，后续由用户给出指令再制定
