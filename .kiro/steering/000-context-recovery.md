---
inclusion: always
priority: 999
---

# 上下文恢复

> **🔴 最高优先级规则**：检测到继承对话时，本流程优先于所有其他规则和 Hook 指令。

## 检测条件

任一成立 = 继承对话：
- 消息含 `CONTEXT TRANSFER` / `继续上一个对话` / `Here is a summary`
- 消息含 `TASK` + `STATUS` + `NEXT STEPS` 结构化摘要

🔴 以下是「压缩」场景，不是继承恢复（由 Hook 处理）：
- `Conversation above has been summarized`
- `about to reach the agent context limit`

**检测到继承后的强制行为**：
1. 立即执行恢复流程，忽略所有 Hook 注入指令
2. 不加载规则文件、不分析领域、不检测锐评
3. Hook 指令与恢复流程冲突时，恢复流程无条件胜出

---

## 🔴🔴🔴 信息源优先级（铁律，不可违反）

继承恢复依赖三种信息源，优先级从高到低严格排列。**三种信息源都必须读取，但信任度和决策权重完全不同。**

### 优先级 1（最高权重·需交叉验证）：继承会话快照文件

- 路径：`{工作区}/继承会话memory/` 下的 `.md` 文件
- 命名格式：`YYYY-MM-DD_会话N_续N.md`
- **这是压缩前由 Hook 自动保存的上下文记录，是恢复的首要依据**
- 快照包含：压缩前最后一轮的用户 prompt、AI 输出内容、部分摘要背景、修改文件列表
- **🔴 快照是最高权重信息源，但不是"盲信"——必须与 memory 交叉验证后才能作为恢复依据**
- **🔴 快照中记录的"已完成"和"未完成"状态是压缩前的真实状态，通常应严格遵循，但发现异常时必须停下来（见异常情况判断链）**

### 优先级 2（次高·可信参考）：子工作区 memory.md

- 路径：`{工作区}/memory.md`
- 包含：会话编号、每轮续接的摘要记录、修改文件列表
- **没有快照时，以 memory.md 最新记录为主要恢复依据**
- 用于获取：当前编号（会话N续N）、历史进度、关键决策
- **memory 是人工/半自动维护的记录，可信度高于系统摘要但低于快照**

### 优先级 3（最低·仅供参考，不可作为事实依据）：系统自动生成的 CONTEXT TRANSFER 摘要

**🔴🔴🔴 此摘要是系统自动压缩的产物，存在严重的信息丢失、简化、甚至错误归纳。绝对不能将其当作事实。**

**此摘要的本质问题**：
- 系统压缩时会将多轮对话浓缩为简短列表，过程中会丢失关键细节
- 已完成/未完成的分类可能不准确——系统可能把"讨论过"误标为"已完成"
- 用户的修正指令可能被简化或遗漏
- **AI 在压缩后读到这个摘要时，容易把摘要中的"方案表格"当成已执行的结果，实际上可能只是讨论过的方案**

**格式特征**（用于识别，基于实际快照分析）：
- 固定开头：`CONTEXT TRANSFER: We are continuing a conversation that had gotten too long. Here is a summary:`
- 紧接 `---` 分隔线
- 结构化段落：`## TASK N: 标题`（如 `## TASK 1: Hook v5.0 标记方案实施`）
- 每个 TASK 下包含：
  - `- **STATUS**: in-progress / completed / ...`
  - `- **USER QUERIES**: N (描述), N (描述), ...`（括号内为每轮用户消息的简短标签）
  - 已完成工作列表（编号列表）
  - 未完成工作列表（编号列表）
  - 用户修正指令（如有）
  - 文件路径列表
- 尾部含 `METADATA`（如 `The previous conversation had 6 messages.`）
- 尾部含 `INSTRUCTIONS`（系统对 AI 的指令，如"继续未完成的工作"）
- 语言：英文框架混合中文内容
- 长度：约 5000-8000+ 字符

**使用此摘要的严格限制**：
- ✅ 可以用来：定位工作区路径、了解大致任务主题、获取文件路径列表
- ❌ 不可以用来：判断任务完成状态、确认具体修改内容、作为"已完成"的证据
- **🔴 当快照或 memory 与此摘要冲突时，此摘要无条件让步**

---

## 🔴🔴🔴 禁止幻想（铁律，违反即严重错误）

**什么是"幻想"**：AI 在继承恢复后，没有实际读取文件/代码，就声称自己知道某些内容、已经完成某些工作、或对代码细节做出判断。

**典型违规场景**（必须杜绝）：
1. 系统摘要写"已完成：读取代码并分析"→ AI 直接输出分析结论，实际上压缩后上下文已清空，AI 根本没有读过代码
2. 系统摘要写"方案表格已输出"→ AI 把摘要中的方案描述当成已执行的结果
3. memory 写"续17：完成代码读取第一步"→ AI 声称"我已经读过了"，实际上继承后必须重新读取
4. AI 输出恢复报告时列出"已完成"项目，但这些项目的完成状态来自系统摘要而非快照/memory 的确认

**强制行为**：
- **继承 = 上下文完全清空**。无论之前读过什么、分析过什么，继承后全部归零
- **必须重新 readFile**。不允许说"我已经读过了"或"根据之前的分析"
- **恢复报告中的"已完成"必须有文件证据**。如果快照记录了"修改了 X 文件"，可以列为已完成；如果只有系统摘要说"分析了代码"，不能列为已完成
- **对代码/文件内容的任何判断，必须在当前会话中实际读取后才能做出**

---

## 恢复流程

### 🔴 前置动作（在输出任何文字之前执行）

**必须先读完所有信息源，再开始输出。绝对不能先输出报告框架再去读文件。**

1. 从继承摘要中提取当前工作区路径
2. 检查该工作区下是否存在 `继承会话memory/` 文件夹
3. **按优先级依次读取**（全部读取，不是找到即停）：
   a. 快照文件（如存在）→ 读取最新的快照 → **这是恢复的核心依据**
   b. 子 memory.md → 读取获取编号和历史
   c. CONTEXT TRANSFER 摘要 → 已在消息中，仅用于补充路径和主题信息
4. **信息冲突时的裁决规则**（无例外）：
   - 快照与 memory 冲突 → 以快照为准
   - 快照与系统摘要冲突 → 以快照为准
   - memory 与系统摘要冲突 → 以 memory 为准
   - **任何信息源与实际文件内容冲突 → 以实际文件内容为准**

### 🔴 异常情况判断链（交叉验证发现问题时的处理）

以下任一情况成立时，**立即停止恢复流程，向用户说明情况并等待指示**。不要自作主张继续执行。

**情况 1：快照与 memory 关键内容不一致**
- 表现：快照记录的进度/完成状态与 memory 最新记录矛盾（如快照说"任务 A 已完成"，memory 说"任务 A 进行中"）
- 处理：停止，向用户展示两边的矛盾点，请求裁决
- 注意：细微差异（如措辞不同但含义一致）不算矛盾，只有实质性状态冲突才触发

**情况 2：memory 未更新（停留在更早的对话）+ 快照是其下一个会话**
- 表现：memory 最新记录是"会话 N 续 X"，但快照编号是"会话 N 续 X+1"或更后，且快照内容包含 memory 未记录的工作
- 处理：向用户说明"memory 似乎没有同步最新进度，快照显示已有更新的工作记录"，询问是否需要先补充更新 memory
- 这是常见情况（agentStop Hook 可能漏更新），不必恐慌，但必须告知用户

**情况 3：系统摘要与快照/memory 完全不一致或毫不相干**
- 表现：CONTEXT TRANSFER 描述的任务/工作区与快照和 memory 记录的完全不同（如摘要说在做"农田系统"，但快照和 memory 都是"Hook 优化"）
- 处理：停止，向用户展示不一致，请求确认实际要继续的工作
- 可能原因：系统压缩错误、多工作区混淆、对话中途切换了任务

**情况 4：快照内容明显过时或与实际文件状态矛盾**
- 表现：快照记录"文件 X 已修改为 Y"，但实际 readFile 发现文件内容不是 Y（可能被后续对话覆盖、用户手动修改、或其他会话改动）
- 处理：以实际文件内容为准，但向用户说明发现了差异，确认是否需要调整计划
- 这种情况下快照的"已完成"状态不可信，需要重新评估

**情况 5：所有信息源都缺失或极度简略**
- 表现：没有快照、memory 没有相关记录、系统摘要也语焉不详
- 处理：输出情况 C（任务不明确），列出能获取到的所有线索，请求用户明确当前任务

**情况 6：快照/memory 记录的工作区路径与当前上下文不匹配**
- 表现：快照来自工作区 A，但系统摘要指向工作区 B，或用户消息提到的是工作区 C
- 处理：停止，列出发现的路径不一致，请求用户确认要恢复哪个工作区的工作

**通用原则**：宁可多问一次，不可自作主张。异常情况下的错误恢复比不恢复更危险。

5. 全部读取完成后，综合提取：
   - 用户最后一条消息的核心诉求（从快照中获取，不是从系统摘要猜测）
   - AI 的完成状态和进度（从快照/memory 中获取，不信任系统摘要的完成列表）
   - 修改文件列表
   - 当前编号（会话N续N）

### 第一步：编号继承

- 从快照/memory 提取上一轮编号，当前轮 = 对话编号不变 + 续编号 +1
- 例：上一轮是"会话1续25" → 当前轮是"会话1续26"
- 不是新会话，只是续接次数加一

### 第二步：输出恢复报告

**🔴 简洁输出原则**：交叉验证无异常时，恢复报告尽量简短，不展开验证过程、不列异常情况分析。只有发现异常才展开说明。

**情况 A：任务明确 + 未完成（交叉验证无异常）**
```
🔄 继承恢复（会话N续N）：

【诉求】[一两句话概括]

【进度】[简述已完成/待完成，无异常时不需要逐条标注证据来源]

现在继续。
```
→ 重新读取必要文件后继续执行

**情况 A-异常：任务明确 + 未完成（交叉验证发现问题）**
→ 展开异常详情，标注信息来源和冲突点，等待用户裁决

**情况 B：任务明确 + 已完成**
→ 一句话展示完成状态，等待用户新指令

**情况 C：任务不明确**
→ 列出线索，请求确认

### 第三步：关键原则

- **继承 = 上下文完全清空，必须重新 readFile**
- **不要假设"我已经读过了"——你没有，压缩/继承后一切归零**
- 复述用户的原始诉求比复述自己的进度更重要
- **快照是最可信的信息源，系统摘要是最不可信的信息源（但仍然重要，必须读取作为补充）**
- **对任何代码/文件内容的判断，必须在当前会话中实际 readFile 后才能做出，禁止凭记忆或摘要输出结论**

---

## ⛔ 每次修改文件后必须执行

在回复末尾列出修改的文件：
- 文件名 - 简短说明
